{% extends "layout_t.html" %}

{% block header %}
   <title>WAMP Compared</title>
   <meta name="description" content="Comparison of WAMP with MQTT, STOMP, AMQP, XMPP and others.">
   <link rel="stylesheet" href="{{ url_for('static', filename='css/page_t_compared.css') }}">

   <a id="top"></a>
{% endblock%}

{% block content %}

<div id="page_wrapper">

   <p class="introline">
      Alright. So how does WAMP stack up versus other technologies?<br>
      Do we really need another wheel? Yes. Please read below to find out why we think so.
   </p>
   <br>

   <p>
      Below you'll find a table comparing WAMP to other technologies according to <b>six criteria</b>:
      <ol>
         <li>
            <b>PubSub</b><br>
            Does it support Publish &amp; Subscribe out of the box?
         </li>
         <li>
            <b>RPC</b><br>
            Does it support Remote Procedure Calls out of the box?
         </li>
         <li>
            <b>Routed RPC</b><br>
            Does it support <a href="/why/#unified_routing">routed</a> (not only point-to-point) Remote Procedure Calls?
         </li>
         <li>
            <b>Web native</b><br>
            Does it run <i>natively</i> on the Web (without tunneling or bridging)?
         </li>
         <li>
            <b>Cross Language</b><br>
            Does it work from different programming languages and run-times?
         </li>
         <li>
            <b>Open Standard</b><br>
            Is there an open, official specification implemented by different vendors?
         </li>
      </ol>
   </p>

   <p class="inset">
      See also:
      <a href="https://into.aalto.fi/download/attachments/12324178/Huang_Fuguo_thesis_2.pdf">Web Technologies for the Internet of Things</a>
      - A master thesis which contains a comparison of WAMP, MQTT, CoAP, REST, SOAP, STOMP and MBWS for IoT applications.
   </p>

<!--
   <p class="citation">
      "Moving onto the part of Internet of Things, we integrated a sensor (light sensor) and
      an actuator (light switch/dimmer) into a web application. The major feature of the
      sensor (sending data) and that of the actuator (commanding and coniguration) perfectly
      match the massage patterns, Pub/Sub and RPC, which WAMP provides."
   </p>      
-->



   <table id="comparison">
      <tr>
         <td>Technology</td>
         <td>PubSub</td>
         <td>RPC</td>
         <td>Routed RPC</td>
         <td>Web native</td>
         <td>Cross Language</td>
         <td>Open Standard</td>
      </tr>

      <tr style="border-bottom: 3px solid #fa72c6;">
         <td><a href="/">WAMP</a></td>
         <td>&#10004;</td>
         <td>&#10004;</td>
         <td>&#10004;</td>
         <td>&#10004;</td>
         <td>&#10004;</td>
         <td>&#10004;</td>
      </tr>

      <tr>
         <td><a href="#ajax">AJAX</a></td>
         <td></td>
         <td>&#10004;</td>
         <td></td>
         <td>&#10004;</td>
         <td>&#10004;</td>
         <td></td>
      </tr>

      <tr>
         <td><a href="#amqp">AMQP</a></td>
         <td>&#10004;</td>
         <td>(&#10004;)</td>
         <td></td>
         <td></td>
         <td>&#10004;</td>
         <td>&#10004;</td>
      </tr>

      <tr>
         <td><a href="#thrift">Apache Thrift</a></td>
         <td></td>
         <td>&#10004;</td>
         <td></td>
         <td></td>
         <td>&#10004;</td>
         <td></td>
      </tr>

      <tr>
         <td><a href="#capnproto">Capn'n'Proto</a></td>
         <td></td>
         <td>&#10004;</td>
         <td></td>
         <td></td>
         <td>&#10004;</td>
         <td></td>
      </tr>

      <tr>
         <td><a href="#comet">Comet</a></td>
         <td></td>
         <td></td>
         <td></td>
         <td>&#10004;</td>
         <td>&#10004;</td>
         <td></td>
      </tr>

      <tr>
         <td><a href="#dds">OMG DDS</a></td>
         <td>&#10004;</td>
         <td></td>
         <td></td>
         <td></td>
         <td>&#10004;</td>
         <td>&#10004;</td>
      </tr>

      <tr>
         <td><a href="#dbus">D-Bus</a></td>
         <td></td>
         <td></td>
         <td></td>
         <td></td>
         <td>&#10004;</td>
         <td></td>
      </tr>

      <tr>
         <td><a href="#corba">CORBA</a></td>
         <td>&#10004;</td>
         <td>&#10004;</td>
         <td></td>
         <td></td>
         <td>&#10004;</td>
         <td>&#10004;</td>
      </tr>

      <tr>
         <td><a href="#dcom">DCOM</a></td>
         <td>&#10004;</td>
         <td>&#10004;</td>
         <td></td>
         <td></td>
         <td>&#10004;</td>
         <td></td>
      </tr>

      <tr>
         <td><a href="#jms">Java JMS</a></td>
         <td>&#10004;</td>
         <td></td>
         <td></td>
         <td></td>
         <td></td>
         <td>&#10004;</td>
      </tr>

      <tr>
         <td><a href="#rmi">Java RMI</a></td>
         <td></td>
         <td>&#10004;</td>
         <td></td>
         <td></td>
         <td></td>
         <td>&#10004;</td>
      </tr>

      <tr>
         <td><a href="#jsonrpc">JSON-RPC</a></td>
         <td></td>
         <td>&#10004;</td>
         <td></td>
         <td>&#10004;</td>
         <td>&#10004;</td>
         <td>&#10004;</td>
      </tr>

      <tr>
         <td><a href="#mbws">MBWS</a></td>
         <td colspan="6">?</td>
      </tr>

      <tr>
         <td><a href="#mqtt">MQTT</a></td>
         <td>&#10004;</td>
         <td></td>
         <td></td>
         <td></td>
         <td>&#10004;</td>
         <td>&#10004;</td>
      </tr>

      <tr>
         <td><a href="#rest">REST</a></td>
         <td></td>
         <td>&#10004;</td>
         <td></td>
         <td>&#10004;</td>
         <td>&#10004;</td>
         <td></td>
      </tr>

      <tr>
         <td><a href="#soap">SOAP</a></td>
         <td></td>
         <td>&#10004;</td>
         <td></td>
         <td>&#10004;</td>
         <td>&#10004;</td>
         <td>&#10004;</td>
      </tr>

      <tr>
         <td><a href="#socketio">socket.io</a></td>
         <td>&#10004;</td>
         <td></td>
         <td></td>
         <td>&#10004;</td>
         <td></td>
         <td></td>
      </tr>

      <tr>
         <td><a href="#sockjs">SockJS</a></td>
         <td></td>
         <td></td>
         <td></td>
         <td>&#10004;</td>
         <td>&#10004;</td>
         <td></td>
      </tr>

      <tr>
         <td><a href="#stomp">STOMP</a></td>
         <td>&#10004;</td>
         <td></td>
         <td></td>
         <td>&#10004;</td>
         <td>&#10004;</td>
         <td>&#10004;</td>
      </tr>

      <tr>
         <td><a href="#xmlrpc">XML-RPC</a></td>
         <td></td>
         <td>&#10004;</td>
         <td></td>
         <td>&#10004;</td>
         <td>&#10004;</td>
         <td>&#10004;</td>
      </tr>

      <tr>
         <td><a href="#xmpp">XMPP</a></td>
         <td>&#10004;</td>
         <td></td>
         <td></td>
         <td>&#10004;</td>
         <td>&#10004;</td>
         <td>&#10004;</td>
      </tr>

      <tr>
         <td><a href="#zmq">ZMQ</a></td>
         <td>&#10004;</td>
         <td></td>
         <td></td>
         <td></td>
         <td>&#10004;</td>
         <td></td>
      </tr>

   </table>


   <a id="ajax"></a>
   <div class="section">
      <h1>AJAX</h1>
      <p>
         <a href="http://en.wikipedia.org/wiki/Ajax_(programming)">AJAX</a> is neither a protocol nor
         an API, but a programming pattern for JavaScript in browsers that uses HTTP requests
         to realize RPC-like communication between frontends (browsers) and backends.
      </p>
      <p>
         AJAX being a programming practice, isn't a complete RPC system either. You need to agree
         upon how calls, results and errors are formatted and serialized.
         See <a href="#jsonrpc">JSON-RPC</a> and <a href="#xmlrpc">XML-RPC</a>.
      </p>
      <p>
         Even when you bake some RPC mechanism using AJAX techniques, this is point-to-point RPC:
         calls aren't routed between different servers or application components, but strictly
         travel from point (browser) to point (server the browser is connected to).
      </p>
      <p>
         Further, AJAX does not provide PubSub - in fact, it doesn't address how to actively push any
         kind of information from server to client (however, see <a href="#comet">Comet</a>).
      </p>
      <p>
         Since AJAX uses plain HTTP for wrapping any kind of RPC-like messages, it suffers
         from the overhead and limitations intrinsic to HTTP. E.g. you cannot have more than
         6-8 concurrent RPCs, as browsers will limit the number of HTTP connections to a single
         destination.
      </p>
      <a href="#top" class="top">Top</a>
   </div>

   <a id="amqp"></a>
   <div class="section">
      <h1>AMQP</h1>
      <p>
         <a href="http://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">AMQP</a> is a ...
<!--
   Doing RPC with AMQP requires extra work: https://www.rabbitmq.com/tutorials/tutorial-six-python.html
-->         
      </p>
      <a href="#top" class="top">Top</a>
   </div>

   <a id="thrift"></a>
   <div class="section">
      <h1>Apache Thrift</h1>
      <p>
         <a href="https://thrift.apache.org/">Apache Thrift</a> is a cross-language RPC system.
         It uses a statically typed approach where procedures first need to be described using
         an <a href="http://en.wikipedia.org/wiki/Interface_definition_language">Interface Definition Language</a>,
         and then code for language specific bindings needs to be generated.
      </p>
      <p>
         Compared to WAMP, Apache Thrift only provides RPC as an application messaging pattern, not PubSub.
      </p>
      <p>
         While Thrift uses a statically typed approach involving IDLs and code generation, WAMP follows
         a dynamic typing approach. There is no IDL and no code generation. Instead, WAMP will provide
         <a href="https://github.com/tavendo/WAMP/blob/master/spec/advanced.md#reflection">run-time reflection</a>
         capabilities instead.
      </p>
      <p>
         Different from WAMP, Thrift also (only) runs over raw TCP and cannot (natively) run over the Web,
         right into the browser. It is designed for communication within the data-center, between backend
         components.
      </p>
      <p>
         Similar to WAMP, Apache Thrift features different serialization formats, and also is able to
         compress a transport (using zlib). WAMP currently offers two serializations (JSON and MsgPack)
         and can run over standard, compressed WebSocket ("permessage-deflate") to further reduce wire traffic.
      </p>
      <p>
         Apache Thrift currently has a lot more language bindings than WAMP and is used/pushed by Facebook.
      </p>
      <a href="#top" class="top">Top</a>
   </div>

   <a id="capnproto"></a>
   <div class="section">
      <h1>Capn'n'Proto</h1>
      <p>
         <a href="http://kentonv.github.io/capnproto/">Capn'n'Proto</a> is a ...
      </p>
      <a href="#top" class="top">Top</a>
   </div>

   <a id="comet"></a>
   <div class="section">
      <h1>Comet</h1>
      <p>
         <a href="http://en.wikipedia.org/wiki/Comet_(programming)">Comet</a> is a ...
      </p>
      <a href="#top" class="top">Top</a>
   </div>


   <a id="dds"></a>
   <div class="section">
      <h1>OMG DDS</h1>
      <p>
         OMG's <a href="http://en.wikipedia.org/wiki/Data_Distribution_Service">Data Distribution Service</a> is a ...
      </p>
      <a href="#top" class="top">Top</a>
   </div>

   <a id="dbus"></a>
   <div class="section">
      <h1>D-Bus</h1>
      <p>
         <a href="http://en.wikipedia.org/wiki/D-Bus">D-Bus</a> is a ...
      </p>
      <a href="#top" class="top">Top</a>
   </div>

   <a id="corba"></a>
   <div class="section">
      <h1>CORBA</h1>
      <p>
         <a href="http://en.wikipedia.org/wiki/Corba">CORBA</a> is a ...
         CORBA Notification Services
      </p>
      <a href="#top" class="top">Top</a>
   </div>

   <a id="dcom"></a>
   <div class="section">
      <h1>DCOM</h1>
      <p>
         <a href="http://en.wikipedia.org/wiki/Dcom">DCOM</a> is a ...
         <a href="http://msdn.microsoft.com/library/cc201989.aspx">specification</a>
         COM+ Event Service
      </p>
      <a href="#top" class="top">Top</a>
   </div>

   <a id="jms"></a>
   <div class="section">
      <h1>Java Message Service (JMS)</h1>
      <p>
         <a href="http://en.wikipedia.org/wiki/Java_Message_Service">Java Message Service (JMS)</a> is
         a Java <b>API</b> specification for an (abstract) PubSub service.
         Programs are written in Java against the JMS API.
         JMS does not provide RPC (but see <a href="#rmi">Java RMI</a>).
      </p>
      <p>
         JMS does not guarantee interoperability between implementations, and the JMS-compliant messaging
         system in use may need to be deployed on both client and server. 
      </p>
      <p>
         In contrast, WAMP is a wire-level protocol specification. Conforming WAMP implementations will
         be able to talk transparently to each other, and different implementations can be mixed and
         matched in one larger system.
      </p>
<!--      
      https://blogs.oracle.com/theaquarium/entry/jms_over_websocket
      http://www.parleys.com/play/52509ef4e4b0c4f11ec57671/about
      http://kaazing.com/products/editions/kaazing-websocket-gateway-jms/
      http://jmesnil.net/stomp-websocket/doc/

      JMS-over-STOMP-over-WebSocket

      STOMP does not expose the full JMS feature set.
      It's not a standard.
-->
      <a href="#top" class="top">Top</a>
   </div>

   <a id="rmi"></a>
   <div class="section">
      <h1>Java RMI</h1>
      <p>
         <a href="http://en.wikipedia.org/wiki/Java_remote_method_invocation">Java RMI</a> is a ...
      </p>
      <a href="#top" class="top">Top</a>
   </div>

   <a id="jsonrpc"></a>
   <div class="section">
      <h1>JSON-RPC</h1>
      <p>
         <a href="http://json-rpc.org/">JSON-RPC</a> is a ...
      </p>
      <a href="#top" class="top">Top</a>
   </div>

   <a id="mbws"></a>
   <div class="section">
      <h1>MBWS</h1>
      <p>
         <a href="https://tools.ietf.org/id/draft-hapner-hybi-messagebroker-subprotocol-03.html">MBWS</a> is a ...
      </p>
      <a href="#top" class="top">Top</a>
   </div>

   <a id="mqtt"></a>
   <div class="section">
      <h1>MQTT</h1>
      <p>
         <a href="http://en.wikipedia.org/wiki/Mqtt">MQTT</a> is a ...
      </p>
      <a href="#top" class="top">Top</a>
   </div>

   <a id="rest"></a>
   <div class="section">
      <h1>REST</h1>
      <p>
         <a href="http://en.wikipedia.org/wiki/Representational_State_Transfer">REST</a> is neither a library, nor protocol or framework. It's a software architecture style. REST stands for "Representational State Transfer" and assumes that data should be transfered over network in one of the standard formats like HTML, XML or JSON and follows an architecture based on 6 limitations: 
         <ul>
            <li>Uniform Interface</li>
            <li>Stateless</li>
            <li>Cacheable</li>
            <li>Client-Server</li>
            <li>Layered System</li>
            <li>Code on Demand (optional)</li>
         </ul>
      </p>
      <p>
         In a World Wide Web, RESTful systems use URL for an information unit address, and http status codes for corresponding <a href="http://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> operations.
      </p>
      <p>
         It is difficult to compare the WAMP protocol and a software architecture paradigm. They both are multilayered and can use different data presentation format. But one of the clearest difference is that WAMP is bidirectional, while REST pattern is not. In RESTful applications only client acts as initiator for data manipulations, and there is no options about how server can send data to client. In contrast to this, WAMP workflow allows data to be transfered to and form server.
      </p>
      <p>
         Another difference is that REST deliberately uses URLs from the HTTP scheme which serve a dual function of <b>identifying</b> and <b>addressing</b> resources. With WAMP, URIs are formed <b>com.example.myprocedure</b> and only <b>identify</b>, but NOT address the procedure to be called. This means, the implementation of the procedure can reside anywhere - it's location is only known to the WAMP router. This provides location transparency for WAMP application components.
      </p>
      <p>
         There is no problem to use WAMP and REST together. For example, you can make basic CRUD-operations over HTTP using GET/POST/PUT/DELETE methods, and in parallel, use WAMP PubSub service for notifications about changes, and WAMP RPC's for making some explicit business logic operations (like sending SMS, or batch picture resizing and so on).
      </p>
   </div>

   <a id="soap"></a>
   <div class="section">
      <h1>SOAP</h1>
      <p>
         <a href="http://en.wikipedia.org/wiki/SOAP">SOAP</a> is a ...
<!--
         http://docs.oasis-open.org/wsn/wsn-ws_base_notification-1.3-spec-os.htm
         https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=wsn
-->
      </p>
      <p>
         Being based on <a href="http://en.wikipedia.org/wiki/XML_Information_Set">XML Information Set</a> and XML for serialization, SOAP is <i>extremely</i>
         verbose and inefficient on the wire. Any kind of binary application payload
         first needs to be encoded. Further, parsing and serialization
         with XML can produce significant CPU loads. For these reasons alone, SOAP
         is considered unsuitable for applications where wire level and battery
         efficiency come into play: IoT and mobile.
      </p>
      <p>
         SOAP usually runs over HTTP (or SMTP) as a transport. Recently, Microsoft
         published a specification for running <a href="http://msdn.microsoft.com/en-us/library/hh536812.aspx">SOAP over WebSocket</a>. This reduces
         the overhead induces by the HTTP protocol, allows for real bidirectional
         messaging but retains the vast inefficiency that comes from XML.
      </p>
      <p class="inset">
         "When relying on HTTP as a transport protocol and not using
         <a href="http://en.wikipedia.org/wiki/WS-Addressing">WS-Addressing</a> or an
         <a href="http://en.wikipedia.org/wiki/Enterprise_service_bus">ESB</a>, the roles of the interacting parties are fixed. Only one party (the client) can use the services of the other. Developers must use polling instead of notification in these common cases."<br>
         From: <a href="http://en.wikipedia.org/wiki/SOAP">Wikipedia on SOAP</a>
      </p>
      <p>
         In contrast, WAMP provides all roles to any client. A WAMP client can
         act as a Caller, Callee, Publisher and Subscriber, all at the same time.
         This works with all WAMP transports. WAMP has built transport independent addressing and routing right into the protocol.
      </p>
      <a href="#top" class="top">Top</a>
   </div>

   <a id="socketio"></a>
   <div class="section">
      <h1>socket.io</h1>
      <p>
         <a href="http://socket.io/">socket.io</a> is a client-server PubSub service implementation written in JavaScript. It uses node.js on server side, browser counter part and own communication protocol. Socket.IO uses WebSocket under the hood, when it's possible, but also has a polyfill as fallback.
      </p>
      <p>
         Comparing to WAMP, library allows you to subscribe to different topics, has a broadcast messages and message namespaces, which works like a realms in WAMP. Binary data transfer is possible, but that needs additional modules on both sides (<a href="https://github.com/nkzawa/socket.io-stream">socket.io-stream</a>) and additional amount of work for developers. They need to program that explicitly.
      </p>
      <p>
         Socket.IO does not provide remote procedure calls.
      </p>
      <a href="#top" class="top">Top</a>
   </div>

   <a id="sockjs"></a>
   <div class="section">
      <h1>SockJS</h1>
      <p>
         <a href="https://github.com/sockjs">SockJS</a> is a WebSocket emulation/polyfill library
         and provides a transport for raw, bidirectional, message-based communication between two
         directly connected peers (a browser and a server).
      </p>
      <p>
         The <a href="https://github.com/sockjs/sockjs-client">SockJS JavaScript client</a>
         adds a WebSocket-like API for JavaScript in browsers lacking native WebSocket support.
         The bidirectional communication capabilities of WebSocket are emulated using various
         mechanism under the hood, including HTTP long-poll.
         The <a href="http://sockjs.github.io/sockjs-protocol/sockjs-protocol-dev.html">"emulation" protocol(s)</a>
         must be implemented on the server-side (available server implementations include NodeJS, Ruby and Erlang).
      </p>
      <p>
         Compared to WAMP, SockJS is lower level in that it is only concerned about the <i>transport layer</i>.
         It does not provide <i>application messaging patterns</i> like RPC or PubSub. 
      </p>
      <p>
         WAMP also provides a <a href="https://github.com/tavendo/WAMP/blob/master/spec/advanced.md#long-poll-transport">HTTP Long-poll transport</a> as a fallback for browsers lacking native WebSocket support. There are fewer fallback variants
         for WAMP than SockJS currently specified (only "long-poll"), but this transport also supports binary messages
         and all WAMP serialization formats (JSON and MsgPack currently).
         I am <a href="https://github.com/sockjs/sockjs-protocol/issues/74">unsure</a> if SockJS supports binary messages at all.
      </p>
      <a href="#top" class="top">Top</a>
   </div>

   <a id="stomp"></a>
   <div class="section">
      <h1>STOMP</h1>
      <p>
         <a href="http://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol">STOMP</a> is a ...
<!--         
         http://stomp.github.io/
         http://jmesnil.net/stomp-websocket/doc/
         http://stomp.github.io/stomp-specification-1.2.html
-->         
      </p>
      <a href="#top" class="top">Top</a>      
   </div>

   <a id="xmlrpc"></a>
   <div class="section">
      <h1>XML-RPC</h1>
      <p>
         <a href="http://en.wikipedia.org/wiki/XML-RPC">XML-RPC</a> is a ...
      </p>
      <a href="#top" class="top">Top</a>
   </div>

   <a id="xmpp"></a>
   <div class="section">
      <h1>XMPP</h1>
      <p>
         <a href="http://en.wikipedia.org/wiki/XMPP">XMPP</a> is a ...
<!--         
         http://xmpp.org/extensions/xep-0009.html
         XMPP is built for one-on-one communication, with “broadcasting” supported by a protocol extension called PubSub.
-->         
      </p>
      <a href="#top" class="top">Top</a>
   </div>

   <a id="zmq"></a>
   <div class="section">
      <h1>ZMQ</h1>
      <p>
         <a href="http://en.wikipedia.org/wiki/Zero_MQ">ZMQ</a> is a light-weight,
         high-performance library for messaging between application components.
         It works without a server.
         http://zeromq.org/whitepapers:brokerless
      </p>
      <p>
         While ZMQ has a request-response message exchange pattern ("REQ-REP sockets"),
         it does not support RPC out of the box. There exist libraries (e.g.
         <a href="http://zerorpc.dotcloud.com/">ZeroRPC</a> by Docker or
         <a href="https://github.com/thriftzmq/thriftzmq-java">ThriftZMQ</a>) that layer
         on top of ZMQ to provide applications with first-class RPC services.
      </p>
      <a href="#top" class="top">Top</a>
   </div>

</div>

{% endblock%}

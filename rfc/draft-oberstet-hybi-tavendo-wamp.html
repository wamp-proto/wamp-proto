<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>The Web Application Messaging Protocol</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Background"/>
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Protocol Overview"/>
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 Design Philosophy"/>
<link href="#rfc.section.1.3.1" rel="Chapter" title="1.3.1 Basic and Advanced Profiles"/>
<link href="#rfc.section.1.3.2" rel="Chapter" title="1.3.2 Application Code"/>
<link href="#rfc.section.1.3.3" rel="Chapter" title="1.3.3 Language Agnostic"/>
<link href="#rfc.section.1.3.4" rel="Chapter" title="1.3.4 Router Implementation Specifics"/>
<link href="#rfc.section.1.4" rel="Chapter" title="1.4 Relationship to WebSocket"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Conformance Requirements"/>
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Terminology and Other Conventions"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Realms, Sessions and Transports"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Peers and Roles"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Symmetric Messaging"/>
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Remote Procedure Call Roles"/>
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Publish &amp; Subscribe Roles"/>
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Peers with multiple Roles"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Building Blocks"/>
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Identifiers"/>
<link href="#rfc.section.5.1.1" rel="Chapter" title="5.1.1 URIs"/>
<link href="#rfc.section.5.1.2" rel="Chapter" title="5.1.2 IDs"/>
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Serializations"/>
<link href="#rfc.section.5.2.1" rel="Chapter" title="5.2.1 JSON"/>
<link href="#rfc.section.5.2.2" rel="Chapter" title="5.2.2 MsgPack"/>
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Transports"/>
<link href="#rfc.section.5.3.1" rel="Chapter" title="5.3.1 WebSocket Transport"/>
<link href="#rfc.section.5.3.2" rel="Chapter" title="5.3.2 Transport and Session Lifetime"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Messages"/>
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Extensibility"/>
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 No Polymorphism"/>
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Structure"/>
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Message Definitions"/>
<link href="#rfc.section.6.4.1" rel="Chapter" title="6.4.1 Session Lifecycle"/>
<link href="#rfc.section.6.4.2" rel="Chapter" title="6.4.2 Publish &amp; Subscribe"/>
<link href="#rfc.section.6.4.3" rel="Chapter" title="6.4.3 Routed Remote Procedure Calls"/>
<link href="#rfc.section.6.5" rel="Chapter" title="6.5 Message Codes and Direction"/>
<link href="#rfc.section.6.6" rel="Chapter" title="6.6 Extension Messages"/>
<link href="#rfc.section.6.7" rel="Chapter" title="6.7 Empty Arguments and Keyword Arguments"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Sessions"/>
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Session Establishment"/>
<link href="#rfc.section.7.1.1" rel="Chapter" title="7.1.1 HELLO"/>
<link href="#rfc.section.7.1.2" rel="Chapter" title="7.1.2 WELCOME"/>
<link href="#rfc.section.7.1.3" rel="Chapter" title="7.1.3 ABORT"/>
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Session Closing"/>
<link href="#rfc.section.7.2.1" rel="Chapter" title="7.2.1 Difference between ABORT and GOODBYE"/>
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Agent Identification"/>
<link href="#rfc.section.8" rel="Chapter" title="8 Publish and Subscribe"/>
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Subscribing and Unsubscribing"/>
<link href="#rfc.section.8.1.1" rel="Chapter" title="8.1.1 SUBSCRIBE"/>
<link href="#rfc.section.8.1.2" rel="Chapter" title="8.1.2 SUBSCRIBED"/>
<link href="#rfc.section.8.1.3" rel="Chapter" title="8.1.3 Subscribe ERROR"/>
<link href="#rfc.section.8.1.4" rel="Chapter" title="8.1.4 UNSUBSCRIBE"/>
<link href="#rfc.section.8.1.5" rel="Chapter" title="8.1.5 UNSUBSCRIBED"/>
<link href="#rfc.section.8.1.6" rel="Chapter" title="8.1.6 Unsubscribe ERROR"/>
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Publishing and Events"/>
<link href="#rfc.section.8.2.1" rel="Chapter" title="8.2.1 PUBLISH"/>
<link href="#rfc.section.8.2.2" rel="Chapter" title="8.2.2 PUBLISHED"/>
<link href="#rfc.section.8.2.3" rel="Chapter" title="8.2.3 Publish ERROR"/>
<link href="#rfc.section.8.2.4" rel="Chapter" title="8.2.4 EVENT"/>
<link href="#rfc.section.9" rel="Chapter" title="9 Remote Procedure Calls"/>
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Registering and Unregistering"/>
<link href="#rfc.section.9.1.1" rel="Chapter" title="9.1.1 REGISTER"/>
<link href="#rfc.section.9.1.2" rel="Chapter" title="9.1.2 REGISTERED"/>
<link href="#rfc.section.9.1.3" rel="Chapter" title="9.1.3 Register ERROR"/>
<link href="#rfc.section.9.1.4" rel="Chapter" title="9.1.4 UNREGISTER"/>
<link href="#rfc.section.9.1.5" rel="Chapter" title="9.1.5 UNREGISTERED"/>
<link href="#rfc.section.9.1.6" rel="Chapter" title="9.1.6 Unregister ERROR"/>
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Calling and Invocations"/>
<link href="#rfc.section.9.2.1" rel="Chapter" title="9.2.1 CALL"/>
<link href="#rfc.section.9.2.2" rel="Chapter" title="9.2.2 INVOCATION"/>
<link href="#rfc.section.9.2.3" rel="Chapter" title="9.2.3 YIELD"/>
<link href="#rfc.section.9.2.4" rel="Chapter" title="9.2.4 RESULT"/>
<link href="#rfc.section.9.2.5" rel="Chapter" title="9.2.5 Invocation ERROR"/>
<link href="#rfc.section.9.2.6" rel="Chapter" title="9.2.6 Call ERROR"/>
<link href="#rfc.section.10" rel="Chapter" title="10 Predefined URIs"/>
<link href="#rfc.section.10.1" rel="Chapter" title="10.1 Basic Profile"/>
<link href="#rfc.section.10.1.1" rel="Chapter" title="10.1.1 Incorrect URIs"/>
<link href="#rfc.section.10.1.2" rel="Chapter" title="10.1.2 Interaction"/>
<link href="#rfc.section.10.1.3" rel="Chapter" title="10.1.3 Session Close"/>
<link href="#rfc.section.10.1.4" rel="Chapter" title="10.1.4 Authorization"/>
<link href="#rfc.section.10.2" rel="Chapter" title="10.2 Advanced Profile"/>
<link href="#rfc.section.11" rel="Chapter" title="11 Ordering Guarantees"/>
<link href="#rfc.section.11.1" rel="Chapter" title="11.1 Publish &amp; Subscribe Ordering"/>
<link href="#rfc.section.11.2" rel="Chapter" title="11.2 Remote Procedure Call Ordering"/>
<link href="#rfc.section.12" rel="Chapter" title="12 Security Model"/>
<link href="#rfc.section.12.1" rel="Chapter" title="12.1 Transport Encryption and Integrity"/>
<link href="#rfc.section.12.2" rel="Chapter" title="12.2 Router Authentication"/>
<link href="#rfc.section.12.3" rel="Chapter" title="12.3 Client Authentication"/>
<link href="#rfc.section.12.3.1" rel="Chapter" title="12.3.1 Routers are trusted"/>
<link href="#rfc.section.13" rel="Chapter" title="13 Advanced Profile"/>
<link href="#rfc.section.13.1" rel="Chapter" title="13.1 Messages"/>
<link href="#rfc.section.13.1.1" rel="Chapter" title="13.1.1 Message Definitions"/>
<link href="#rfc.section.13.1.2" rel="Chapter" title="13.1.2 Message Codes and Direction"/>
<link href="#rfc.section.13.2" rel="Chapter" title="13.2 Features"/>
<link href="#rfc.section.13.2.1" rel="Chapter" title="13.2.1 RPC Features"/>
<link href="#rfc.section.13.2.2" rel="Chapter" title="13.2.2 PubSub Features"/>
<link href="#rfc.section.13.2.3" rel="Chapter" title="13.2.3 Other Advanced Features"/>
<link href="#rfc.section.13.3" rel="Chapter" title="13.3 Advanced RPC Features"/>
<link href="#rfc.section.13.3.1" rel="Chapter" title="13.3.1 Progressive Call Results"/>
<link href="#rfc.section.13.3.2" rel="Chapter" title="13.3.2 Progressive Calls"/>
<link href="#rfc.section.13.3.3" rel="Chapter" title="13.3.3 Call Timeouts"/>
<link href="#rfc.section.13.3.4" rel="Chapter" title="13.3.4 Call Canceling"/>
<link href="#rfc.section.13.3.5" rel="Chapter" title="13.3.5 Caller Identification"/>
<link href="#rfc.section.13.3.6" rel="Chapter" title="13.3.6 Call Trust Levels"/>
<link href="#rfc.section.13.3.7" rel="Chapter" title="13.3.7 Registration Meta API"/>
<link href="#rfc.section.13.3.8" rel="Chapter" title="13.3.8 Pattern-based Registrations"/>
<link href="#rfc.section.13.3.9" rel="Chapter" title="13.3.9 Shared Registration"/>
<link href="#rfc.section.13.3.10" rel="Chapter" title="13.3.10 Sharded Registration"/>
<link href="#rfc.section.13.3.11" rel="Chapter" title="13.3.11 Registration Revocation"/>
<link href="#rfc.section.13.3.12" rel="Chapter" title="13.3.12 Procedure Reflection"/>
<link href="#rfc.section.13.4" rel="Chapter" title="13.4 Advanced PubSub Features"/>
<link href="#rfc.section.13.4.1" rel="Chapter" title="13.4.1 Subscriber Black- and Whitelisting"/>
<link href="#rfc.section.13.4.2" rel="Chapter" title="13.4.2 Publisher Exclusion"/>
<link href="#rfc.section.13.5" rel="Chapter" title="13.5 Feature Definition"/>
<link href="#rfc.section.13.6" rel="Chapter" title="13.6 Feature Announcement"/>
<link href="#rfc.section.13.6.1" rel="Chapter" title="13.6.1 Publisher Identification"/>
<link href="#rfc.section.13.6.2" rel="Chapter" title="13.6.2 Publication Trust Levels"/>
<link href="#rfc.section.13.6.3" rel="Chapter" title="13.6.3 Subscription Meta API"/>
<link href="#rfc.section.13.6.4" rel="Chapter" title="13.6.4 Pattern-based Subscriptions"/>
<link href="#rfc.section.13.6.5" rel="Chapter" title="13.6.5 Sharded Subscriptions"/>
<link href="#rfc.section.13.6.6" rel="Chapter" title="13.6.6 Event History"/>
<link href="#rfc.section.13.6.7" rel="Chapter" title="13.6.7 Registration Revocation"/>
<link href="#rfc.section.13.6.8" rel="Chapter" title="13.6.8 Topic Reflection"/>
<link href="#rfc.section.13.7" rel="Chapter" title="13.7 Other Advanced Features"/>
<link href="#rfc.section.13.7.1" rel="Chapter" title="13.7.1 Session Meta API"/>
<link href="#rfc.section.13.7.2" rel="Chapter" title="13.7.2 Authentication"/>
<link href="#rfc.section.13.7.3" rel="Chapter" title="13.7.3 Alternative Transports"/>
<link href="#rfc.section.14" rel="Chapter" title="14 Binary conversion of JSON Strings"/>
<link href="#rfc.section.14.1" rel="Chapter" title="14.1 Python"/>
<link href="#rfc.section.14.2" rel="Chapter" title="14.2 JavaScript"/>
<link href="#rfc.section.15" rel="Chapter" title="15 Security Considerations"/>
<link href="#rfc.section.16" rel="Chapter" title="16 IANA Considerations"/>
<link href="#rfc.section.17" rel="Chapter" title="17 Contributors"/>
<link href="#rfc.section.18" rel="Chapter" title="18 Acknowledgements"/>
<link href="#rfc.references" rel="Chapter" title="19 References"/>
<link href="#rfc.references.1" rel="Chapter" title="19.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="19.2 Informative References"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.0 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Oberstein, T. and A. Goedde" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-oberstet-hybi-tavendo-wamp-02" />
  <meta name="dct.issued" scheme="ISO8601" content="2015-10-10" />
  <meta name="dct.abstract" content="This document defines the Web Application Messaging Protocol (WAMP). WAMP is a routed protocol that provides two messaging patterns: Publish &amp; Subscribe and routed Remote Procedure Calls. It is intended to connect application components in distributed applications. WAMP uses WebSocket as its default transport, but can be transmitted via any other protocol that allows for ordered, reliable, bi-directional, and message-oriented communications.  " />
  <meta name="description" content="This document defines the Web Application Messaging Protocol (WAMP). WAMP is a routed protocol that provides two messaging patterns: Publish &amp; Subscribe and routed Remote Procedure Calls. It is intended to connect application components in distributed applications. WAMP uses WebSocket as its default transport, but can be transmitted via any other protocol that allows for ordered, reliable, bi-directional, and message-oriented communications.  " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">BiDirectional or Server-Initiated HTTP</td>
  <td class="right">T. Oberstein</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">A. Goedde</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">Tavendo GmbH</td>
</tr>
<tr>
  <td class="left">Expires: April 12, 2016</td>
  <td class="right">October 10, 2015</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">The Web Application Messaging Protocol<br />
  <span class="filename">draft-oberstet-hybi-tavendo-wamp-02</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document defines the Web Application Messaging Protocol (WAMP). WAMP is a routed protocol that provides two messaging patterns: Publish &amp; Subscribe and routed Remote Procedure Calls. It is intended to connect application components in distributed applications. WAMP uses WebSocket as its default transport, but can be transmitted via any other protocol that allows for ordered, reliable, bi-directional, and message-oriented communications.  </p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on April 12, 2016.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2015 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Background</a></li>
<li>1.2.   <a href="#rfc.section.1.2">Protocol Overview</a></li>
<li>1.3.   <a href="#rfc.section.1.3">Design Philosophy</a></li>
<ul><li>1.3.1.   <a href="#rfc.section.1.3.1">Basic and Advanced Profiles</a></li>
<li>1.3.2.   <a href="#rfc.section.1.3.2">Application Code</a></li>
<li>1.3.3.   <a href="#rfc.section.1.3.3">Language Agnostic</a></li>
<li>1.3.4.   <a href="#rfc.section.1.3.4">Router Implementation Specifics</a></li>
</ul><li>1.4.   <a href="#rfc.section.1.4">Relationship to WebSocket</a></li>
</ul><li>2.   <a href="#rfc.section.2">Conformance Requirements</a></li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Terminology and Other Conventions</a></li>
</ul><li>3.   <a href="#rfc.section.3">Realms, Sessions and Transports</a></li>
<li>4.   <a href="#rfc.section.4">Peers and Roles</a></li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Symmetric Messaging</a></li>
<li>4.2.   <a href="#rfc.section.4.2">Remote Procedure Call Roles</a></li>
<li>4.3.   <a href="#rfc.section.4.3">Publish &amp; Subscribe Roles</a></li>
<li>4.4.   <a href="#rfc.section.4.4">Peers with multiple Roles</a></li>
</ul><li>5.   <a href="#rfc.section.5">Building Blocks</a></li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Identifiers</a></li>
<ul><li>5.1.1.   <a href="#rfc.section.5.1.1">URIs</a></li>
<li>5.1.2.   <a href="#rfc.section.5.1.2">IDs</a></li>
</ul><li>5.2.   <a href="#rfc.section.5.2">Serializations</a></li>
<ul><li>5.2.1.   <a href="#rfc.section.5.2.1">JSON</a></li>
<li>5.2.2.   <a href="#rfc.section.5.2.2">MsgPack</a></li>
</ul><li>5.3.   <a href="#rfc.section.5.3">Transports</a></li>
<ul><li>5.3.1.   <a href="#rfc.section.5.3.1">WebSocket Transport</a></li>
<li>5.3.2.   <a href="#rfc.section.5.3.2">Transport and Session Lifetime</a></li>
</ul></ul><li>6.   <a href="#rfc.section.6">Messages</a></li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Extensibility</a></li>
<li>6.2.   <a href="#rfc.section.6.2">No Polymorphism</a></li>
<li>6.3.   <a href="#rfc.section.6.3">Structure</a></li>
<li>6.4.   <a href="#rfc.section.6.4">Message Definitions</a></li>
<ul><li>6.4.1.   <a href="#rfc.section.6.4.1">Session Lifecycle</a></li>
<li>6.4.2.   <a href="#rfc.section.6.4.2">Publish &amp; Subscribe</a></li>
<li>6.4.3.   <a href="#rfc.section.6.4.3">Routed Remote Procedure Calls</a></li>
</ul><li>6.5.   <a href="#rfc.section.6.5">Message Codes and Direction</a></li>
<li>6.6.   <a href="#rfc.section.6.6">Extension Messages</a></li>
<li>6.7.   <a href="#rfc.section.6.7">Empty Arguments and Keyword Arguments</a></li>
</ul><li>7.   <a href="#rfc.section.7">Sessions</a></li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Session Establishment</a></li>
<ul><li>7.1.1.   <a href="#rfc.section.7.1.1">HELLO</a></li>
<li>7.1.2.   <a href="#rfc.section.7.1.2">WELCOME</a></li>
<li>7.1.3.   <a href="#rfc.section.7.1.3">ABORT</a></li>
</ul><li>7.2.   <a href="#rfc.section.7.2">Session Closing</a></li>
<ul><li>7.2.1.   <a href="#rfc.section.7.2.1">Difference between ABORT and GOODBYE</a></li>
</ul><li>7.3.   <a href="#rfc.section.7.3">Agent Identification</a></li>
</ul><li>8.   <a href="#rfc.section.8">Publish and Subscribe</a></li>
<ul><li>8.1.   <a href="#rfc.section.8.1">Subscribing and Unsubscribing</a></li>
<ul><li>8.1.1.   <a href="#rfc.section.8.1.1">SUBSCRIBE</a></li>
<li>8.1.2.   <a href="#rfc.section.8.1.2">SUBSCRIBED</a></li>
<li>8.1.3.   <a href="#rfc.section.8.1.3">Subscribe ERROR</a></li>
<li>8.1.4.   <a href="#rfc.section.8.1.4">UNSUBSCRIBE</a></li>
<li>8.1.5.   <a href="#rfc.section.8.1.5">UNSUBSCRIBED</a></li>
<li>8.1.6.   <a href="#rfc.section.8.1.6">Unsubscribe ERROR</a></li>
</ul><li>8.2.   <a href="#rfc.section.8.2">Publishing and Events</a></li>
<ul><li>8.2.1.   <a href="#rfc.section.8.2.1">PUBLISH</a></li>
<li>8.2.2.   <a href="#rfc.section.8.2.2">PUBLISHED</a></li>
<li>8.2.3.   <a href="#rfc.section.8.2.3">Publish ERROR</a></li>
<li>8.2.4.   <a href="#rfc.section.8.2.4">EVENT</a></li>
</ul></ul><li>9.   <a href="#rfc.section.9">Remote Procedure Calls</a></li>
<ul><li>9.1.   <a href="#rfc.section.9.1">Registering and Unregistering</a></li>
<ul><li>9.1.1.   <a href="#rfc.section.9.1.1">REGISTER</a></li>
<li>9.1.2.   <a href="#rfc.section.9.1.2">REGISTERED</a></li>
<li>9.1.3.   <a href="#rfc.section.9.1.3">Register ERROR</a></li>
<li>9.1.4.   <a href="#rfc.section.9.1.4">UNREGISTER</a></li>
<li>9.1.5.   <a href="#rfc.section.9.1.5">UNREGISTERED</a></li>
<li>9.1.6.   <a href="#rfc.section.9.1.6">Unregister ERROR</a></li>
</ul><li>9.2.   <a href="#rfc.section.9.2">Calling and Invocations</a></li>
<ul><li>9.2.1.   <a href="#rfc.section.9.2.1">CALL</a></li>
<li>9.2.2.   <a href="#rfc.section.9.2.2">INVOCATION</a></li>
<li>9.2.3.   <a href="#rfc.section.9.2.3">YIELD</a></li>
<li>9.2.4.   <a href="#rfc.section.9.2.4">RESULT</a></li>
<li>9.2.5.   <a href="#rfc.section.9.2.5">Invocation ERROR</a></li>
<li>9.2.6.   <a href="#rfc.section.9.2.6">Call ERROR</a></li>
</ul></ul><li>10.   <a href="#rfc.section.10">Predefined URIs</a></li>
<ul><li>10.1.   <a href="#rfc.section.10.1">Basic Profile</a></li>
<ul><li>10.1.1.   <a href="#rfc.section.10.1.1">Incorrect URIs</a></li>
<li>10.1.2.   <a href="#rfc.section.10.1.2">Interaction</a></li>
<li>10.1.3.   <a href="#rfc.section.10.1.3">Session Close</a></li>
<li>10.1.4.   <a href="#rfc.section.10.1.4">Authorization</a></li>
</ul><li>10.2.   <a href="#rfc.section.10.2">Advanced Profile</a></li>
</ul><li>11.   <a href="#rfc.section.11">Ordering Guarantees</a></li>
<ul><li>11.1.   <a href="#rfc.section.11.1">Publish &amp; Subscribe Ordering</a></li>
<li>11.2.   <a href="#rfc.section.11.2">Remote Procedure Call Ordering</a></li>
</ul><li>12.   <a href="#rfc.section.12">Security Model</a></li>
<ul><li>12.1.   <a href="#rfc.section.12.1">Transport Encryption and Integrity</a></li>
<li>12.2.   <a href="#rfc.section.12.2">Router Authentication</a></li>
<li>12.3.   <a href="#rfc.section.12.3">Client Authentication</a></li>
<ul><li>12.3.1.   <a href="#rfc.section.12.3.1">Routers are trusted</a></li>
</ul></ul><li>13.   <a href="#rfc.section.13">Advanced Profile</a></li>
<ul><li>13.1.   <a href="#rfc.section.13.1">Messages</a></li>
<ul><li>13.1.1.   <a href="#rfc.section.13.1.1">Message Definitions</a></li>
<li>13.1.2.   <a href="#rfc.section.13.1.2">Message Codes and Direction</a></li>
</ul><li>13.2.   <a href="#rfc.section.13.2">Features</a></li>
<ul><li>13.2.1.   <a href="#rfc.section.13.2.1">RPC Features</a></li>
<li>13.2.2.   <a href="#rfc.section.13.2.2">PubSub Features</a></li>
<li>13.2.3.   <a href="#rfc.section.13.2.3">Other Advanced Features</a></li>
</ul><li>13.3.   <a href="#rfc.section.13.3">Advanced RPC Features</a></li>
<ul><li>13.3.1.   <a href="#rfc.section.13.3.1">Progressive Call Results</a></li>
<li>13.3.2.   <a href="#rfc.section.13.3.2">Progressive Calls</a></li>
<li>13.3.3.   <a href="#rfc.section.13.3.3">Call Timeouts</a></li>
<li>13.3.4.   <a href="#rfc.section.13.3.4">Call Canceling</a></li>
<li>13.3.5.   <a href="#rfc.section.13.3.5">Caller Identification</a></li>
<li>13.3.6.   <a href="#rfc.section.13.3.6">Call Trust Levels</a></li>
<li>13.3.7.   <a href="#rfc.section.13.3.7">Registration Meta API</a></li>
<li>13.3.8.   <a href="#rfc.section.13.3.8">Pattern-based Registrations</a></li>
<li>13.3.9.   <a href="#rfc.section.13.3.9">Shared Registration</a></li>
<li>13.3.10.   <a href="#rfc.section.13.3.10">Sharded Registration</a></li>
<li>13.3.11.   <a href="#rfc.section.13.3.11">Registration Revocation</a></li>
<li>13.3.12.   <a href="#rfc.section.13.3.12">Procedure Reflection</a></li>
</ul><li>13.4.   <a href="#rfc.section.13.4">Advanced PubSub Features</a></li>
<ul><li>13.4.1.   <a href="#rfc.section.13.4.1">Subscriber Black- and Whitelisting</a></li>
<li>13.4.2.   <a href="#rfc.section.13.4.2">Publisher Exclusion</a></li>
</ul><li>13.5.   <a href="#rfc.section.13.5">Feature Definition</a></li>
<li>13.6.   <a href="#rfc.section.13.6">Feature Announcement</a></li>
<ul><li>13.6.1.   <a href="#rfc.section.13.6.1">Publisher Identification</a></li>
<li>13.6.2.   <a href="#rfc.section.13.6.2">Publication Trust Levels</a></li>
<li>13.6.3.   <a href="#rfc.section.13.6.3">Subscription Meta API</a></li>
<li>13.6.4.   <a href="#rfc.section.13.6.4">Pattern-based Subscriptions</a></li>
<li>13.6.5.   <a href="#rfc.section.13.6.5">Sharded Subscriptions</a></li>
<li>13.6.6.   <a href="#rfc.section.13.6.6">Event History</a></li>
<li>13.6.7.   <a href="#rfc.section.13.6.7">Registration Revocation</a></li>
<li>13.6.8.   <a href="#rfc.section.13.6.8">Topic Reflection</a></li>
</ul><li>13.7.   <a href="#rfc.section.13.7">Other Advanced Features</a></li>
<ul><li>13.7.1.   <a href="#rfc.section.13.7.1">Session Meta API</a></li>
<li>13.7.2.   <a href="#rfc.section.13.7.2">Authentication</a></li>
<li>13.7.3.   <a href="#rfc.section.13.7.3">Alternative Transports</a></li>
</ul></ul><li>14.   <a href="#rfc.section.14">Binary conversion of JSON Strings</a></li>
<ul><li>14.1.   <a href="#rfc.section.14.1">Python</a></li>
<li>14.2.   <a href="#rfc.section.14.2">JavaScript</a></li>
</ul><li>15.   <a href="#rfc.section.15">Security Considerations</a></li>
<li>16.   <a href="#rfc.section.16">IANA Considerations</a></li>
<li>17.   <a href="#rfc.section.17">Contributors</a></li>
<li>18.   <a href="#rfc.section.18">Acknowledgements</a></li>
<li>19.   <a href="#rfc.references">References</a></li>
<ul><li>19.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>19.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<h1 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#background" id="background">Background</a></h1>
<p><em>This section is non-normative.</em> </p>
<p id="rfc.section.1.1.p.2">The WebSocket protocol brings bi-directional real-time connections to the browser. It defines an API at the message level, requiring users who want to use WebSocket connections in their applications to define their own semantics on top of it.  </p>
<p id="rfc.section.1.1.p.3">The Web Application Messaging Protocol (WAMP) is intended to provide application developers with the semantics they need to handle messaging between components in distributed applications.  </p>
<p id="rfc.section.1.1.p.4">WAMP was initially defined as a WebSocket sub-protocol, which provided Publish &amp; Subscribe (PubSub) functionality as well as Remote Procedure Calls (RPC) for procedures implemented in a WAMP router. Feedback from implementers and users of this was included in a second version of the protocol which this document defines. Among the changes was that WAMP can now run over any transport which is message-oriented, ordered, reliable, and bi-directional.  </p>
<p id="rfc.section.1.1.p.5">WAMP is a routed protocol, with all components connecting to a <em>WAMP Router</em>, where the WAMP Router performs message routing between the components.  </p>
<p id="rfc.section.1.1.p.6">WAMP provides two messaging patterns: <em>Publish &amp; Subscribe</em> and <em>routed Remote Procedure Calls</em>.  </p>
<p id="rfc.section.1.1.p.7">Publish &amp; Subscribe (PubSub) is an established messaging pattern where a component, the <em>Subscriber</em>, informs the router that it wants to receive information on a topic (i.e., it subscribes to a topic). Another component, a <em>Publisher</em>, can then publish to this topic, and the router distributes events to all Subscribers.  </p>
<p id="rfc.section.1.1.p.8">Routed Remote Procedure Calls (RPCs) rely on the same sort of decoupling that is used by the Publish &amp; Subscribe pattern. A component, the <em>Callee</em>, announces to the router that it provides a certain procedure, identified by a procedure name. Other components, <em>Callers</em>, can then call the procedure, with the router invoking the procedure on the Callee, receiving the procedure's result, and then forwarding this result back to the Caller. Routed RPCs differ from traditional client-server RPCs in that the router serves as an intermediary between the Caller and the Callee.  </p>
<p id="rfc.section.1.1.p.9">The decoupling in routed RPCs arises from the fact that the Caller is no longer required to have knowledge of the Callee; it merely needs to know the identifier of the procedure it wants to call. There is also no longer a need for a direct connection between the caller and the callee, since all traffic is routed. This enables the calling of procedures in components which are not reachable externally (e.g. on a NATted connection) but which can establish an outgoing connection to the WAMP router.  </p>
<p id="rfc.section.1.1.p.10">Combining these two patterns into a single protocol allows it to be used for the entire messaging requirements of an application, thus reducing technology stack complexity, as well as networking overheads.  </p>
<h1 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2.</a> <a href="#protocol-overview" id="protocol-overview">Protocol Overview</a></h1>
<p><em>This section is non-normative.</em> </p>
<p id="rfc.section.1.2.p.2">The PubSub messaging pattern defines three roles: <em>Subscribers</em> and <em>Publishers</em>, which communicate via a <em>Broker</em>.  </p>
<p id="rfc.section.1.2.p.3">The routed RPC messaging pattern also defines three roles: <em>Callers</em> and <em>Callees</em>, which communicate via a <em>Dealer</em>.  </p>
<p id="rfc.section.1.2.p.4">WAMP Connections are established by <em>Clients</em> to a <em>Router</em>. Connections can use any transport that is message-based, ordered, reliable and bi-directional, with WebSocket as the default transport.  </p>
<p id="rfc.section.1.2.p.5">A Router is a component which implements one or both of the Broker and Dealer roles. A Client is a component which implements any or all of the Subscriber, Publisher, Caller, or Callee roles.  </p>
<p id="rfc.section.1.2.p.6">WAMP <em>Connections</em> are established by Clients to a Router. Connections can use any transport which is message-oriented, ordered, reliable and bi-directional, with WebSocket as the default transport.  </p>
<p id="rfc.section.1.2.p.7">WAMP <em>Sessions</em> are established over a WAMP Connection. A WAMP Session is joined to a <em>Realm</em> on a Router. Routing occurs only between WAMP Sessions that have joined the same Realm.  </p>
<p id="rfc.section.1.2.p.8">The <em>WAMP Basic Profile</em> defines the parts of the protocol that are required to establish a WAMP connection, as well as for basic interactions between the four client and two router roles. WAMP implementations are required to implement the Basic Profile, at minimum.  </p>
<p id="rfc.section.1.2.p.9">The <em>WAMP Advanced Profile</em> defines additions to the Basic Profile which greatly extend the utility of WAMP in real-world applications. WAMP implementations may support any subset of the Advanced Profile features. They are required to announce those supported features during session establishment.  </p>
<h1 id="rfc.section.1.3"><a href="#rfc.section.1.3">1.3.</a> <a href="#design-philosophy" id="design-philosophy">Design Philosophy</a></h1>
<p><em>This section is non-normative.</em> </p>
<p id="rfc.section.1.3.p.2">WAMP was designed to be performant, safe and easy to implement. Its entire design was driven by a implement, get feedback, adjust cycle.  </p>
<p id="rfc.section.1.3.p.3">An initial version of the protocol was publicly released in March 2012. The intent was to gain insight through implementation and use, and integrate these into a second version of the protocol, where there would be no regard for compatibility between the two versions. Several interoperable, independent implementations were released, and feedback from the implementers and users was collected.  </p>
<p id="rfc.section.1.3.p.4">The second version of the protocol, which this RFC covers, integrates this feedback. Routed Remote Procedure Calls are one outcome of this, where the initial version of the protocol only allowed the calling of procedures provided by the router. Another, related outcome was the strict separation of routing and application logic.  </p>
<p id="rfc.section.1.3.p.5">While WAMP was originally developed to use WebSocket as a transport, with JSON for serialization, experience in the field revealed that other transports and serialization formats were better suited to some use cases. For instance, with the use of WAMP in the Internet of Things sphere, resource constraints play a much larger role than in the browser, so any reduction of resource usage in WAMP implementations counts. This lead to the decoupling of WAMP from any particular transport or serialization, with the establishment of minimum requirements for both.  </p>
<h1 id="rfc.section.1.3.1"><a href="#rfc.section.1.3.1">1.3.1.</a> <a href="#basic-and-advanced-profiles" id="basic-and-advanced-profiles">Basic and Advanced Profiles</a></h1>
<p id="rfc.section.1.3.1.p.1">This document first describes a Basic Profile for WAMP in its entirety, before describing an Advanced Profile which extends the basic functionality of WAMP.  </p>
<p id="rfc.section.1.3.1.p.2">The separation into Basic and Advanced Profiles is intended to extend the reach of the protocol. It allows implementations to start out with a minimal, yet operable and useful set of features, and to expand that set from there. It also allows implementations that are tailored for resource-constrained environments, where larger feature sets would not be possible. Here implementers can weigh between resource constraints and functionality requirements, then implement an optimal feature set for the circumstances.  </p>
<p id="rfc.section.1.3.1.p.3">Advanced Profile features are announced during session establishment, so that different implementations can adjust their interactions to fit the commonly supported feature set.  </p>
<h1 id="rfc.section.1.3.2"><a href="#rfc.section.1.3.2">1.3.2.</a> <a href="#application-code" id="application-code">Application Code</a></h1>
<p id="rfc.section.1.3.2.p.1">WAMP is designed for application code to run within Clients, i.e. <em>Peers</em> having the roles Callee, Caller, Publisher, and Subscriber.  </p>
<p id="rfc.section.1.3.2.p.2">Routers, i.e. Peers of the roles Brokers and Dealers are responsible for <strong>generic call and event routing</strong> and do not run application code.  </p>
<p id="rfc.section.1.3.2.p.3">This allows the transparent exchange of Broker and Dealer implementations without affecting the application and to distribute and deploy application components flexibly.  </p>
<p/>

<ul class="empty">
  <li>Note that a <strong>program</strong> that implements, for instance, the Dealer role might at the same time implement, say, a built-in Callee. It is the Dealer and Broker that are generic, not the program.  </li>
</ul>
<h1 id="rfc.section.1.3.3"><a href="#rfc.section.1.3.3">1.3.3.</a> <a href="#language-agnostic" id="language-agnostic">Language Agnostic</a></h1>
<p id="rfc.section.1.3.3.p.1">WAMP is language agnostic, i.e. can be implemented in any programming language. At the level of arguments that may be part of a WAMP message, WAMP takes a 'superset of all' approach. WAMP implementations may support features of the implementing language for use in arguments, e.g. keyword arguments.  </p>
<h1 id="rfc.section.1.3.4"><a href="#rfc.section.1.3.4">1.3.4.</a> <a href="#router-implementation-specifics" id="router-implementation-specifics">Router Implementation Specifics</a></h1>
<p id="rfc.section.1.3.4.p.1">This specification only deals with the protcol level. Specific WAMP Broker and Dealer implementations may differ in aspects such as support for: </p>
<p/>

<ul>
  <li>router networks (clustering and federation),</li>
  <li>authentication and authorization schemes,</li>
  <li>message persistence, and,</li>
  <li>management and monitoring.</li>
</ul>

<p> </p>
<p id="rfc.section.1.3.4.p.3">The definition and documentation of such Router features is outside the scope of this document.  </p>
<h1 id="rfc.section.1.4"><a href="#rfc.section.1.4">1.4.</a> <a href="#relationship-to-websocket" id="relationship-to-websocket">Relationship to WebSocket</a></h1>
<p id="rfc.section.1.4.p.1">WAMP uses WebSocket as its default transport binding, and is a registered WebSocket subprotocol.  </p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#conformance-requirements" id="conformance-requirements">Conformance Requirements</a></h1>
<p id="rfc.section.2.p.1">All diagrams, examples, and notes in this specification are non-normative, as are all sections explicitly marked non-normative. Everything else in this specification is normative.  </p>
<p id="rfc.section.2.p.2">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 <a href="#RFC2119">[RFC2119]</a>.  </p>
<p id="rfc.section.2.p.3">Requirements phrased in the imperative as part of algorithms (such as "strip any leading space characters" or "return false and abort these steps") are to be interpreted with the meaning of the key word ("MUST", "SHOULD", "MAY", etc.) used in introducing the algorithm.  </p>
<p id="rfc.section.2.p.4">Conformance requirements phrased as algorithms or specific steps MAY  be implemented in any manner, so long as the end result is equivalent.  </p>
<h1 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> <a href="#terminology-and-other-conventions" id="terminology-and-other-conventions">Terminology and Other Conventions</a></h1>
<p id="rfc.section.2.1.p.1">Key terms such as named algorithms or definitions are indicated like <em>this</em> when they first occur, and are capitalized throughout the text.  </p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#realms-sessions-and-transports" id="realms-sessions-and-transports">Realms, Sessions and Transports</a></h1>
<p id="rfc.section.3.p.1">A Realm is a WAMP routing and administrative domain, optionally protected by authentication and authorization. WAMP messages are only routed within a Realm.  </p>
<p id="rfc.section.3.p.2">A Session is a transient conversation between two Peers attached to a Realm and running over a Transport.  </p>
<p id="rfc.section.3.p.3">A Transport connects two WAMP Peers and provides a channel over which WAMP messages for a WAMP Session can flow in both directions.  </p>
<p id="rfc.section.3.p.4">WAMP can run over any Transport which is message-based, bidirectional,  reliable and ordered.  </p>
<p id="rfc.section.3.p.5">The default transport for WAMP is WebSocket <a href="#RFC6455">[RFC6455]</a>, where WAMP is an <a href="http://www.iana.org/assignments/websocket/websocket.xml">officially registered</a> subprotocol.  </p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#peers-and-roles" id="peers-and-roles">Peers and Roles</a></h1>
<p id="rfc.section.4.p.1">A WAMP Session connects two Peers, a Client and a Router. Each WAMP Peer MUST implement one role, and MAY implement more roles.  </p>
<p id="rfc.section.4.p.2">A Client MAY implement any combination of the Roles: </p>
<p/>

<ul>
  <li>Callee</li>
  <li>Caller</li>
  <li>Publisher</li>
  <li>Subscriber</li>
</ul>

<p> </p>
<p id="rfc.section.4.p.4">and a Router MAY implement either or both of the Roles: </p>
<p/>

<ul>
  <li>Dealer</li>
  <li>Broker</li>
</ul>

<p> </p>
<p/>

<ul class="empty">
  <li>This document describes WAMP as in client-to-router communication. Direct client-to-client communication is not supported by WAMP. Router-to-router communication MAY be defined by a specific router implementation.  </li>
</ul>
<h1 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> <a href="#symmetric-messaging" id="symmetric-messaging">Symmetric Messaging</a></h1>
<p id="rfc.section.4.1.p.1">It is important to note that though the establishment of a Transport might have a inherent asymmetry (like a TCP client establishing a WebSocket connection to a server), and Clients establish WAMP sessions by attaching to Realms on Routers, WAMP itself is designed to be fully symmetric for application components.  </p>
<p id="rfc.section.4.1.p.2">After the transport and a session have been established, any application component may act as Caller, Callee, Publisher and Subscriber at the same time. And Routers provide the fabric on top of which WAMP runs a symmetric application messaging service.  </p>
<h1 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> <a href="#remote-procedure-call-roles" id="remote-procedure-call-roles">Remote Procedure Call Roles</a></h1>
<p id="rfc.section.4.2.p.1">The Remote Procedure Call messaging pattern involves peers of three different roles: </p>
<p/>

<ul>
  <li>Callee (Client)</li>
  <li>Caller (Client)</li>
  <li>Dealer (Router)</li>
</ul>

<p> </p>
<p id="rfc.section.4.2.p.3">A Caller issues calls to remote procedures by providing the procedure URI and any arguments for the call.  The Callee will execute the procedure using the supplied arguments to the call and return the result of the call to the Caller.  </p>
<p id="rfc.section.4.2.p.4">Callees register procedures they provide with Dealers. Callers initiate procedure calls first to Dealers. Dealers route calls incoming from Callers to Callees implementing the procedure called, and route call results back from Callees to Callers.  </p>
<p id="rfc.section.4.2.p.5">The Caller and Callee will usually run application code, while the Dealer works as a generic router for remote procedure calls decoupling Callers and Callees.  </p>
<h1 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3.</a> <a href="#publish--subscribe-roles" id="publish--subscribe-roles">Publish &amp; Subscribe Roles</a></h1>
<p id="rfc.section.4.3.p.1">The Publish &amp; Subscribe messaging pattern involves peers of three different roles: </p>
<p/>

<ul>
  <li>Subscriber (Client)</li>
  <li>Publisher (Client)</li>
  <li>Broker (Router)</li>
</ul>

<p> </p>
<p id="rfc.section.4.3.p.3">A Publishers publishes events to topics by providing the topic URI and any payload for the event. Subscribers of the topic will receive the event together with the event payload.  </p>
<p id="rfc.section.4.3.p.4">Subscribers subscribe to topics they are interested in with Brokers. Publishers initiate publication first at Brokers. Brokers route events incoming from Publishers to Subscribers that are subscribed to respective topics.  </p>
<p id="rfc.section.4.3.p.5">The Publisher and Subscriber will usually run application code, while the Broker works as a generic router for events decoupling Publishers from Subscribers.  </p>
<h1 id="rfc.section.4.4"><a href="#rfc.section.4.4">4.4.</a> <a href="#peers-with-multiple-roles" id="peers-with-multiple-roles">Peers with multiple Roles</a></h1>
<p id="rfc.section.4.4.p.1">Note that Peers might implement more than one role: e.g. a Peer might act as Caller, Publisher and Subscriber at the same time. Another Peer might act as both a Broker and a Dealer.  </p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#building-blocks" id="building-blocks">Building Blocks</a></h1>
<p id="rfc.section.5.p.1">WAMP is defined with respect to the following building blocks </p>
<p/>

<ol>
  <li>Identifiers</li>
  <li>Serializations</li>
  <li>Transports</li>
</ol>

<p> </p>
<p id="rfc.section.5.p.3">For each building block, WAMP only assumes a defined set of requirements, which allows to run WAMP variants with different concrete bindings.  </p>
<h1 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a> <a href="#identifiers" id="identifiers">Identifiers</a></h1>
<h1 id="rfc.section.5.1.1"><a href="#rfc.section.5.1.1">5.1.1.</a> <a href="#uris" id="uris">URIs</a></h1>
<p id="rfc.section.5.1.1.p.1">WAMP needs to identify the following <strong>persistent</strong> resources: </p>
<p/>

<ol>
  <li>Topics</li>
  <li>Procedures</li>
  <li>Errors</li>
</ol>

<p> </p>
<p id="rfc.section.5.1.1.p.3">These are identified in WAMP using <em>Uniform Resource Identifiers</em> (URIs) <a href="#RFC3986">[RFC3986]</a> that MUST be Unicode strings.  </p>
<p/>

<ul class="empty">
  <li>When using JSON as WAMP serialization format, URIs (as other strings) are transmitted in UTF-8 <a href="#RFC3629">[RFC3629]</a> encoding.  </li>
</ul>
<p><em>Examples</em> </p>
<p/>

<ul>
  <li>
    <samp>com.myapp.mytopic1</samp>
  </li>
  <li>
    <samp>com.myapp.myprocedure1</samp>
  </li>
  <li>
    <samp>com.myapp.myerror1</samp>
  </li>
</ul>

<p> </p>
<p id="rfc.section.5.1.1.p.7">The URIs are understood to form a single, global, hierarchical namespace for WAMP.  </p>
<p/>

<ul class="empty">
  <li>The namespace is unified for topics, procedures and errors - these different resource types do NOT have separate namespaces.  </li>
</ul>
<p id="rfc.section.5.1.1.p.9">To avoid resource naming conflicts, the package naming convention from Java is used, where URIs SHOULD begin with (reversed) domain names owned by the organization defining the URI.  </p>
<h1 id="rfc.section.5.1.1.1"><a href="#rfc.section.5.1.1.1">5.1.1.1.</a> <a href="#relaxedloose-uris" id="relaxedloose-uris">Relaxed/Loose URIs</a></h1>
<p id="rfc.section.5.1.1.1.p.1">URI components (the parts between two <samp>.</samp>s, the head part up to the first <samp>.</samp>, the tail part after the last <samp>.</samp>) MUST NOT contain a <samp>.</samp>, <samp>#</samp> or whitespace characters and MUST NOT be empty (zero-length strings).  </p>
<p/>

<ul class="empty">
  <li>The restriction not to allow <samp>.</samp> in component strings is due to the fact that <samp>.</samp> is used to separate components, and WAMP associates semantics with resource hierarchies, such as in pattern-based subscriptions that are part of the Advanced Profile. The restriction not to allow empty (zero-length) strings as components is due to the fact that this may be used to denote wildcard components with pattern-based subscriptions and registrations in the Advanced Profile. The character <samp>#</samp> is not allowed since this is reserved for internal use by Dealers and Brokers.  </li>
</ul>
<p id="rfc.section.5.1.1.1.p.3">As an example, the following regular expression could be used in Python to check URIs according to above rules: </p>
<pre>
    &lt;CODE BEGINS&gt;
        ## loose URI check disallowing empty URI components
        pattern = re.compile(r"^([^\s\.#]+\.)*([^\s\.#]+)$")
    &lt;CODE ENDS&gt;
</pre>
<p id="rfc.section.5.1.1.1.p.4">When empty URI components are allowed (which is the case for specific messages that are part of the Advanced Profile), this following regular expression can be used (shown used in Python): </p>
<pre>
    &lt;CODE BEGINS&gt;
        ## loose URI check allowing empty URI components
        pattern = re.compile(r"^(([^\s\.#]+\.)|\.)*([^\s\.#]+)?$")
    &lt;CODE ENDS&gt;
</pre>
<h1 id="rfc.section.5.1.1.2"><a href="#rfc.section.5.1.1.2">5.1.1.2.</a> <a href="#strict-uris" id="strict-uris">Strict URIs</a></h1>
<p id="rfc.section.5.1.1.2.p.1">While the above rules MUST be followed, following a stricter URI rule is recommended: URI components SHOULD only contain letters, digits and <samp>_</samp>.  </p>
<p id="rfc.section.5.1.1.2.p.2">As an example, the following regular expression could be used in Python to check URIs according to the above rules: </p>
<pre>
    &lt;CODE BEGINS&gt;
        ## strict URI check disallowing empty URI components
        pattern = re.compile(r"^([0-9a-z_]+\.)*([0-9a-z_]+)$")
    &lt;CODE ENDS&gt;
</pre>
<p id="rfc.section.5.1.1.2.p.3">When empty URI components are allowed (which is the case for specific messages that are part of the Advanced Profile), the following regular expression can be used (shown in Python): </p>
<pre>
    &lt;CODE BEGINS&gt;
        ## strict URI check allowing empty URI components
        pattern = re.compile(r"^(([0-9a-z_]+\.)|\.)*([0-9a-z_]+)?$")
    &lt;CODE ENDS&gt;
</pre>
<p/>

<ul class="empty">
  <li>Following the suggested regular expression will make URI components valid identifiers in most languages (modulo URIs starting with a digit and language keywords) and the use of lower-case only will make those identifiers unique in languages that have case-insensitive identifiers. Following this suggestion can allow implementations to map topics, procedures and errors to the language environment in a completely transparent way.  </li>
</ul>
<h1 id="rfc.section.5.1.1.3"><a href="#rfc.section.5.1.1.3">5.1.1.3.</a> <a href="#reserved-uris" id="reserved-uris">Reserved URIs</a></h1>
<p id="rfc.section.5.1.1.3.p.1">Further, application URIs MUST NOT use <samp>wamp</samp> as a first URI component, since this is reserved for URIs predefined with the WAMP protocol itself.  </p>
<p><em>Examples</em> </p>
<p/>

<ul>
  <li>
    <samp>wamp.error.not_authorized</samp>
  </li>
  <li>
    <samp>wamp.error.procedure_already_exists</samp>
  </li>
</ul>

<p> </p>
<h1 id="rfc.section.5.1.2"><a href="#rfc.section.5.1.2">5.1.2.</a> <a href="#ids" id="ids">IDs</a></h1>
<p id="rfc.section.5.1.2.p.1">WAMP needs to identify the following ephemeral entities each in the scope noted: </p>
<p/>

<ol>
  <li>Sessions (<em>global scope</em>)</li>
  <li>Publications (<em>global scope</em>)</li>
  <li>Subscriptions (<em>router scope</em>)</li>
  <li>Registrations (<em>router scope</em>)</li>
  <li>Requests (<em>session scope</em>)</li>
</ol>

<p> </p>
<p id="rfc.section.5.1.2.p.3">These are identified in WAMP using IDs that are integers between (inclusive) <strong>0</strong> and <strong>2^53</strong> (9007199254740992): </p>
<p/>

<ul>
  <li>IDs in the <em>global scope</em> MUST be drawn <em>randomly</em> from a <em>uniform distribution</em> over the complete range [0, 2^53]</li>
  <li>IDs in the <em>router scope</em> can be chosen freely by the specific router implementation</li>
  <li>IDs in the <em>session scope</em> SHOULD be incremented by 1 beginning with 1 (for each direction - <em>Client-to-Router</em> and <em>Router-to-Client</em>)</li>
</ul>

<p> </p>
<p/>

<ul class="empty">
  <li>The reason to choose the specific upper bound is that 2^53 is the largest integer such that this integer and <em>all</em> (positive) smaller integers can be represented exactly in IEEE-754 doubles. Some languages (e.g. JavaScript) use doubles as their sole number type. Most languages do have signed and unsigned 64-bit integer types that both can hold any value from the specified range.  </li>
</ul>
<p id="rfc.section.5.1.2.p.6">The following is a complete list of usage of IDs in the three categories for all WAMP messages. For a full definition of these see <a href="#messages">Section 6</a>.  </p>
<h1 id="rfc.section.5.1.2.1"><a href="#rfc.section.5.1.2.1">5.1.2.1.</a> <a href="#global-scope-ids" id="global-scope-ids">Global Scope IDs</a></h1>
<p/>

<ul>
  <li>
    <samp>WELCOME.Session</samp>
  </li>
  <li>
    <samp>PUBLISHED.Publication</samp>
  </li>
  <li>
    <samp>EVENT.Publication</samp>
  </li>
</ul>

<p> </p>
<h1 id="rfc.section.5.1.2.2"><a href="#rfc.section.5.1.2.2">5.1.2.2.</a> <a href="#router-scope-ids" id="router-scope-ids">Router Scope IDs</a></h1>
<p/>

<ul>
  <li>
    <samp>EVENT.Subscription</samp>
  </li>
  <li>
    <samp>SUBSCRIBED.Subscription</samp>
  </li>
  <li>
    <samp>REGISTERED.Registration</samp>
  </li>
  <li>
    <samp>UNSUBSCRIBE.Subscription</samp>
  </li>
  <li>
    <samp>UNREGISTER.Registration</samp>
  </li>
  <li>
    <samp>INVOCATION.Registration</samp>
  </li>
</ul>

<p> </p>
<h1 id="rfc.section.5.1.2.3"><a href="#rfc.section.5.1.2.3">5.1.2.3.</a> <a href="#session-scope-ids" id="session-scope-ids">Session Scope IDs</a></h1>
<p/>

<ul>
  <li>
    <samp>ERROR.Request</samp>
  </li>
  <li>
    <samp>PUBLISH.Request</samp>
  </li>
  <li>
    <samp>PUBLISHED.Request</samp>
  </li>
  <li>
    <samp>SUBSCRIBE.Request</samp>
  </li>
  <li>
    <samp>SUBSCRIBED.Request</samp>
  </li>
  <li>
    <samp>UNSUBSCRIBE.Request</samp>
  </li>
  <li>
    <samp>UNSUBSCRIBED.Request</samp>
  </li>
  <li>
    <samp>CALL.Request</samp>
  </li>
  <li>
    <samp>CANCEL.Request</samp>
  </li>
  <li>
    <samp>RESULT.Request</samp>
  </li>
  <li>
    <samp>REGISTER.Request</samp>
  </li>
  <li>
    <samp>REGISTERED.Request</samp>
  </li>
  <li>
    <samp>UNREGISTER.Request</samp>
  </li>
  <li>
    <samp>UNREGISTERED.Request</samp>
  </li>
  <li>
    <samp>INVOCATION.Request</samp>
  </li>
  <li>
    <samp>INTERRUPT.Request</samp>
  </li>
  <li>
    <samp>YIELD.Request</samp>
  </li>
</ul>

<p> </p>
<h1 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a> <a href="#serializations" id="serializations">Serializations</a></h1>
<p id="rfc.section.5.2.p.1">WAMP is a message based protocol that requires serialization of messages to octet sequences to be sent out on the wire.  </p>
<p id="rfc.section.5.2.p.2">A message <em>serialization</em> format is assumed that (at least) provides the following types: </p>
<p/>

<ul>
  <li><samp>integer</samp> (non-negative)</li>
  <li><samp>string</samp> (UTF-8 encoded Unicode)</li>
  <li>
    <samp>bool</samp>
  </li>
  <li>
    <samp>list</samp>
  </li>
  <li><samp>dict</samp> (with string keys)</li>
</ul>

<p> </p>
<p/>

<ul class="empty">
  <li>WAMP <em>itself</em> only uses the above types, e.g. it does not use the JSON data types <samp>number</samp> (non-integer) and <samp>null</samp>. The <em>application payloads</em> transmitted by WAMP (e.g. in call arguments or event payloads) may use other types a concrete serialization format supports.  </li>
</ul>
<p id="rfc.section.5.2.p.5">There is no required serialization or set of serializations for WAMP implementations (but each implementation MUST, of course, implement at least one serialization format). Routers SHOULD implement more than one serialization format, enabling components using different kinds of serializations to connect to each other.  </p>
<p id="rfc.section.5.2.p.6">WAMP defines two bindings for message <em>serialization</em>: </p>
<p/>

<ol>
  <li>JSON</li>
  <li>MsgPack</li>
</ol>

<p> </p>
<p id="rfc.section.5.2.p.8">Other bindings for <em>serialization</em> may be defined in future WAMP versions.  </p>
<h1 id="rfc.section.5.2.1"><a href="#rfc.section.5.2.1">5.2.1.</a> <a href="#json" id="json">JSON</a></h1>
<p id="rfc.section.5.2.1.p.1">With JSON serialization, each WAMP message is serialized according to the JSON specification as described in RFC4627.  </p>
<p id="rfc.section.5.2.1.p.2">Further, binary data follows a convention for conversion to JSON strings. For details see the Appendix.  </p>
<h1 id="rfc.section.5.2.2"><a href="#rfc.section.5.2.2">5.2.2.</a> <a href="#msgpack" id="msgpack">MsgPack</a></h1>
<p id="rfc.section.5.2.2.p.1">With MsgPack serialization, each WAMP message is serialized according to the MsgPack specification.  </p>
<p/>

<ul class="empty">
  <li>Version 5 or later of MsgPack MUST BE used, since this version is able to differentiate between strings and binary values.  </li>
</ul>
<h1 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3.</a> <a href="#transports" id="transports">Transports</a></h1>
<p id="rfc.section.5.3.p.1">WAMP assumes a <em>transport</em> with the following characteristics: </p>
<p/>

<ol>
  <li>message-based</li>
  <li>reliable</li>
  <li>ordered</li>
  <li>bidirectional (full-duplex)</li>
</ol>

<p> </p>
<p id="rfc.section.5.3.p.3">There is no required transport or set of transports for WAMP implementations (but each implementation MUST, of course, implement at least one transport). Routers SHOULD implement more than one transport, enabling components using different kinds of transports to connect in an application.  </p>
<h1 id="rfc.section.5.3.1"><a href="#rfc.section.5.3.1">5.3.1.</a> <a href="#websocket-transport" id="websocket-transport">WebSocket Transport</a></h1>
<p id="rfc.section.5.3.1.p.1">The default transport binding for WAMP is WebSocket.  </p>
<p id="rfc.section.5.3.1.p.2">In the Basic Profile, WAMP messages are transmitted as WebSocket messages: each WAMP message is transmitted as a separate WebSocket message (not WebSocket frame). The Advanced Profile may define other modes, e.g. a <strong>batched mode</strong> where multiple WAMP messages are transmitted via single WebSocket message.  </p>
<p id="rfc.section.5.3.1.p.3">The WAMP protocol MUST BE negotiated during the WebSocket opening handshake between Peers using the WebSocket subprotocol negotiation mechanism.  </p>
<p id="rfc.section.5.3.1.p.4">WAMP uses the following WebSocket subprotocol identifiers for unbatched modes: </p>
<p/>

<ul>
  <li>
    <samp>wamp.2.json</samp>
  </li>
  <li>
    <samp>wamp.2.msgpack</samp>
  </li>
</ul>

<p> </p>
<p id="rfc.section.5.3.1.p.6">With <samp>wamp.2.json</samp>, <em>all</em> WebSocket messages MUST BE of type <strong>text</strong> (UTF8 encoded payload) and use the JSON message serialization.  </p>
<p id="rfc.section.5.3.1.p.7">With <samp>wamp.2.msgpack</samp>, <em>all</em> WebSocket messages MUST BE of type <strong>binary</strong> and use the MsgPack message serialization.  </p>
<p/>

<ul class="empty">
  <li>To avoid incompatibilities merely due to naming conflicts with WebSocket subprotocol identifiers, implementers SHOULD register identifiers for additional serialization formats with the official WebSocket subprotocol registry.  </li>
</ul>
<h1 id="rfc.section.5.3.2"><a href="#rfc.section.5.3.2">5.3.2.</a> <a href="#transport-and-session-lifetime" id="transport-and-session-lifetime">Transport and Session Lifetime</a></h1>
<p id="rfc.section.5.3.2.p.1">WAMP implementations MAY choose to tie the lifetime of the underlying transport connection for a WAMP connection to that of a WAMP session, i.e. establish a new transport-layer connection as part of each new session establishment. They MAY equally choose to allow re-use of a transport connection, allowing subsequent WAMP sessions to be established using the same transport connection.  </p>
<p id="rfc.section.5.3.2.p.2">The diagram below illustrates the full transport connection and session lifecycle for an implementation which uses WebSocket over TCP as the transport and allows the re-use of a transport connection.  </p>
<pre>
    ,------.                                    ,------.
    | Peer |                                    | Peer |
    `--+---'                                    `--+---'

                      TCP established
       |&lt;-----------------------------------------&gt;|
       |                                           |
       |               TLS established             |
       |+&lt;---------------------------------------&gt;+|
       |+                                         +|
       |+           WebSocket established         +|
       |+|&lt;-------------------------------------&gt;|+|
       |+|                                       |+|
       |+|            WAMP established           |+|
       |+|+&lt;-----------------------------------&gt;+|+|
       |+|+                                     +|+|
       |+|+                                     +|+|
       |+|+            WAMP closed              +|+|
       |+|+&lt;-----------------------------------&gt;+|+|
       |+|                                       |+|
       |+|                                       |+|
       |+|            WAMP established           |+|
       |+|+&lt;-----------------------------------&gt;+|+|
       |+|+                                     +|+|
       |+|+                                     +|+|
       |+|+            WAMP closed              +|+|
       |+|+&lt;-----------------------------------&gt;+|+|
       |+|                                       |+|
       |+|           WebSocket closed            |+|
       |+|&lt;-------------------------------------&gt;|+|
       |+                                         +|
       |+              TLS closed                 +|
       |+&lt;---------------------------------------&gt;+|
       |                                           |
       |               TCP closed                  |
       |&lt;-----------------------------------------&gt;|

    ,--+---.                                    ,--+---.
    | Peer |                                    | Peer |
    `------'                                    `------'
</pre>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#messages" id="messages">Messages</a></h1>
<p id="rfc.section.6.p.1">All WAMP messages are a <samp>list</samp> with a first element <samp>MessageType</samp> followed by one or more message type specific elements: </p>
<pre>
    [MessageType|integer, ... one or more message type specific
        elements ...]
</pre>
<p id="rfc.section.6.p.2">The notation <samp>Element|type</samp> denotes a message element named <samp>Element</samp> of type <samp>type</samp>, where <samp>type</samp> is one of </p>
<p/>

<ul>
  <li><samp>uri</samp>: a string URI as defined in <a href="#uris">Section 5.1.1</a></li>
  <li><samp>id</samp>: an integer ID as defined in <a href="#ids">Section 5.1.2</a></li>
  <li><samp>integer</samp>: a non-negative integer</li>
  <li><samp>string</samp>: a Unicode string, including the empty string</li>
  <li><samp>bool</samp>: a boolean value (<samp>true</samp> or <samp>false</samp>) - integers MUST NOT be used instead of boolean value</li>
  <li><samp>dict</samp>: a dictionary (map) where keys MUST be strings, keys MUST be unique and serialization order is undefined (left to the serializer being used)</li>
  <li><samp>list</samp>: a list (array) where items can be again any of this enumeration</li>
</ul>

<p> </p>
<p><em>Example</em> </p>
<p id="rfc.section.6.p.5">A <samp>SUBSCRIBE</samp> message has the following format </p>
<pre>
    [SUBSCRIBE, Request|id, Options|dict, Topic|uri]
</pre>
<p id="rfc.section.6.p.6">Here is an example message conforming to the above format </p>
<pre>
    [32, 713845233, {}, "com.myapp.mytopic1"]
</pre>
<h1 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a> <a href="#extensibility" id="extensibility">Extensibility</a></h1>
<p id="rfc.section.6.1.p.1">Some WAMP messages contain <samp>Options|dict</samp> or <samp>Details|dict</samp> elements. This allows for future extensibility and implementations that only provide subsets of functionality by ignoring unimplemented attributes. Keys in <samp>Options</samp> and <samp>Details</samp> MUST be of type <samp>string</samp> and MUST match the regular expression <samp>[a-z][a-z0-9_]{2,}</samp> for WAMP <em>predefined</em> keys. Implementations MAY use implementation-specific keys that MUST match the regular expression <samp>_[a-z0-9_]{3,}</samp>. Attributes unknown to an implementation MUST be ignored.  </p>
<h1 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a> <a href="#no-polymorphism" id="no-polymorphism">No Polymorphism</a></h1>
<p id="rfc.section.6.2.p.1">For a given <samp>MessageType</samp> <em>and</em> number of message elements the expected types are uniquely defined. Hence there are no polymorphic messages in WAMP. This leads to a message parsing and validation control flow that is efficient, simple to implement and simple to code for rigorous message format checking.  </p>
<h1 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3.</a> <a href="#structure" id="structure">Structure</a></h1>
<p id="rfc.section.6.3.p.1">The <em>application</em> payload (that is call arguments, call results, event payload etc) is always at the end of the message element list. The rationale is: Brokers and Dealers have no need to inspect (parse) the application payload. Their business is call/event routing. Having the application payload at the end of the list allows Brokers and Dealers to skip parsing it altogether. This can improve efficiency and performance.  </p>
<h1 id="rfc.section.6.4"><a href="#rfc.section.6.4">6.4.</a> <a href="#message-definitions" id="message-definitions">Message Definitions</a></h1>
<p id="rfc.section.6.4.p.1">WAMP defines the following messages that are explained in detail in the following sections.  </p>
<p id="rfc.section.6.4.p.2">The messages concerning the WAMP session itself are mandatory for all Peers, i.e. a Client MUST implement <samp>HELLO</samp>, <samp>ABORT</samp> and <samp>GOODBYE</samp>, while a Router MUST implement <samp>WELCOME</samp>, <samp>ABORT</samp> and <samp>GOODBYE</samp>.  </p>
<p id="rfc.section.6.4.p.3">All other messages are mandatory <em>per role</em>, i.e. in an implementation that only provides a Client with the role of Publisher MUST additionally implement sending <samp>PUBLISH</samp> and receiving <samp>PUBLISHED</samp> and <samp>ERROR</samp> messages.  </p>
<h1 id="rfc.section.6.4.1"><a href="#rfc.section.6.4.1">6.4.1.</a> <a href="#session-lifecycle" id="session-lifecycle">Session Lifecycle</a></h1>
<h1 id="rfc.section.6.4.1.1"><a href="#rfc.section.6.4.1.1">6.4.1.1.</a> <a href="#hello" id="hello">HELLO</a></h1>
<p id="rfc.section.6.4.1.1.p.1">Sent by a Client to initiate opening of a WAMP session to a Router attaching to a Realm.  </p>
<pre>
    [HELLO, Realm|uri, Details|dict]
</pre>
<h1 id="rfc.section.6.4.1.2"><a href="#rfc.section.6.4.1.2">6.4.1.2.</a> <a href="#welcome" id="welcome">WELCOME</a></h1>
<p id="rfc.section.6.4.1.2.p.1">Sent by a Router to accept a Client. The WAMP session is now open.  </p>
<pre>
    [WELCOME, Session|id, Details|dict]
</pre>
<h1 id="rfc.section.6.4.1.3"><a href="#rfc.section.6.4.1.3">6.4.1.3.</a> <a href="#abort" id="abort">ABORT</a></h1>
<p id="rfc.section.6.4.1.3.p.1">Sent by a Peer*to abort the opening of a WAMP session. No response is expected.  </p>
<pre>
  [ABORT, Details|dict, Reason|uri]
</pre>
<h1 id="rfc.section.6.4.1.4"><a href="#rfc.section.6.4.1.4">6.4.1.4.</a> <a href="#goodbye" id="goodbye">GOODBYE</a></h1>
<p id="rfc.section.6.4.1.4.p.1">Sent by a Peer to close a previously opened WAMP session. Must be echo'ed by the receiving Peer.  </p>
<pre>
    [GOODBYE, Details|dict, Reason|uri]
</pre>
<h1 id="rfc.section.6.4.1.5"><a href="#rfc.section.6.4.1.5">6.4.1.5.</a> <a href="#error" id="error">ERROR</a></h1>
<p id="rfc.section.6.4.1.5.p.1">Error reply sent by a Peer as an error response to different kinds of requests.  </p>
<pre>
    [ERROR, REQUEST.Type|int, REQUEST.Request|id, Details|dict,
        Error|uri]

    [ERROR, REQUEST.Type|int, REQUEST.Request|id, Details|dict,
        Error|uri, Arguments|list]

    [ERROR, REQUEST.Type|int, REQUEST.Request|id, Details|dict,
        Error|uri, Arguments|list, ArgumentsKw|dict]
</pre>
<h1 id="rfc.section.6.4.2"><a href="#rfc.section.6.4.2">6.4.2.</a> <a href="#publish--subscribe" id="publish--subscribe">Publish &amp; Subscribe</a></h1>
<h1 id="rfc.section.6.4.2.1"><a href="#rfc.section.6.4.2.1">6.4.2.1.</a> <a href="#publish" id="publish">PUBLISH</a></h1>
<p id="rfc.section.6.4.2.1.p.1">Sent by a Publisher to a Broker to publish an event.  </p>
<pre>
    [PUBLISH, Request|id, Options|dict, Topic|uri]

    [PUBLISH, Request|id, Options|dict, Topic|uri,
        Arguments|list]

    [PUBLISH, Request|id, Options|dict, Topic|uri,
        Arguments|list, ArgumentsKw|dict]
</pre>
<h1 id="rfc.section.6.4.2.2"><a href="#rfc.section.6.4.2.2">6.4.2.2.</a> <a href="#published" id="published">PUBLISHED</a></h1>
<p id="rfc.section.6.4.2.2.p.1">Acknowledge sent by a Broker to a Publisher for acknowledged publications.  </p>
<pre>
    [PUBLISHED, PUBLISH.Request|id, Publication|id]
</pre>
<h1 id="rfc.section.6.4.2.3"><a href="#rfc.section.6.4.2.3">6.4.2.3.</a> <a href="#subscribe" id="subscribe">SUBSCRIBE</a></h1>
<p id="rfc.section.6.4.2.3.p.1">Subscribe request sent by a Subscriber to a Broker to subscribe to a topic.  </p>
<pre>
    [SUBSCRIBE, Request|id, Options|dict, Topic|uri]
</pre>
<h1 id="rfc.section.6.4.2.4"><a href="#rfc.section.6.4.2.4">6.4.2.4.</a> <a href="#subscribed" id="subscribed">SUBSCRIBED</a></h1>
<p id="rfc.section.6.4.2.4.p.1">Acknowledge sent by a Broker to a Subscriber to acknowledge a subscription.  </p>
<pre>
    [SUBSCRIBED, SUBSCRIBE.Request|id, Subscription|id]
</pre>
<h1 id="rfc.section.6.4.2.5"><a href="#rfc.section.6.4.2.5">6.4.2.5.</a> <a href="#unsubscribe" id="unsubscribe">UNSUBSCRIBE</a></h1>
<p id="rfc.section.6.4.2.5.p.1">Unsubscribe request sent by a Subscriber to a Broker to unsubscribe a subscription.  </p>
<pre>
    [UNSUBSCRIBE, Request|id, SUBSCRIBED.Subscription|id]
</pre>
<h1 id="rfc.section.6.4.2.6"><a href="#rfc.section.6.4.2.6">6.4.2.6.</a> <a href="#unsubscribed" id="unsubscribed">UNSUBSCRIBED</a></h1>
<p id="rfc.section.6.4.2.6.p.1">Acknowledge sent by a Broker to a Subscriber to acknowledge unsubscription.  </p>
<pre>
    [UNSUBSCRIBED, UNSUBSCRIBE.Request|id]
</pre>
<h1 id="rfc.section.6.4.2.7"><a href="#rfc.section.6.4.2.7">6.4.2.7.</a> <a href="#event" id="event">EVENT</a></h1>
<p id="rfc.section.6.4.2.7.p.1">Event dispatched by Broker to Subscribers for subscriptions the event was matching.  </p>
<pre>
    [EVENT, SUBSCRIBED.Subscription|id, PUBLISHED.Publication|id,
        Details|dict]

    [EVENT, SUBSCRIBED.Subscription|id, PUBLISHED.Publication|id,
        Details|dict, PUBLISH.Arguments|list]

    [EVENT, SUBSCRIBED.Subscription|id, PUBLISHED.Publication|id,
        Details|dict, PUBLISH.Arguments|list,
        PUBLISH.ArgumentsKw|dict]
</pre>
<p/>

<ul class="empty">
  <li>An event is dispatched to a Subscriber for a given <samp>Subscription|id</samp> <em>only once</em>. On the other hand, a Subscriber that holds subscriptions with different <samp>Subscription|id</samp>s that all match a given event will receive the event on each matching subscription.  </li>
</ul>
<h1 id="rfc.section.6.4.3"><a href="#rfc.section.6.4.3">6.4.3.</a> <a href="#routed-remote-procedure-calls" id="routed-remote-procedure-calls">Routed Remote Procedure Calls</a></h1>
<h1 id="rfc.section.6.4.3.1"><a href="#rfc.section.6.4.3.1">6.4.3.1.</a> <a href="#call" id="call">CALL</a></h1>
<p id="rfc.section.6.4.3.1.p.1">Call as originally issued by the <em>Caller</em> to the <em>Dealer</em>.  </p>
<pre>
  [CALL, Request|id, Options|dict, Procedure|uri]

  [CALL, Request|id, Options|dict, Procedure|uri, Arguments|list]

  [CALL, Request|id, Options|dict, Procedure|uri, Arguments|list,
      ArgumentsKw|dict]
</pre>
<h1 id="rfc.section.6.4.3.2"><a href="#rfc.section.6.4.3.2">6.4.3.2.</a> <a href="#result" id="result">RESULT</a></h1>
<p id="rfc.section.6.4.3.2.p.1">Result of a call as returned by <em>Dealer</em> to <em>Caller</em>.  </p>
<pre>
    [RESULT, CALL.Request|id, Details|dict]

    [RESULT, CALL.Request|id, Details|dict, YIELD.Arguments|list]

    [RESULT, CALL.Request|id, Details|dict, YIELD.Arguments|list,
        YIELD.ArgumentsKw|dict]
</pre>
<h1 id="rfc.section.6.4.3.3"><a href="#rfc.section.6.4.3.3">6.4.3.3.</a> <a href="#register" id="register">REGISTER</a></h1>
<p id="rfc.section.6.4.3.3.p.1">A <em>Callees</em> request to register an endpoint at a <em>Dealer</em>.  </p>
<pre>
    [REGISTER, Request|id, Options|dict, Procedure|uri]
</pre>
<h1 id="rfc.section.6.4.3.4"><a href="#rfc.section.6.4.3.4">6.4.3.4.</a> <a href="#registered" id="registered">REGISTERED</a></h1>
<p id="rfc.section.6.4.3.4.p.1">Acknowledge sent by a <em>Dealer</em> to a <em>Callee</em> for successful registration.  </p>
<pre>
    [REGISTERED, REGISTER.Request|id, Registration|id]
</pre>
<h1 id="rfc.section.6.4.3.5"><a href="#rfc.section.6.4.3.5">6.4.3.5.</a> <a href="#unregister" id="unregister">UNREGISTER</a></h1>
<p id="rfc.section.6.4.3.5.p.1">A <em>Callees</em> request to unregister a previously established registration.  </p>
<pre>
    [UNREGISTER, Request|id, REGISTERED.Registration|id]
</pre>
<h1 id="rfc.section.6.4.3.6"><a href="#rfc.section.6.4.3.6">6.4.3.6.</a> <a href="#unregistered" id="unregistered">UNREGISTERED</a></h1>
<p id="rfc.section.6.4.3.6.p.1">Acknowledge sent by a <em>Dealer</em> to a <em>Callee</em> for successful unregistration.  </p>
<pre>
    [UNREGISTERED, UNREGISTER.Request|id]
</pre>
<h1 id="rfc.section.6.4.3.7"><a href="#rfc.section.6.4.3.7">6.4.3.7.</a> <a href="#invocation" id="invocation">INVOCATION</a></h1>
<p id="rfc.section.6.4.3.7.p.1">Actual invocation of an endpoint sent by <em>Dealer</em> to a <em>Callee</em>.  </p>
<pre>
    [INVOCATION, Request|id, REGISTERED.Registration|id,
        Details|dict]

    [INVOCATION, Request|id, REGISTERED.Registration|id,
        Details|dict, C* Arguments|list]

    [INVOCATION, Request|id, REGISTERED.Registration|id,
        Details|dict, CALL.Arguments|list, CALL.ArgumentsKw|dict]
</pre>
<h1 id="rfc.section.6.4.3.8"><a href="#rfc.section.6.4.3.8">6.4.3.8.</a> <a href="#yield" id="yield">YIELD</a></h1>
<p id="rfc.section.6.4.3.8.p.1">Actual yield from an endpoint sent by a <em>Callee</em> to <em>Dealer</em>.  </p>
<pre>
    [YIELD, INVOCATION.Request|id, Options|dict]

    [YIELD, INVOCATION.Request|id, Options|dict, Arguments|list]

    [YIELD, INVOCATION.Request|id, Options|dict, Arguments|list,
        ArgumentsKw|dict]
</pre>
<h1 id="rfc.section.6.5"><a href="#rfc.section.6.5">6.5.</a> <a href="#message-codes-and-direction" id="message-codes-and-direction">Message Codes and Direction</a></h1>
<p id="rfc.section.6.5.p.1">The following table lists the message type code for <strong>all 25 messages defined in the WAMP basic profile</strong> and their direction between peer roles.  </p>
<p id="rfc.section.6.5.p.2">Reserved codes may be used to identify additional message types in future standards documents.  </p>
<p/>

<ul class="empty">
  <li>"Tx" indicates the message is sent by the respective role, and "Rx" indicates the message is received by the respective role.  </li>
</ul>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="center">Cod</th>
      <th class="center">Message</th>
      <th class="center">Pub</th>
      <th class="center">Brk</th>
      <th class="center">Subs</th>
      <th class="center">Calr</th>
      <th class="center">Dealr</th>
      <th class="center">Callee</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="center">1</td>
      <td class="center">
        <samp>HELLO</samp>
      </td>
      <td class="center">Tx</td>
      <td class="center">Rx</td>
      <td class="center">Tx</td>
      <td class="center">Tx</td>
      <td class="center">Rx</td>
      <td class="center">Tx</td>
    </tr>
    <tr>
      <td class="center">2</td>
      <td class="center">
        <samp>WELCOME</samp>
      </td>
      <td class="center">Rx</td>
      <td class="center">Tx</td>
      <td class="center">Rx</td>
      <td class="center">Rx</td>
      <td class="center">Tx</td>
      <td class="center">Rx</td>
    </tr>
    <tr>
      <td class="center">3</td>
      <td class="center">
        <samp>ABORT</samp>
      </td>
      <td class="center">Rx</td>
      <td class="center">TxRx</td>
      <td class="center">Rx</td>
      <td class="center">Rx</td>
      <td class="center">TxRx</td>
      <td class="center">Rx</td>
    </tr>
    <tr>
      <td class="center">6</td>
      <td class="center">
        <samp>GOODBYE</samp>
      </td>
      <td class="center">TxRx</td>
      <td class="center">TxRx</td>
      <td class="center">TxRx</td>
      <td class="center">TxRx</td>
      <td class="center">TxRx</td>
      <td class="center">TxRx</td>
    </tr>
    <tr>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
    </tr>
    <tr>
      <td class="center">8</td>
      <td class="center">
        <samp>ERROR</samp>
      </td>
      <td class="center">Rx</td>
      <td class="center">Tx</td>
      <td class="center">Rx</td>
      <td class="center">Rx</td>
      <td class="center">TxRx</td>
      <td class="center">TxRx</td>
    </tr>
    <tr>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
    </tr>
    <tr>
      <td class="center">16</td>
      <td class="center">
        <samp>PUBLISH</samp>
      </td>
      <td class="center">Tx</td>
      <td class="center">Rx</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
    </tr>
    <tr>
      <td class="center">17</td>
      <td class="center">
        <samp>PUBLISHED</samp>
      </td>
      <td class="center">Rx</td>
      <td class="center">Tx</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
    </tr>
    <tr>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
    </tr>
    <tr>
      <td class="center">32</td>
      <td class="center">
        <samp>SUBSCRIBE</samp>
      </td>
      <td class="center"/>
      <td class="center">Rx</td>
      <td class="center">Tx</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
    </tr>
    <tr>
      <td class="center">33</td>
      <td class="center">
        <samp>SUBSCRIBED</samp>
      </td>
      <td class="center"/>
      <td class="center">Tx</td>
      <td class="center">Rx</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
    </tr>
    <tr>
      <td class="center">34</td>
      <td class="center">
        <samp>UNSUBSCRIBE</samp>
      </td>
      <td class="center"/>
      <td class="center">Rx</td>
      <td class="center">Tx</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
    </tr>
    <tr>
      <td class="center">35</td>
      <td class="center">
        <samp>UNSUBSCRIBED</samp>
      </td>
      <td class="center"/>
      <td class="center">Tx</td>
      <td class="center">Rx</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
    </tr>
    <tr>
      <td class="center">36</td>
      <td class="center">
        <samp>EVENT</samp>
      </td>
      <td class="center"/>
      <td class="center">Tx</td>
      <td class="center">Rx</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
    </tr>
    <tr>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
    </tr>
    <tr>
      <td class="center">48</td>
      <td class="center">
        <samp>CALL</samp>
      </td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center">Tx</td>
      <td class="center">Rx</td>
      <td class="center"/>
    </tr>
    <tr>
      <td class="center">50</td>
      <td class="center">
        <samp>RESULT</samp>
      </td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center">Rx</td>
      <td class="center">Tx</td>
      <td class="center"/>
    </tr>
    <tr>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
    </tr>
    <tr>
      <td class="center">64</td>
      <td class="center">
        <samp>REGISTER</samp>
      </td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center">Rx</td>
      <td class="center">Tx</td>
    </tr>
    <tr>
      <td class="center">65</td>
      <td class="center">
        <samp>REGISTERED</samp>
      </td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center">Tx</td>
      <td class="center">Rx</td>
    </tr>
    <tr>
      <td class="center">66</td>
      <td class="center">
        <samp>UNREGISTER</samp>
      </td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center">Rx</td>
      <td class="center">Tx</td>
    </tr>
    <tr>
      <td class="center">67</td>
      <td class="center">
        <samp>UNREGISTERED</samp>
      </td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center">Tx</td>
      <td class="center">Rx</td>
    </tr>
    <tr>
      <td class="center">68</td>
      <td class="center">
        <samp>INVOCATION</samp>
      </td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center">Tx</td>
      <td class="center">Rx</td>
    </tr>
    <tr>
      <td class="center">70</td>
      <td class="center">
        <samp>YIELD</samp>
      </td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center">Rx</td>
      <td class="center">Tx</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.section.6.6"><a href="#rfc.section.6.6">6.6.</a> <a href="#extension-messages" id="extension-messages">Extension Messages</a></h1>
<p id="rfc.section.6.6.p.1">WAMP uses type codes from the core range [0, 255]. Implementations MAY define and use implementation specific messages with message type codes from the extension message range [256, 1023]. For example, a router MAY implement router-to-router communication by using extension messages.  </p>
<h1 id="rfc.section.6.7"><a href="#rfc.section.6.7">6.7.</a> <a href="#empty-arguments-and-keyword-arguments" id="empty-arguments-and-keyword-arguments">Empty Arguments and Keyword Arguments</a></h1>
<p id="rfc.section.6.7.p.1">Implementations SHOULD avoid sending empty <samp>Arguments</samp> lists.  </p>
<p id="rfc.section.6.7.p.2">E.g. a <samp>CALL</samp> message </p>
<pre>
    [CALL, Request|id, Options|dict, Procedure|uri,
        Arguments|list]
</pre>
<p id="rfc.section.6.7.p.3">where <samp>Arguments == []</samp> SHOULD be avoided, and instead </p>
<pre>
    [CALL, Request|id, Options|dict, Procedure|uri]
</pre>
<p id="rfc.section.6.7.p.4">SHOULD be sent.  </p>
<p id="rfc.section.6.7.p.5">Implementations SHOULD avoid sending empty <samp>ArgumentsKw</samp> dictionaries.  </p>
<p id="rfc.section.6.7.p.6">E.g. a <samp>CALL</samp> message </p>
<pre>
    [CALL, Request|id, Options|dict, Procedure|uri,
        Arguments|list, ArgumentsKw|dict]
</pre>
<p id="rfc.section.6.7.p.7">where <samp>ArgumentsKw == {}</samp> SHOULD be avoided, and instead </p>
<pre>
    [CALL, Request|id, Options|dict, Procedure|uri,
        Arguments|list]
</pre>
<p id="rfc.section.6.7.p.8">SHOULD be sent when <samp>Arguments</samp> is non-empty.  </p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#sessions" id="sessions">Sessions</a></h1>
<p id="rfc.section.7.p.1">The message flow between <em>Clients</em> and <em>Routers</em> for opening and closing WAMP sessions involves the following messages: </p>
<p/>

<ol>
  <li>
    <samp>HELLO</samp>
  </li>
  <li>
    <samp>WELCOME</samp>
  </li>
  <li>
    <samp>ABORT</samp>
  </li>
  <li>
    <samp>GOODBYE</samp>
  </li>
</ol>

<p> </p>
<h1 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a> <a href="#session-establishment" id="session-establishment">Session Establishment</a></h1>
<h1 id="rfc.section.7.1.1"><a href="#rfc.section.7.1.1">7.1.1.</a> <a href="#hello-1" id="hello-1">HELLO</a></h1>
<p id="rfc.section.7.1.1.p.1">After the underlying transport has been established, the opening of a WAMP session is initiated by the <em>Client</em> sending a <samp>HELLO</samp> message to the <em>Router</em> </p>
<pre>
    [HELLO, Realm|uri, Details|dict]
</pre>
<p id="rfc.section.7.1.1.p.2">where </p>
<p/>

<ul>
  <li><samp>Realm</samp> is a string identifying the realm this session should attach to</li>
  <li><samp>Details</samp> is a dictionary that allows to provide additional opening information (see below).</li>
</ul>

<p> </p>
<p id="rfc.section.7.1.1.p.4">The <samp>HELLO</samp> message MUST be the very first message sent by the <em>Client</em> after the transport has been established.  </p>
<p id="rfc.section.7.1.1.p.5">In the WAMP Basic Profile without session authentication the <em>Router</em> will reply with a <samp>WELCOME</samp> or <samp>ABORT</samp> message.  </p>
<pre>
    ,------.          ,------.
    |Client|          |Router|
    `--+---'          `--+---'
       |      HELLO      |
       | ----------------&gt;
       |                 |
       |     WELCOME     |
       | &lt;----------------
    ,--+---.          ,--+---.
    |Client|          |Router|
    `------'          `------'
</pre>
<p id="rfc.section.7.1.1.p.6">A WAMP session starts its lifetime when the <em>Router</em> has sent a <samp>WELCOME</samp> message to the <em>Client</em>, and ends when the underlying transport closes or when the session is closed explicitly by either peer sending the <samp>GOODBYE</samp> message (see below).  </p>
<p id="rfc.section.7.1.1.p.7">It is a protocol error to receive a second <samp>HELLO</samp> message during the lifetime of the session and the <em>Peer</em> must fail the session if that happens.  </p>
<h1 id="rfc.section.7.1.1.1"><a href="#rfc.section.7.1.1.1">7.1.1.1.</a> <a href="#client-role-and-feature-announcement" id="client-role-and-feature-announcement">Client: Role and Feature Announcement</a></h1>
<p id="rfc.section.7.1.1.1.p.1">WAMP uses <em>Role &amp; Feature announcement</em> instead of <em>protocol versioning</em> to allow </p>
<p/>

<ul>
  <li>implementations only supporting subsets of functionality</li>
  <li>future extensibility</li>
</ul>

<p> </p>
<p id="rfc.section.7.1.1.1.p.3">A <em>Client</em> must announce the <strong>roles</strong> it supports via <samp>Hello.Details.roles|dict</samp>, with a key mapping to a <samp>Hello.Details.roles.&lt;role&gt;|dict</samp> where <samp>&lt;role&gt;</samp> can be: </p>
<p/>

<ul>
  <li>
    <samp>publisher</samp>
  </li>
  <li>
    <samp>subscriber</samp>
  </li>
  <li>
    <samp>caller</samp>
  </li>
  <li>
    <samp>callee</samp>
  </li>
</ul>

<p> </p>
<p id="rfc.section.7.1.1.1.p.5">A <em>Client</em> can support any combination of the above roles but must support at least one role.  </p>
<p id="rfc.section.7.1.1.1.p.6">The <samp>&lt;role&gt;|dict</samp> is a dictionary describing <strong>features</strong> supported by the peer for that role.  </p>
<p id="rfc.section.7.1.1.1.p.7">This MUST be empty for WAMP Basic Profile implementations, and MUST be used by implementations implementing parts of the Advanced Profile to list the specific set of features they support.  </p>
<p><em>Example: A Client that implements the Publisher and Subscriber roles of the WAMP Basic Profile.</em> </p>
<pre>
    [1, "somerealm", {
      "roles": {
          "publisher": {},
          "subscriber": {}
      }
    }]
</pre>
<h1 id="rfc.section.7.1.2"><a href="#rfc.section.7.1.2">7.1.2.</a> <a href="#welcome-1" id="welcome-1">WELCOME</a></h1>
<p id="rfc.section.7.1.2.p.1">A <em>Router</em> completes the opening of a WAMP session by sending a <samp>WELCOME</samp> reply message to the <em>Client</em>.  </p>
<pre>
    [WELCOME, Session|id, Details|dict]
</pre>
<p id="rfc.section.7.1.2.p.2">where </p>
<p/>

<ul>
  <li><samp>Session</samp> MUST be a randomly generated ID specific to the WAMP session. This applies for the lifetime of the session.</li>
  <li><samp>Details</samp> is a dictionary that allows to provide additional information regarding the open session (see below).</li>
</ul>

<p> </p>
<p id="rfc.section.7.1.2.p.4">In the WAMP Basic Profile without session authentication, a <samp>WELCOME</samp> message MUST be the first message sent by the <em>Router</em>, directly in response to a <samp>HELLO</samp> message received from the <em>Client</em>. Extensions in the Advanced Profile MAY include intermediate steps and messages for authentication.  </p>
<p/>

<ul class="empty">
  <li>Note. The behavior if a requested <samp>Realm</samp> does not presently exist is router-specific. A router may e.g. automatically create the realm, or deny the establishment of the session with a <samp>ABORT</samp> reply message.  </li>
</ul>
<h1 id="rfc.section.7.1.2.1"><a href="#rfc.section.7.1.2.1">7.1.2.1.</a> <a href="#router-role-and-feature-announcement" id="router-role-and-feature-announcement">Router: Role and Feature Announcement</a></h1>
<p id="rfc.section.7.1.2.1.p.1">Similar to a <em>Client</em> announcing <em>Roles</em> and <em>Features</em> supported in the `<samp>HELLO</samp> message, a <em>Router</em> announces its supported <em>Roles</em> and <em>Features</em> in the <samp>WELCOME</samp> message.  </p>
<p id="rfc.section.7.1.2.1.p.2">A <em>Router</em> MUST announce the <strong>roles</strong> it supports via <samp>Welcome.Details.roles|dict</samp>, with a key mapping to a <samp>Welcome.Details.roles.&lt;role&gt;|dict</samp> where <samp>&lt;role&gt;</samp> can be: </p>
<p/>

<ul>
  <li>
    <samp>broker</samp>
  </li>
  <li>
    <samp>dealer</samp>
  </li>
</ul>

<p> </p>
<p id="rfc.section.7.1.2.1.p.4">A <em>Router</em> must support at least one role, and MAY support both roles.  </p>
<p id="rfc.section.7.1.2.1.p.5">The <samp>&lt;role&gt;|dict</samp> is a dictionary describing <strong>features</strong> supported by the peer for that role. With WAMP Basic Profile implementations, this MUST be empty, but MUST be used by implementations implementing parts of the Advanced Profile to list the specific set of features they support </p>
<p><em>Example: A Router implementing the Broker role of the WAMP Basic Profile.</em> </p>
<pre>
    [2, 9129137332, {
       "roles": {
          "broker": {}
       }
    }]
</pre>
<h1 id="rfc.section.7.1.3"><a href="#rfc.section.7.1.3">7.1.3.</a> <a href="#abort-1" id="abort-1">ABORT</a></h1>
<p id="rfc.section.7.1.3.p.1">Both the <em>Router</em> and the <em>Client</em> may abort the opening of a WAMP session by sending an <samp>ABORT</samp> message.  </p>
<pre>
    [ABORT, Details|dict, Reason|uri]
</pre>
<p id="rfc.section.7.1.3.p.2">where </p>
<p/>

<ul>
  <li><samp>Reason</samp> MUST be an URI.</li>
  <li><samp>Details</samp> MUST be a dictionary that allows to provide additional, optional closing information (see below).</li>
</ul>

<p> </p>
<p id="rfc.section.7.1.3.p.4">No response to an <samp>ABORT</samp> message is expected.  </p>
<pre>
    ,------.          ,------.
    |Client|          |Router|
    `--+---'          `--+---'
       |      HELLO      |
       | ----------------&gt;
       |                 |
       |      ABORT      |
       | &lt;----------------
    ,--+---.          ,--+---.
    |Client|          |Router|
    `------'          `------'
</pre>
<p><em>Example</em> </p>
<pre>
    [3, {"message": "The realm does not exist."},
        "wamp.error.no_such_realm"]
</pre>
<h1 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a> <a href="#session-closing" id="session-closing">Session Closing</a></h1>
<p id="rfc.section.7.2.p.1">A WAMP session starts its lifetime with the <em>Router</em> sending a <samp>WELCOME</samp> message to the <em>Client</em> and ends when the underlying transport disappears or when the WAMP session is closed explicitly by a <samp>GOODBYE</samp> message sent by one <em>Peer</em> and a <samp>GOODBYE</samp> message sent from the other <em>Peer</em> in response.  </p>
<pre>
    [GOODBYE, Details|dict, Reason|uri]
</pre>
<p id="rfc.section.7.2.p.2">where </p>
<p/>

<ul>
  <li><samp>Reason</samp> MUST be an URI.</li>
  <li><samp>Details</samp> MUST be a dictionary that allows to provide additional, optional closing information (see below).</li>
</ul>

<p> </p>
<pre>
    ,------.          ,------.
    |Client|          |Router|
    `--+---'          `--+---'
       |     GOODBYE     |
       | ----------------&gt;
       |                 |
       |     GOODBYE     |
       | &lt;----------------
    ,--+---.          ,--+---.
    |Client|          |Router|
    `------'          `------'
</pre>
<pre>
    ,------.          ,------.
    |Client|          |Router|
    `--+---'          `--+---'
       |     GOODBYE     |
       | &lt;----------------
       |                 |
       |     GOODBYE     |
       | ----------------&gt;
    ,--+---.          ,--+---.
    |Client|          |Router|
    `------'          `------'
</pre>
<p><em>Example</em>. One <em>Peer</em> initiates closing </p>
<pre>
    [6, {"message": "The host is shutting down now."},
        "wamp.error.system_shutdown"]
</pre>
<p id="rfc.section.7.2.p.5">and the other peer replies </p>
<pre>
    [6, {}, "wamp.error.goodbye_and_out"]
</pre>
<p><em>Example</em>. One <em>Peer</em> initiates closing </p>
<pre>
    [6, {}, "wamp.error.close_realm"]
</pre>
<p id="rfc.section.7.2.p.7">and the other peer replies </p>
<pre>
    [6, {}, "wamp.error.goodbye_and_out"]
</pre>
<h1 id="rfc.section.7.2.1"><a href="#rfc.section.7.2.1">7.2.1.</a> <a href="#difference-between-abort-and-goodbye" id="difference-between-abort-and-goodbye">Difference between ABORT and GOODBYE</a></h1>
<p id="rfc.section.7.2.1.p.1">The differences between <samp>ABORT</samp> and <samp>GOODBYE</samp> messages are: </p>
<p/>

<ol>
  <li><samp>ABORT</samp> gets sent only <em>before</em> a <em>Session</em> is established, while <samp>GOODBYE</samp> is sent only <em>after</em> a <em>Session</em> is already established.</li>
  <li><samp>ABORT</samp> is never replied to by a <em>Peer</em>, whereas <samp>GOODBYE</samp> must be replied to by the receiving <em>Peer</em></li>
</ol>

<p> </p>
<p/>

<ul class="empty">
  <li>Though <samp>ABORT</samp> and <samp>GOODBYE</samp> are structurally identical, using different message types serves to reduce overloaded meaning of messages and simplify message handling code.  </li>
</ul>
<h1 id="rfc.section.7.3"><a href="#rfc.section.7.3">7.3.</a> <a href="#agent-identification" id="agent-identification">Agent Identification</a></h1>
<p id="rfc.section.7.3.p.1">When a software agent operates in a network protocol, it often identifies itself, its application type, operating system, software vendor, or software revision, by submitting a characteristic identification string to its operating peer.  </p>
<p id="rfc.section.7.3.p.2">Similar to what browsers do with the <samp>User-Agent</samp> HTTP header, both the <samp>HELLO</samp> and the <samp>WELCOME</samp> message MAY disclose the WAMP implementation in use to its peer: </p>
<pre>
    HELLO.Details.agent|string
</pre>
<p id="rfc.section.7.3.p.3">and </p>
<pre>
    WELCOME.Details.agent|string
</pre>
<p><em>Example: A Client "HELLO" message.</em> </p>
<pre>
    [1, "somerealm", {
         "agent": "AutobahnJS-0.9.14",
         "roles": {
            "subscriber": {},
            "publisher": {}
         }
    }]
</pre>
<p><em>Example: A Router "WELCOME" message.</em> </p>
<pre>
    [2, 9129137332, {
        "agent": "Crossbar.io-0.10.11",
        "roles": {
          "broker": {}
        }
    }]
</pre>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#publish-and-subscribe" id="publish-and-subscribe">Publish and Subscribe</a></h1>
<p id="rfc.section.8.p.1">All of the following features for Publish &amp; Subscribe are mandatory for WAMP Basic Profile implementations supporting the respective roles, i.e. <em>Publisher</em>, <em>Subscriber</em> and <em>Dealer</em>.  </p>
<h1 id="rfc.section.8.1"><a href="#rfc.section.8.1">8.1.</a> <a href="#subscribing-and-unsubscribing" id="subscribing-and-unsubscribing">Subscribing and Unsubscribing</a></h1>
<p id="rfc.section.8.1.p.1">The message flow between <em>Clients</em> implementing the role of <em>Subscriber</em> and <em>Routers</em> implementing the role of <em>Broker</em> for subscribing and unsubscribing involves the following messages: </p>
<p/>

<ol>
  <li>
    <samp>SUBSCRIBE</samp>
  </li>
  <li>
    <samp>SUBSCRIBED</samp>
  </li>
  <li>
    <samp>UNSUBSCRIBE</samp>
  </li>
  <li>
    <samp>UNSUBSCRIBED</samp>
  </li>
  <li>
    <samp>ERROR</samp>
  </li>
</ol>

<p> </p>
<pre>
    ,---------.          ,------.             ,----------.
    |Publisher|          |Broker|             |Subscriber|
    `----+----'          `--+---'             `----+-----'
         |                  |                      |
         |                  |                      |
         |                  |       SUBSCRIBE      |
         |                  | &lt;---------------------
         |                  |                      |
         |                  |  SUBSCRIBED or ERROR |
         |                  | ---------------------&gt;
         |                  |                      |
         |                  |                      |
         |                  |                      |
         |                  |                      |
         |                  |      UNSUBSCRIBE     |
         |                  | &lt;---------------------
         |                  |                      |
         |                  | UNSUBSCRIBED or ERROR|
         |                  | ---------------------&gt;
    ,----+----.          ,--+---.             ,----+-----.
    |Publisher|          |Broker|             |Subscriber|
    `---------'          `------'             `----------'
</pre>
<p id="rfc.section.8.1.p.3">A <em>Subscriber</em> may subscribe to zero, one or more topics, and a <em>Publisher</em> publishes to topics without knowledge of subscribers.  </p>
<p id="rfc.section.8.1.p.4">Upon subscribing to a topic via the <samp>SUBSCRIBE</samp> message, a <em>Subscriber</em> will receive any future events published to the respective topic by <em>Publishers</em>, and will receive those events asynchronously.  </p>
<p id="rfc.section.8.1.p.5">A subscription lasts for the duration of a session, unless a <em>Subscriber</em> opts out from a previously established subscription via the <samp>UNSUBSCRIBE</samp> message.  </p>
<p/>

<ul class="empty">
  <li>A <em>Subscriber</em> may have more than one event handler attached to the same subscription. This can be implemented in different ways: a) a <em>Subscriber</em> can recognize itself that it is already subscribed and just attach another handler to the subscription for incoming events, b) or it can send a new <samp>SUBSCRIBE</samp> message to broker (as it would be first) and upon receiving a <samp>SUBSCRIBED.Subscription|id</samp> it already knows about, attach the handler to the existing subscription </li>
</ul>
<h1 id="rfc.section.8.1.1"><a href="#rfc.section.8.1.1">8.1.1.</a> <a href="#subscribe-1" id="subscribe-1">SUBSCRIBE</a></h1>
<p id="rfc.section.8.1.1.p.1">A <em>Subscriber</em> communicates its interest in a topic to a <em>Broker</em> by sending a <samp>SUBSCRIBE</samp> message: </p>
<pre>
    [SUBSCRIBE, Request|id, Options|dict, Topic|uri]
</pre>
<p id="rfc.section.8.1.1.p.2">where </p>
<p/>

<ul>
  <li><samp>Request</samp> MUST be a random, ephemeral ID chosen by the <em>Subscriber</em> and used to correlate the <em>Broker's</em> response with the request.</li>
  <li><samp>Options</samp> MUST be a dictionary that allows to provide additional subscription request details in a extensible way. This is described further below.</li>
  <li><samp>Topic</samp> is the topic the <em>Subscriber</em> wants to subscribe to and MUST be an URI.</li>
</ul>

<p> </p>
<p><em>Example</em> </p>
<pre>
    [32, 713845233, {}, "com.myapp.mytopic1"]
</pre>
<p id="rfc.section.8.1.1.p.5">A <em>Broker</em>, receiving a <samp>SUBSCRIBE</samp> message, can fullfill or reject the subscription, so it answers with <samp>SUBSCRIBED</samp> or <samp>ERROR</samp> messages.  </p>
<h1 id="rfc.section.8.1.2"><a href="#rfc.section.8.1.2">8.1.2.</a> <a href="#subscribed-1" id="subscribed-1">SUBSCRIBED</a></h1>
<p id="rfc.section.8.1.2.p.1">If the <em>Broker</em> is able to fulfill and allow the subscription, it answers by sending a <samp>SUBSCRIBED</samp> message to the <em>Subscriber</em> </p>
<pre>
    [SUBSCRIBED, SUBSCRIBE.Request|id, Subscription|id]
</pre>
<p id="rfc.section.8.1.2.p.2">where </p>
<p/>

<ul>
  <li><samp>SUBSCRIBE.Request</samp> MUST be the ID from the original request.</li>
  <li><samp>Subscription</samp> MUST be an ID chosen by the <em>Broker</em> for the subscription.</li>
</ul>

<p> </p>
<p><em>Example</em> </p>
<pre>
    [33, 713845233, 5512315355]
</pre>
<p/>

<ul class="empty">
  <li>Note. The <samp>Subscription</samp> ID chosen by the broker need not be unique to the subscription of a single <em>Subscriber</em>, but may be assigned to the <samp>Topic</samp>, or the combination of the <samp>Topic</samp> and some or all <samp>Options</samp>, such as the topic pattern matching method to be used. Then this ID may be sent to all <em>Subscribers</em> for the <samp>Topic</samp> or <samp>Topic</samp> /  <samp>Options</samp> combination. This allows the <em>Broker</em> to serialize an event to be delivered only once for all actual receivers of the event.  </li>
  <li>In case of receiving a <samp>SUBSCRIBE</samp> message from the same <em>Subscriber</em> and to already subscribed topic, <em>Broker</em> should answer with <samp>SUBSCRIBED</samp> message, containing the existing <samp>Subscription|id</samp>.  </li>
</ul>
<h1 id="rfc.section.8.1.3"><a href="#rfc.section.8.1.3">8.1.3.</a> <a href="#subscribe-error" id="subscribe-error">Subscribe ERROR</a></h1>
<p id="rfc.section.8.1.3.p.1">When the request for subscription cannot be fulfilled by the <em>Broker</em>, the <em>Broker</em> sends back an <samp>ERROR</samp> message to the <em>Subscriber</em> </p>
<pre>
    [ERROR, SUBSCRIBE, SUBSCRIBE.Request|id, Details|dict,
        Error|uri]
</pre>
<p id="rfc.section.8.1.3.p.2">where </p>
<p/>

<ul>
  <li><samp>SUBSCRIBE.Request</samp> MUST be the ID from the original request.</li>
  <li><samp>Error</samp> MUST be an URI that gives the error of why the request could not be fulfilled.</li>
</ul>

<p> </p>
<p><em>Example</em> </p>
<pre>
    [8, 32, 713845233, {}, "wamp.error.not_authorized"]
</pre>
<h1 id="rfc.section.8.1.4"><a href="#rfc.section.8.1.4">8.1.4.</a> <a href="#unsubscribe-1" id="unsubscribe-1">UNSUBSCRIBE</a></h1>
<p id="rfc.section.8.1.4.p.1">When a <em>Subscriber</em> is no longer interested in receiving events for a subscription it sends an <samp>UNSUBSCRIBE</samp> message </p>
<pre>
    [UNSUBSCRIBE, Request|id, SUBSCRIBED.Subscription|id]
</pre>
<p id="rfc.section.8.1.4.p.2">where </p>
<p/>

<ul>
  <li><samp>Request</samp> MUST be a random, ephemeral ID chosen by the <em>Subscriber</em> and used to correlate the <em>Broker's</em> response with the request.</li>
  <li><samp>SUBSCRIBED.Subscription</samp> MUST be the ID for the subscription to unsubscribe from, originally handed out by the <em>Broker</em> to the <em>Subscriber</em>.</li>
</ul>

<p> </p>
<p><em>Example</em> </p>
<pre>
    [34, 85346237, 5512315355]
</pre>
<h1 id="rfc.section.8.1.5"><a href="#rfc.section.8.1.5">8.1.5.</a> <a href="#unsubscribed-1" id="unsubscribed-1">UNSUBSCRIBED</a></h1>
<p id="rfc.section.8.1.5.p.1">Upon successful unsubscription, the <em>Broker</em> sends an <samp>UNSUBSCRIBED</samp> message to the <em>Subscriber</em> </p>
<pre>
    [UNSUBSCRIBED, UNSUBSCRIBE.Request|id]
</pre>
<p id="rfc.section.8.1.5.p.2">where </p>
<p/>

<ul>
  <li><samp>UNSUBSCRIBE.Request</samp> MUST be the ID from the original request.</li>
</ul>

<p> </p>
<p><em>Example</em> </p>
<pre>
    [35, 85346237]
</pre>
<h1 id="rfc.section.8.1.6"><a href="#rfc.section.8.1.6">8.1.6.</a> <a href="#unsubscribe-error" id="unsubscribe-error">Unsubscribe ERROR</a></h1>
<p id="rfc.section.8.1.6.p.1">When the request fails, the <em>Broker</em> sends an <samp>ERROR</samp> </p>
<pre>
    [ERROR, UNSUBSCRIBE, UNSUBSCRIBE.Request|id, Details|dict,
        Error|uri]
</pre>
<p id="rfc.section.8.1.6.p.2">where </p>
<p/>

<ul>
  <li><samp>UNSUBSCRIBE.Request</samp> MUST be the ID from the original request.</li>
  <li><samp>Error</samp> MUST be an URI that gives the error of why the request could not be fulfilled.</li>
</ul>

<p> </p>
<p><em>Example</em> </p>
<pre>
    [8, 34, 85346237, {}, "wamp.error.no_such_subscription"]
</pre>
<h1 id="rfc.section.8.2"><a href="#rfc.section.8.2">8.2.</a> <a href="#publishing-and-events" id="publishing-and-events">Publishing and Events</a></h1>
<p id="rfc.section.8.2.p.1">The message flow between <em>Publishers</em>, a <em>Broker</em> and <em>Subscribers</em> for publishing to topics and dispatching events involves the following messages: </p>
<p/>

<ol>
  <li>
    <samp>PUBLISH</samp>
  </li>
  <li>
    <samp>PUBLISHED</samp>
  </li>
  <li>
    <samp>EVENT</samp>
  </li>
  <li>
    <samp>ERROR</samp>
  </li>
</ol>

<p> </p>
<pre>
    ,---------.          ,------.          ,----------.
    |Publisher|          |Broker|          |Subscriber|
    `----+----'          `--+---'          `----+-----'
         |     PUBLISH      |                   |
         |------------------&gt;                   |
         |                  |                   |
         |PUBLISHED or ERROR|                   |
         |&lt;------------------                   |
         |                  |                   |
         |                  |       EVENT       |
         |                  | ------------------&gt;
    ,----+----.          ,--+---.          ,----+-----.
    |Publisher|          |Broker|          |Subscriber|
    `---------'          `------'          `----------'
</pre>
<h1 id="rfc.section.8.2.1"><a href="#rfc.section.8.2.1">8.2.1.</a> <a href="#publish-1" id="publish-1">PUBLISH</a></h1>
<p id="rfc.section.8.2.1.p.1">When a <em>Publisher</em> requests to publish an event to some topic, it sends a <samp>PUBLISH</samp> message to a <em>Broker</em>: </p>
<pre>
    [PUBLISH, Request|id, Options|dict, Topic|uri]
</pre>
<p id="rfc.section.8.2.1.p.2">or </p>
<pre>
    [PUBLISH, Request|id, Options|dict, Topic|uri, Arguments|list]
</pre>
<p id="rfc.section.8.2.1.p.3">or </p>
<pre>
    [PUBLISH, Request|id, Options|dict, Topic|uri, Arguments|list,
        ArgumentsKw|dict]
</pre>
<p id="rfc.section.8.2.1.p.4">where </p>
<p/>

<ul>
  <li><samp>Request</samp> is a random, ephemeral ID chosen by the <em>Publisher</em> and used to correlate the <em>Broker's</em> response with the request.</li>
  <li><samp>Options</samp> is a dictionary that allows to provide additional publication request details in an extensible way. This is described further below.</li>
  <li><samp>Topic</samp> is the topic published to.</li>
  <li><samp>Arguments</samp> is a list of application-level event payload elements. The list may be of zero length.</li>
  <li><samp>ArgumentsKw</samp> is an optional dictionary containing application-level event payload, provided as keyword arguments. The dictionary may be empty.</li>
</ul>

<p> </p>
<p id="rfc.section.8.2.1.p.6">If the <em>Broker</em> is able to fulfill and allowing the publication, the <em>Broker</em> will send the event to all current <em>Subscribers</em> of the topic of the published event.  </p>
<p id="rfc.section.8.2.1.p.7">By default, publications are unacknowledged, and the <em>Broker</em> will not respond, whether the publication was successful indeed or not. This behavior can be changed with the option <samp>PUBLISH.Options.acknowledge|bool</samp> (see below).  </p>
<p><em>Example</em> </p>
<pre>
    [16, 239714735, {}, "com.myapp.mytopic1"]
</pre>
<p><em>Example</em> </p>
<pre>
    [16, 239714735, {}, "com.myapp.mytopic1", ["Hello, world!"]]
</pre>
<p><em>Example</em> </p>
<pre>
    [16, 239714735, {}, "com.myapp.mytopic1", [], {"color": "orange",
        "sizes": [23, 42, 7]}]
</pre>
<h1 id="rfc.section.8.2.2"><a href="#rfc.section.8.2.2">8.2.2.</a> <a href="#published-1" id="published-1">PUBLISHED</a></h1>
<p id="rfc.section.8.2.2.p.1">If the <em>Broker</em> is able to fulfill and allowing the publication, and <samp>PUBLISH.Options.acknowledge == true</samp>, the <em>Broker</em> replies by sending a <samp>PUBLISHED</samp> message to the <em>Publisher</em>: </p>
<pre>
    [PUBLISHED, PUBLISH.Request|id, Publication|id]
</pre>
<p id="rfc.section.8.2.2.p.2">where </p>
<p/>

<ul>
  <li><samp>PUBLISH.Request</samp> is the ID from the original publication request.</li>
  <li><samp>Publication</samp> is a ID chosen by the Broker for the publication.</li>
</ul>

<p> </p>
<p><em>Example</em> </p>
<pre>
    [17, 239714735, 4429313566]
</pre>
<h1 id="rfc.section.8.2.3"><a href="#rfc.section.8.2.3">8.2.3.</a> <a href="#publish-error" id="publish-error">Publish ERROR</a></h1>
<p id="rfc.section.8.2.3.p.1">When the request for publication cannot be fulfilled by the <em>Broker</em>, and <samp>PUBLISH.Options.acknowledge == true</samp>, the <em>Broker</em> sends back an <samp>ERROR</samp> message to the <em>Publisher</em> </p>
<pre>
    [ERROR, PUBLISH, PUBLISH.Request|id, Details|dict, Error|uri]
</pre>
<p id="rfc.section.8.2.3.p.2">where </p>
<p/>

<ul>
  <li><samp>PUBLISH.Request</samp> is the ID from the original publication request.</li>
  <li><samp>Error</samp> is an URI that gives the error of why the request could not be fulfilled.</li>
</ul>

<p> </p>
<p><em>Example</em> </p>
<pre>
    [8, 16, 239714735, {}, "wamp.error.not_authorized"]
</pre>
<h1 id="rfc.section.8.2.4"><a href="#rfc.section.8.2.4">8.2.4.</a> <a href="#event-1" id="event-1">EVENT</a></h1>
<p id="rfc.section.8.2.4.p.1">When a publication is successful and a <em>Broker</em> dispatches the event, it determines a list of receivers for the event based on <em>Subscribers</em> for the topic published to and, possibly, other information in the event.  </p>
<p id="rfc.section.8.2.4.p.2">Note that the <em>Publisher</em> of an event will never receive the published event even if the <em>Publisher</em> is also a <em>Subscriber</em> of the topic published to.  </p>
<p/>

<ul class="empty">
  <li>The Advanced Profile provides options for more detailed control over publication.  </li>
</ul>
<p id="rfc.section.8.2.4.p.4">When a <em>Subscriber</em> is deemed to be a receiver, the <em>Broker</em> sends the <em>Subscriber</em> an <samp>EVENT</samp> message: </p>
<pre>
    [EVENT, SUBSCRIBED.Subscription|id, PUBLISHED.Publication|id,
        Details|dict]
</pre>
<p id="rfc.section.8.2.4.p.5">or </p>
<pre>
    [EVENT, SUBSCRIBED.Subscription|id, PUBLISHED.Publication|id,
        Details|dict, PUBLISH.Arguments|list]
</pre>
<p id="rfc.section.8.2.4.p.6">or </p>
<pre>
    [EVENT, SUBSCRIBED.Subscription|id, PUBLISHED.Publication|id,
    Details|dict, PUBLISH.Arguments|list, PUBLISH.ArgumentKw|dict]
</pre>
<p id="rfc.section.8.2.4.p.7">where </p>
<p/>

<ul>
  <li><samp>SUBSCRIBED.Subscription</samp> is the ID for the subscription under which the <em>Subscriber</em> receives the event - the ID for the subscription originally handed out by the <em>Broker</em> to the <em>Subscriber</em>.</li>
  <li><samp>PUBLISHED.Publication</samp> is the ID of the publication of the published event.</li>
  <li><samp>Details</samp> is a dictionary that allows the <em>Broker</em> to provide additional event details in a extensible way. This is described further below.</li>
  <li><samp>PUBLISH.Arguments</samp> is the application-level event payload that was provided with the original publication request.</li>
  <li><samp>PUBLISH.ArgumentKw</samp> is the application-level event payload that was provided with the original publication request.</li>
</ul>

<p> </p>
<p><em>Example</em> </p>
<pre>
    [36, 5512315355, 4429313566, {}]
</pre>
<p><em>Example</em> </p>
<pre>
    [36, 5512315355, 4429313566, {}, ["Hello, world!"]]
</pre>
<p><em>Example</em> </p>
<pre>
    [36, 5512315355, 4429313566, {}, [], {"color": "orange",
        "sizes": [23, 42, 7]}]
</pre>
<h1 id="rfc.section.9"><a href="#rfc.section.9">9.</a> <a href="#remote-procedure-calls" id="remote-procedure-calls">Remote Procedure Calls</a></h1>
<p id="rfc.section.9.p.1">All of the following features for Remote Procedure Calls are mandatory for WAMP Basic Profile implementations supporting the respective roles.  </p>
<h1 id="rfc.section.9.1"><a href="#rfc.section.9.1">9.1.</a> <a href="#registering-and-unregistering" id="registering-and-unregistering">Registering and Unregistering</a></h1>
<p id="rfc.section.9.1.p.1">The message flow between <em>Callees</em> and a <em>Dealer</em> for registering and unregistering endpoints to be called over RPC involves the following messages: </p>
<p/>

<ol>
  <li>
    <samp>REGISTER</samp>
  </li>
  <li>
    <samp>REGISTERED</samp>
  </li>
  <li>
    <samp>UNREGISTER</samp>
  </li>
  <li>
    <samp>UNREGISTERED</samp>
  </li>
  <li>
    <samp>ERROR</samp>
  </li>
</ol>

<p> </p>
<pre>
    ,------.          ,------.               ,------.
    |Caller|          |Dealer|               |Callee|
    `--+---'          `--+---'               `--+---'
       |                 |                      |
       |                 |                      |
       |                 |       REGISTER       |
       |                 | &lt;---------------------
       |                 |                      |
       |                 |  REGISTERED or ERROR |
       |                 | ---------------------&gt;
       |                 |                      |
       |                 |                      |
       |                 |                      |
       |                 |                      |
       |                 |                      |
       |                 |      UNREGISTER      |
       |                 | &lt;---------------------
       |                 |                      |
       |                 | UNREGISTERED or ERROR|
       |                 | ---------------------&gt;
    ,--+---.          ,--+---.               ,--+---.
    |Caller|          |Dealer|               |Callee|
    `------'          `------'               `------'
</pre>
<h1 id="rfc.section.9.1.1"><a href="#rfc.section.9.1.1">9.1.1.</a> <a href="#register-1" id="register-1">REGISTER</a></h1>
<p id="rfc.section.9.1.1.p.1">A <em>Callee</em> announces the availability of an endpoint implementing a procedure with a <em>Dealer</em> by sending a <samp>REGISTER</samp> message: </p>
<pre>
    [REGISTER, Request|id, Options|dict, Procedure|uri]
</pre>
<p id="rfc.section.9.1.1.p.2">where </p>
<p/>

<ul>
  <li><samp>Request</samp> is a random, ephemeral ID chosen by the <em>Callee</em> and used to correlate the <em>Dealer's</em> response with the request.</li>
  <li><samp>Options</samp> is a dictionary that allows to provide additional registration request details in a extensible way. This is described further below.</li>
  <li><samp>Procedure</samp>is the procedure the <em>Callee</em> wants to register</li>
</ul>

<p> </p>
<p><em>Example</em> </p>
<pre>
    [64, 25349185, {}, "com.myapp.myprocedure1"]
</pre>
<h1 id="rfc.section.9.1.2"><a href="#rfc.section.9.1.2">9.1.2.</a> <a href="#registered-1" id="registered-1">REGISTERED</a></h1>
<p id="rfc.section.9.1.2.p.1">If the <em>Dealer</em> is able to fulfill and allowing the registration, it answers by sending a <samp>REGISTERED</samp> message to the <samp>Callee</samp>: </p>
<pre>
    [REGISTERED, REGISTER.Request|id, Registration|id]
</pre>
<p id="rfc.section.9.1.2.p.2">where </p>
<p/>

<ul>
  <li><samp>REGISTER.Request</samp> is the ID from the original request.</li>
  <li><samp>Registration</samp> is an ID chosen by the <em>Dealer</em> for the registration.</li>
</ul>

<p> </p>
<p><em>Example</em> </p>
<pre>
    [65, 25349185, 2103333224]
</pre>
<h1 id="rfc.section.9.1.3"><a href="#rfc.section.9.1.3">9.1.3.</a> <a href="#register-error" id="register-error">Register ERROR</a></h1>
<p id="rfc.section.9.1.3.p.1">When the request for registration cannot be fulfilled by the <em>Dealer</em>, the <em>Dealer</em> sends back an <samp>ERROR</samp> message to the <em>Callee</em>: </p>
<pre>
    [ERROR, REGISTER, REGISTER.Request|id, Details|dict, Error|uri]
</pre>
<p id="rfc.section.9.1.3.p.2">where </p>
<p/>

<ul>
  <li><samp>REGISTER.Request</samp> is the ID from the original request.</li>
  <li><samp>Error</samp> is an URI that gives the error of why the request could not be fulfilled.</li>
</ul>

<p> </p>
<p><em>Example</em> </p>
<pre>
    [8, 64, 25349185, {}, "wamp.error.procedure_already_exists"]
</pre>
<h1 id="rfc.section.9.1.4"><a href="#rfc.section.9.1.4">9.1.4.</a> <a href="#unregister-1" id="unregister-1">UNREGISTER</a></h1>
<p id="rfc.section.9.1.4.p.1">When a <em>Callee</em> is no longer willing to provide an implementation of the registered procedure, it sends an <samp>UNREGISTER</samp> message to the <em>Dealer</em>: </p>
<pre>
    [UNREGISTER, Request|id, REGISTERED.Registration|id]
</pre>
<p id="rfc.section.9.1.4.p.2">where </p>
<p/>

<ul>
  <li><samp>Request</samp> is a random, ephemeral ID chosen by the <em>Callee</em> and used to correlate the <em>Dealer's</em> response with the request.</li>
  <li><samp>REGISTERED.Registration</samp> is the ID for the registration to revoke, originally handed out by the <em>Dealer</em> to the <em>Callee</em>.</li>
</ul>

<p> </p>
<p><em>Example</em> </p>
<pre>
    [66, 788923562, 2103333224]
</pre>
<h1 id="rfc.section.9.1.5"><a href="#rfc.section.9.1.5">9.1.5.</a> <a href="#unregistered-1" id="unregistered-1">UNREGISTERED</a></h1>
<p id="rfc.section.9.1.5.p.1">Upon successful unregistration, the <em>Dealer</em> sends an <samp>UNREGISTERED</samp> message to the <em>Callee</em>: </p>
<pre>
    [UNREGISTERED, UNREGISTER.Request|id]
</pre>
<p id="rfc.section.9.1.5.p.2">where </p>
<p/>

<ul>
  <li><samp>UNREGISTER.Request</samp> is the ID from the original request.</li>
</ul>

<p> </p>
<p><em>Example</em> </p>
<pre>
    [67, 788923562]
</pre>
<h1 id="rfc.section.9.1.6"><a href="#rfc.section.9.1.6">9.1.6.</a> <a href="#unregister-error" id="unregister-error">Unregister ERROR</a></h1>
<p id="rfc.section.9.1.6.p.1">When the unregistration request fails, the <em>Dealer</em> sends an <samp>ERROR</samp> message: </p>
<pre>
    [ERROR, UNREGISTER, UNREGISTER.Request|id, Details|dict,
        Error|uri]
</pre>
<p id="rfc.section.9.1.6.p.2">where </p>
<p/>

<ul>
  <li><samp>UNREGISTER.Request</samp> is the ID from the original request.</li>
  <li><samp>Error</samp> is an URI that gives the error of why the request could not be fulfilled.</li>
</ul>

<p> </p>
<p><em>Example</em> </p>
<pre>
    [8, 66, 788923562, {}, "wamp.error.no_such_registration"]
</pre>
<h1 id="rfc.section.9.2"><a href="#rfc.section.9.2">9.2.</a> <a href="#calling-and-invocations" id="calling-and-invocations">Calling and Invocations</a></h1>
<p id="rfc.section.9.2.p.1">The message flow between <em>Callers</em>, a <em>Dealer</em> and <em>Callees</em> for calling procedures and invoking endpoints involves the following messages: </p>
<p/>

<ol>
  <li>
    <samp>CALL</samp>
  </li>
  <li>
    <samp>RESULT</samp>
  </li>
  <li>
    <samp>INVOCATION</samp>
  </li>
  <li>
    <samp>YIELD</samp>
  </li>
  <li>
    <samp>ERROR</samp>
  </li>
</ol>

<p> </p>
<pre>
    ,------.          ,------.          ,------.
    |Caller|          |Dealer|          |Callee|
    `--+---'          `--+---'          `--+---'
       |       CALL      |                 |
       | ----------------&gt;                 |
       |                 |                 |
       |                 |    INVOCATION   |
       |                 | ----------------&gt;
       |                 |                 |
       |                 |  YIELD or ERROR |
       |                 | &lt;----------------
       |                 |                 |
       | RESULT or ERROR |                 |
       | &lt;----------------                 |
    ,--+---.          ,--+---.          ,--+---.
    |Caller|          |Dealer|          |Callee|
    `------'          `------'          `------'
</pre>
<p id="rfc.section.9.2.p.3">The execution of remote procedure calls is asynchronous, and there may be more than one call outstanding. A call is called outstanding (from the point of view of the <em>Caller</em>), when a (final) result or error has not yet been received by the <em>Caller</em>.  </p>
<h1 id="rfc.section.9.2.1"><a href="#rfc.section.9.2.1">9.2.1.</a> <a href="#call-1" id="call-1">CALL</a></h1>
<p id="rfc.section.9.2.1.p.1">When a <em>Caller</em> wishes to call a remote procedure, it sends a <samp>CALL</samp> message to a <em>Dealer</em>: </p>
<pre>
    [CALL, Request|id, Options|dict, Procedure|uri]
</pre>
<p id="rfc.section.9.2.1.p.2">or </p>
<pre>
    [CALL, Request|id, Options|dict, Procedure|uri, Arguments|list]
</pre>
<p id="rfc.section.9.2.1.p.3">or </p>
<pre>
    [CALL, Request|id, Options|dict, Procedure|uri, Arguments|list,
        ArgumentsKw|dict]
</pre>
<p id="rfc.section.9.2.1.p.4">where </p>
<p/>

<ul>
  <li><samp>Request</samp> is a random, ephemeral ID chosen by the <em>Caller</em> and used to correlate the <em>Dealer's</em> response with the request.</li>
  <li><samp>Options</samp> is a dictionary that allows to provide additional call request details in an extensible way. This is described further below.</li>
  <li><samp>Procedure</samp> is the URI of the procedure to be called.</li>
  <li><samp>Arguments</samp> is a list of positional call arguments (each of arbitrary type). The list may be of zero length.</li>
  <li><samp>ArgumentsKw</samp> is a dictionary of keyword call arguments (each of arbitrary type). The dictionary may be empty.</li>
</ul>

<p> </p>
<p><em>Example</em> </p>
<pre>
    [48, 7814135, {}, "com.myapp.ping"]
</pre>
<p><em>Example</em> </p>
<pre>
    [48, 7814135, {}, "com.myapp.echo", ["Hello, world!"]]
</pre>
<p><em>Example</em> </p>
<pre>
    [48, 7814135, {}, "com.myapp.add2", [23, 7]]
</pre>
<p><em>Example</em> </p>
<pre>
    [48, 7814135, {}, "com.myapp.user.new", ["johnny"],
        {"firstname": "John", "surname": "Doe"}]
</pre>
<h1 id="rfc.section.9.2.2"><a href="#rfc.section.9.2.2">9.2.2.</a> <a href="#invocation-1" id="invocation-1">INVOCATION</a></h1>
<p id="rfc.section.9.2.2.p.1">If the <em>Dealer</em> is able to fulfill (mediate) the call and it allows the call, it sends a <samp>INVOCATION</samp> message to the respective <em>Callee</em> implementing the procedure: </p>
<pre>
    [INVOCATION, Request|id, REGISTERED.Registration|id,
        Details|dict]
</pre>
<p id="rfc.section.9.2.2.p.2">or </p>
<pre>
    [INVOCATION, Request|id, REGISTERED.Registration|id,
        Details|dict, CALL.Arguments|list]
</pre>
<p id="rfc.section.9.2.2.p.3">or </p>
<pre>
    [INVOCATION, Request|id, REGISTERED.Registration|id,
        Details|dict, CALL.Arguments|list, CALL.ArgumentsKw|dict]
</pre>
<p id="rfc.section.9.2.2.p.4">where </p>
<p/>

<ul>
  <li><samp>Request</samp> is a random, ephemeral ID chosen by the <em>Dealer</em> and used to correlate the <em>Callee's</em> response with the request.</li>
  <li><samp>REGISTERED.Registration</samp> is the registration ID under which the procedure was registered at the <em>Dealer</em>.</li>
  <li><samp>Details</samp> is a dictionary that allows to provide additional invocation request details in an extensible way. This is described further below.</li>
  <li><samp>CALL.Arguments</samp> is the original list of positional call arguments as provided by the <em>Caller</em>.</li>
  <li><samp>CALL.ArgumentsKw</samp> is the original dictionary of keyword call arguments as provided by the <em>Caller</em>.</li>
</ul>

<p> </p>
<p><em>Example</em> </p>
<pre>
    [68, 6131533, 9823526, {}]
</pre>
<p><em>Example</em> </p>
<pre>
    [68, 6131533, 9823527, {}, ["Hello, world!"]]
</pre>
<p><em>Example</em> </p>
<pre>
    [68, 6131533, 9823528, {}, [23, 7]]
</pre>
<p><em>Example</em> </p>
<pre>
    [68, 6131533, 9823529, {}, ["johnny"], {"firstname": "John",
        "surname": "Doe"}]
</pre>
<h1 id="rfc.section.9.2.3"><a href="#rfc.section.9.2.3">9.2.3.</a> <a href="#yield-1" id="yield-1">YIELD</a></h1>
<p id="rfc.section.9.2.3.p.1">If the <em>Callee</em> is able to successfully process and finish the execution of the call, it answers by sending a <samp>YIELD</samp> message to the <em>Dealer</em>: </p>
<pre>
    [YIELD, INVOCATION.Request|id, Options|dict]
</pre>
<p id="rfc.section.9.2.3.p.2">or </p>
<pre>
    [YIELD, INVOCATION.Request|id, Options|dict, Arguments|list]
</pre>
<p id="rfc.section.9.2.3.p.3">or </p>
<pre>
    [YIELD, INVOCATION.Request|id, Options|dict, Arguments|list,
        ArgumentsKw|dict]
</pre>
<p id="rfc.section.9.2.3.p.4">where </p>
<p/>

<ul>
  <li><samp>INVOCATION.Request</samp> is the ID from the original invocation request.</li>
  <li><samp>Options</samp>is a dictionary that allows to provide additional options.</li>
  <li><samp>Arguments</samp> is a list of positional result elements (each of arbitrary type). The list may be of zero length.</li>
  <li><samp>ArgumentsKw</samp> is a dictionary of keyword result elements (each of arbitrary type). The dictionary may be empty.</li>
</ul>

<p> </p>
<p><em>Example</em> </p>
<pre>
    [70, 6131533, {}]
</pre>
<p><em>Example</em> </p>
<pre>
    [70, 6131533, {}, ["Hello, world!"]]
</pre>
<p><em>Example</em> </p>
<pre>
    [70, 6131533, {}, [30]]
</pre>
<p><em>Example</em> </p>
<pre>
    [70, 6131533, {}, [], {"userid": 123, "karma": 10}]
</pre>
<h1 id="rfc.section.9.2.4"><a href="#rfc.section.9.2.4">9.2.4.</a> <a href="#result-1" id="result-1">RESULT</a></h1>
<p id="rfc.section.9.2.4.p.1">The <em>Dealer</em> will then send a <samp>RESULT</samp> message to the original <em>Caller</em>: </p>
<pre>
    [RESULT, CALL.Request|id, Details|dict]
</pre>
<p id="rfc.section.9.2.4.p.2">or </p>
<pre>
    [RESULT, CALL.Request|id, Details|dict, YIELD.Arguments|list]
</pre>
<p id="rfc.section.9.2.4.p.3">or </p>
<pre>
    [RESULT, CALL.Request|id, Details|dict, YIELD.Arguments|list,
        YIELD.ArgumentsKw|dict]
</pre>
<p id="rfc.section.9.2.4.p.4">where </p>
<p/>

<ul>
  <li><samp>CALL.Request</samp> is the ID from the original call request.</li>
  <li><samp>Details</samp> is a dictionary of additional details.</li>
  <li><samp>YIELD.Arguments</samp> is the original list of positional result elements as returned by the <em>Callee</em>.</li>
  <li><samp>YIELD.ArgumentsKw</samp> is the original dictionary of keyword result elements as returned by the <em>Callee</em>.</li>
</ul>

<p> </p>
<p><em>Example</em> </p>
<pre>
    [50, 7814135, {}]
</pre>
<p><em>Example</em> </p>
<pre>
    [50, 7814135, {}, ["Hello, world!"]]
</pre>
<p><em>Example</em> </p>
<pre>
    [50, 7814135, {}, [30]]
</pre>
<p><em>Example</em> </p>
<pre>
    [50, 7814135, {}, [], {"userid": 123, "karma": 10}]
</pre>
<h1 id="rfc.section.9.2.5"><a href="#rfc.section.9.2.5">9.2.5.</a> <a href="#invocation-error" id="invocation-error">Invocation ERROR</a></h1>
<p id="rfc.section.9.2.5.p.1">If the <em>Callee</em> is unable to process or finish the execution of the call, or the application code implementing the procedure raises an exception or otherwise runs into an error, the <em>Callee</em> sends an <samp>ERROR</samp> message to the <em>Dealer</em>: </p>
<pre>
    [ERROR, INVOCATION, INVOCATION.Request|id, Details|dict,
        Error|uri]
</pre>
<p id="rfc.section.9.2.5.p.2">or </p>
<pre>
    [ERROR, INVOCATION, INVOCATION.Request|id, Details|dict,
    Error|uri, Arguments|list]
</pre>
<p id="rfc.section.9.2.5.p.3">or </p>
<pre>
    [ERROR, INVOCATION, INVOCATION.Request|id, Details|dict,
        Error|uri, Arguments|list, ArgumentsKw|dict]
</pre>
<p id="rfc.section.9.2.5.p.4">where </p>
<p/>

<ul>
  <li><samp>INVOCATION.Request</samp> is the ID from the original <samp>INVOCATION</samp> request previously sent by the <em>Dealer</em> to the <em>Callee</em>.</li>
  <li><samp>Details</samp> is a dictionary with additional error details.</li>
  <li><samp>Error</samp> is an URI that identifies the error of why the request could not be fulfilled.</li>
  <li><samp>Arguments</samp> is a list containing arbitrary, application defined, positional error information. This will be forwarded by the <em>Dealer</em> to the <em>Caller</em> that initiated the call.</li>
  <li><samp>ArgumentsKw</samp> is a dictionary containing arbitrary, application defined, keyword-based error information. This will be forwarded by the <em>Dealer</em> to the <em>Caller</em> that initiated the call.</li>
</ul>

<p> </p>
<p><em>Example</em> </p>
<pre>
    [8, 68, 6131533, {}, "com.myapp.error.object_write_protected",
        ["Object is write protected."], {"severity": 3}]
</pre>
<h1 id="rfc.section.9.2.6"><a href="#rfc.section.9.2.6">9.2.6.</a> <a href="#call-error" id="call-error">Call ERROR</a></h1>
<p id="rfc.section.9.2.6.p.1">The <em>Dealer</em> will then send a <samp>ERROR</samp> message to the original <em>Caller</em>: </p>
<pre>
    [ERROR, CALL, CALL.Request|id, Details|dict, Error|uri]
</pre>
<p id="rfc.section.9.2.6.p.2">or </p>
<pre>
    [ERROR, CALL, CALL.Request|id, Details|dict, Error|uri,
        Arguments|list]
</pre>
<p id="rfc.section.9.2.6.p.3">or </p>
<pre>
    [ERROR, CALL, CALL.Request|id, Details|dict, Error|uri,
        Arguments|list, ArgumentsKw|dict]
</pre>
<p id="rfc.section.9.2.6.p.4">where </p>
<p/>

<ul>
  <li><samp>CALL.Request</samp> is the ID from the original <samp>CALL</samp> request sent by the <em>Caller</em> to the <em>Dealer</em>.</li>
  <li><samp>Details</samp> is a dictionary with additional error details.</li>
  <li><samp>Error</samp> is an URI identifying the type of error as returned by the <em>Callee</em> to the <em>Dealer</em>.</li>
  <li><samp>Arguments</samp> is a list containing the original error payload list as returned by the <em>Callee</em> to the <em>Dealer</em>.</li>
  <li><samp>ArgumentsKw</samp> is a dictionary containing the original error payload dictionary as returned by the <em>Callee</em> to the <em>Dealer</em></li>
</ul>

<p> </p>
<p><em>Example</em> </p>
<pre>
    [8, 48, 7814135, {}, "com.myapp.error.object_write_protected",
        ["Object is write protected."], {"severity": 3}]
</pre>
<p id="rfc.section.9.2.6.p.7">If the original call already failed at the <em>Dealer</em> <strong>before</strong> the call would have been forwarded to any <em>Callee</em>, the <em>Dealer</em> will send an <samp>ERROR</samp> message to the <em>Caller</em>: </p>
<pre>
    [ERROR, CALL, CALL.Request|id, Details|dict, Error|uri]
</pre>
<p><em>Example</em> </p>
<pre>
    [8, 48, 7814135, {}, "wamp.error.no_such_procedure"]
</pre>
<h1 id="rfc.section.10"><a href="#rfc.section.10">10.</a> <a href="#predefined-uris" id="predefined-uris">Predefined URIs</a></h1>
<p id="rfc.section.10.p.1">WAMP pre-defines the following error URIs for the basic and for the advanced profile. WAMP peers MUST use only the defined error messages.  </p>
<h1 id="rfc.section.10.1"><a href="#rfc.section.10.1">10.1.</a> <a href="#basic-profile" id="basic-profile">Basic Profile</a></h1>
<h1 id="rfc.section.10.1.1"><a href="#rfc.section.10.1.1">10.1.1.</a> <a href="#incorrect-uris" id="incorrect-uris">Incorrect URIs</a></h1>
<p id="rfc.section.10.1.1.p.1">When a <em>Peer</em> provides an incorrect URI for any URI-based attribute of a WAMP message (e.g. realm, topic), then the other <em>Peer</em> MUST respond with an <samp>ERROR</samp> message and give the following <em>Error URI</em>: </p>
<pre>
    wamp.error.invalid_uri
</pre>
<h1 id="rfc.section.10.1.2"><a href="#rfc.section.10.1.2">10.1.2.</a> <a href="#interaction" id="interaction">Interaction</a></h1>
<p><em>Peer</em> provided an incorrect URI for any URI-based attribute of WAMP message, such as realm, topic or procedure </p>
<pre>
    wamp.error.invalid_uri
</pre>
<p id="rfc.section.10.1.2.p.2">A <em>Dealer</em> could not perform a call, since no procedure is currently registered under the given URI.  </p>
<pre>
    wamp.error.no_such_procedure
</pre>
<p id="rfc.section.10.1.2.p.3">A procedure could not be registered, since a procedure with the given URI is already registered.  </p>
<pre>
    wamp.error.procedure_already_exists
</pre>
<p id="rfc.section.10.1.2.p.4">A <em>Dealer</em> could not perform an unregister, since the given registration is not active.  </p>
<pre>
    wamp.error.no_such_registration
</pre>
<p id="rfc.section.10.1.2.p.5">A <em>Broker</em> could not perform an unsubscribe, since the given subscription is not active.  </p>
<pre>
    wamp.error.no_such_subscription
</pre>
<p id="rfc.section.10.1.2.p.6">A call failed since the given argument types or values are not acceptable to the called procedure. In this case the <em>Callee</em> may throw this error. Alternatively a <em>Router</em> may throw this error if it performed <em>payload validation</em> of a call, call result, call error or publish, and the payload did not conform to the requirements.  </p>
<pre>
    wamp.error.invalid_argument
</pre>
<h1 id="rfc.section.10.1.3"><a href="#rfc.section.10.1.3">10.1.3.</a> <a href="#session-close" id="session-close">Session Close</a></h1>
<p id="rfc.section.10.1.3.p.1">The <em>Peer</em> is shutting down completely - used as a <samp>GOODBYE</samp> (or <samp>ABORT</samp>) reason.  </p>
<pre>
    wamp.error.system_shutdown
</pre>
<p id="rfc.section.10.1.3.p.2">The <em>Peer</em> want to leave the realm - used as a <samp>GOODBYE</samp> reason.  </p>
<pre>
    wamp.error.close_realm
</pre>
<p id="rfc.section.10.1.3.p.3">A <em>Peer</em> acknowledges ending of a session - used as a <samp>GOODBYE</samp> reply reason.  </p>
<pre>
    wamp.error.goodbye_and_out
</pre>
<h1 id="rfc.section.10.1.4"><a href="#rfc.section.10.1.4">10.1.4.</a> <a href="#authorization" id="authorization">Authorization</a></h1>
<p id="rfc.section.10.1.4.p.1">A join, call, register, publish or subscribe failed, since the <em>Peer</em> is not authorized to perform the operation.  </p>
<pre>
    wamp.error.not_authorized
</pre>
<p id="rfc.section.10.1.4.p.2">A <em>Dealer</em> or <em>Broker</em> could not determine if the <em>Peer</em> is authorized to perform a join, call, register, publish or subscribe, since the authorization operation <em>itself</em> failed. E.g. a custom authorizer did run into an error.  </p>
<pre>
    wamp.error.authorization_failed
</pre>
<p><em>Peer</em> wanted to join a non-existing realm (and the <em>Router</em> did not allow to auto-create the realm).  </p>
<pre>
    wamp.error.no_such_realm
</pre>
<p id="rfc.section.10.1.4.p.4">A <em>Peer</em> was to be authenticated under a Role that does not (or no longer) exists on the Router. For example, the <em>Peer</em> was successfully authenticated, but the Role configured does not exists - hence there is some misconfiguration in the Router.  </p>
<pre>
    wamp.error.no_such_role
</pre>
<h1 id="rfc.section.10.2"><a href="#rfc.section.10.2">10.2.</a> <a href="#advanced-profile" id="advanced-profile">Advanced Profile</a></h1>
<p id="rfc.section.10.2.p.1">uri<em>Dealer</em> or&#160;<em>Callee</em> canceled a call previously issued </p>
<pre>
    wamp.error.canceled
</pre>
<p id="rfc.section.10.2.p.2">A <em>Peer</em> requested an interaction with an option that was disallowed by the <em>Router</em> </p>
<pre>
    wamp.error.option_not_allowed
</pre>
<p id="rfc.section.10.2.p.3">A <em>Dealer</em> could not perform a call, since a procedure with the given URI is registered, but <em>Callee Black- and Whitelisting</em> and/or <em>Caller Exclusion</em> lead to the exclusion of (any) <em>Callee</em> providing the procedure.  </p>
<pre>
    wamp.error.no_eligible_callee
</pre>
<p id="rfc.section.10.2.p.4">A <em>Router</em> rejected client request to disclose its identity </p>
<pre>
    wamp.error.option_disallowed.disclose_me
</pre>
<p id="rfc.section.10.2.p.5">A <em>Router</em> encountered a network failure </p>
<pre>
    wamp.error.network_failure
</pre>
<h1 id="rfc.section.11"><a href="#rfc.section.11">11.</a> <a href="#ordering-guarantees" id="ordering-guarantees">Ordering Guarantees</a></h1>
<p id="rfc.section.11.p.1">All WAMP implementations, in particular <em>Routers</em> MUST support the following ordering guarantees.  </p>
<p/>

<ul class="empty">
  <li>A WAMP Advanced Profile may provide applications options to relax ordering guarantees, in particular with distributed calls.  </li>
</ul>
<h1 id="rfc.section.11.1"><a href="#rfc.section.11.1">11.1.</a> <a href="#publish--subscribe-ordering" id="publish--subscribe-ordering">Publish &amp; Subscribe Ordering</a></h1>
<p id="rfc.section.11.1.p.1">Regarding <strong>Publish &amp; Subscribe</strong>, the ordering guarantees are as follows: </p>
<p id="rfc.section.11.1.p.2">If <em>Subscriber A</em> is subscribed to both <strong>Topic 1</strong> and <strong>Topic 2</strong>, and <em>Publisher B</em> first publishes an <strong>Event 1</strong> to <strong>Topic 1</strong> and then an <strong>Event 2</strong> to <strong>Topic 2</strong>, then <em>Subscriber A</em> will first receive <strong>Event 1</strong> and then <strong>Event 2</strong>. This also holds if <strong>Topic 1</strong> and <strong>Topic 2</strong> are identical.  </p>
<p id="rfc.section.11.1.p.3">In other words, WAMP guarantees ordering of events between any given <em>pair</em> of <em>Publisher</em> and <em>Subscriber</em>.  </p>
<p id="rfc.section.11.1.p.4">Further, if <em>Subscriber A</em> subscribes to <strong>Topic 1</strong>, the <samp>SUBSCRIBED</samp> message will be sent by the <em>Broker</em> to <em>Subscriber A</em> before any <samp>EVENT</samp> message for <strong>Topic 1</strong>.  </p>
<p id="rfc.section.11.1.p.5">There is no guarantee regarding the order of return for multiple subsequent subscribe requests. A subscribe request might require the <em>Broker</em> to do a time-consuming lookup in some database, whereas another subscribe request second might be permissible immediately.  </p>
<h1 id="rfc.section.11.2"><a href="#rfc.section.11.2">11.2.</a> <a href="#remote-procedure-call-ordering" id="remote-procedure-call-ordering">Remote Procedure Call Ordering</a></h1>
<p id="rfc.section.11.2.p.1">Regarding <strong>Remote Procedure Calls</strong>, the ordering guarantees are as follows: </p>
<p id="rfc.section.11.2.p.2">If <em>Callee A</em> has registered endpoints for both <strong>Procedure 1</strong> and <strong>Procedure 2</strong>, and <em>Caller B</em> first issues a <strong>Call 1</strong> to <strong>Procedure 1</strong> and then a <strong>Call 2</strong> to <strong>Procedure 2</strong>, and both calls are routed to <em>Callee A</em>, then <em>Callee A</em> will first receive an invocation corresponding to <strong>Call 1</strong> and then <strong>Call 2</strong>. This also holds if <strong>Procedure 1</strong> and <strong>Procedure 2</strong> are identical.  </p>
<p id="rfc.section.11.2.p.3">In other words, WAMP guarantees ordering of invocations between any given <em>pair</em> of <em>Caller</em> and <em>Callee</em>.  </p>
<p id="rfc.section.11.2.p.4">There are no guarantees on the order of call results and errors in relation to <em>different</em> calls, since the execution of calls upon different invocations of endpoints in <em>Callees</em> are running independently. A first call might require an expensive, long-running computation, whereas a second, subsequent call might finish immediately.  </p>
<p id="rfc.section.11.2.p.5">Further, if <em>Callee A</em> registers for <strong>Procedure 1</strong>, the <samp>REGISTERED</samp> message will be sent by <em>Dealer</em> to <em>Callee A</em> before any <samp>INVOCATION</samp> message for <strong>Procedure 1</strong>.  </p>
<p id="rfc.section.11.2.p.6">There is no guarantee regarding the order of return for multiple subsequent register requests. A register request might require the <em>Broker</em> to do a time-consuming lookup in some database, whereas another register request second might be permissible immediately.  </p>
<h1 id="rfc.section.12"><a href="#rfc.section.12">12.</a> <a href="#security-model" id="security-model">Security Model</a></h1>
<p id="rfc.section.12.p.1">The following discusses the security model for the Basic Profile. Any changes or extensions to this for the Advanced Profile are discussed further on as part of the Advanced Profile definition.  </p>
<h1 id="rfc.section.12.1"><a href="#rfc.section.12.1">12.1.</a> <a href="#transport-encryption-and-integrity" id="transport-encryption-and-integrity">Transport Encryption and Integrity</a></h1>
<p id="rfc.section.12.1.p.1">WAMP transports may provide (optional) transport-level encryption and integrity verification. If so, encryption and integrity is point-to-point: between a <em>Client</em> and the <em>Router</em> it is connected to.  </p>
<p id="rfc.section.12.1.p.2">Transport-level encryption and integrity is solely at the transport-level and transparent to WAMP. WAMP itself deliberately does not specify any kind of transport-level encryption.  </p>
<p id="rfc.section.12.1.p.3">Implementations that offer TCP based transport such as WAMP-over-WebSocket or WAMP-over-RawSocket SHOULD implement Transport Layer Security (TLS).  </p>
<p id="rfc.section.12.1.p.4">WAMP deployments are encouraged to stick to a TLS-only policy with the TLS code and setup being hardened.  </p>
<p id="rfc.section.12.1.p.5">Further, when a <em>Client</em> connects to a <em>Router</em> over a local-only transport such as Unix domain sockets, the integrity of the data transmitted is implicit (the OS kernel is trusted), and the privacy of the data transmitted can be assured using file system permissions (no one can tap a Unix domain socket without appropriate permissions or being root).  </p>
<h1 id="rfc.section.12.2"><a href="#rfc.section.12.2">12.2.</a> <a href="#router-authentication" id="router-authentication">Router Authentication</a></h1>
<p id="rfc.section.12.2.p.1">To authenticate <em>Routers</em> to <em>Clients</em>, deployments MUST run TLS and <em>Clients</em> MUST verify the <em>Router</em> server certificate presented. WAMP itself does not provide mechanisms to authenticate a <em>Router</em> (only a <em>Client</em>).  </p>
<p id="rfc.section.12.2.p.2">The verification of the <em>Router</em> server certificate can happen </p>
<p/>

<ol>
  <li>against a certificate trust database that comes with the <em>Clients</em> operating system</li>
  <li>against an issuing certificate/key hard-wired into the <em>Client</em></li>
  <li>by using new mechanisms like DNS-based Authentication of Named Enitities (DNSSEC)/TLSA</li>
</ol>

<p> </p>
<p id="rfc.section.12.2.p.4">Further, when a <em>Client</em> connects to a <em>Router</em> over a local-only transport such as Unix domain sockets, the file system permissions can be used to create implicit trust. E.g. if only the OS user under which the <em>Router</em> runs has the permission to create a Unix domain socket under a specific path, <em>Clients</em> connecting to that path can trust in the router authenticity.  </p>
<h1 id="rfc.section.12.3"><a href="#rfc.section.12.3">12.3.</a> <a href="#client-authentication" id="client-authentication">Client Authentication</a></h1>
<p id="rfc.section.12.3.p.1">Authentication of a <em>Client</em> to a <em>Router</em> at the WAMP level is not part of the basic profile.  </p>
<p id="rfc.section.12.3.p.2">When running over TLS, a <em>Router</em> MAY authenticate a <em>Client</em> at the transport level by doing a <em>client certificate based authentication</em>.  </p>
<h1 id="rfc.section.12.3.1"><a href="#rfc.section.12.3.1">12.3.1.</a> <a href="#routers-are-trusted" id="routers-are-trusted">Routers are trusted</a></h1>
<p><em>Routers</em> are <em>trusted</em> by <em>Clients</em>.  </p>
<p id="rfc.section.12.3.1.p.2">In particular, <em>Routers</em> can read (and modify) any application payload transmitted in events, calls, call results and call errors (the <samp>Arguments</samp> or <samp>ArgumentsKw</samp> message fields).  </p>
<p id="rfc.section.12.3.1.p.3">Hence, <em>Routers</em> do not provide confidentiality with respect to application payload, and also do not provide authenticity or integrity of application payloads that could be verified by a receiving <em>Client</em>.  </p>
<p><em>Routers</em> need to read the application payloads in cases of automatic conversion between different serialization formats.  </p>
<p id="rfc.section.12.3.1.p.5">Further, <em>Routers</em> are trusted to <strong>actually perform</strong> routing as specified. E.g. a <em>Client</em> that publishes an event has to trust a <em>Router</em> that the event is actually dispatched to all (eligible) <em>Subscribers</em> by the <em>Router</em>.  </p>
<p id="rfc.section.12.3.1.p.6">A rogue <em>Router</em> might deny normal routing operation without a <em>Client</em> taking notice.  </p>
<h1 id="rfc.section.13"><a href="#rfc.section.13">13.</a> <a href="#advanced-profile-1" id="advanced-profile-1">Advanced Profile</a></h1>
<p id="rfc.section.13.p.1">While implementations MUST implement the subset of the Basic Profile necessary for the particular set of WAMP roles they provide, they MAY implement any subset of features from the Advanced Profile. Implementers SHOULD implement the maximum of features possible considering the aims of an implementation.  </p>
<p/>

<ul class="empty">
  <li>Note: Features listed here may be experimental or underspecced and yet unimplemented in any implementation. This is part of the specification is very much a work in progress. An approximate status of each feature is given at the beginning of the feature section.  </li>
</ul>
<h1 id="rfc.section.13.1"><a href="#rfc.section.13.1">13.1.</a> <a href="#messages-1" id="messages-1">Messages</a></h1>
<p id="rfc.section.13.1.p.1">The Advanced Profile defines the following additional messages which are explained in detail in separate sections.  </p>
<h1 id="rfc.section.13.1.1"><a href="#rfc.section.13.1.1">13.1.1.</a> <a href="#message-definitions-1" id="message-definitions-1">Message Definitions</a></h1>
<p id="rfc.section.13.1.1.p.1">The following 4 additional message types MAY be used in the Advanced Profile.  </p>
<h1 id="rfc.section.13.1.1.1"><a href="#rfc.section.13.1.1.1">13.1.1.1.</a> <a href="#challenge" id="challenge">CHALLENGE</a></h1>
<p id="rfc.section.13.1.1.1.p.1">The <samp>CHALLENGE</samp> message is used with certain Authentication Methods. During authenticated session establishment, a <strong>Router</strong> sends a challenge message.  </p>
<pre>
[CHALLENGE, AuthMethod|string, Extra|dict]
</pre>
<h1 id="rfc.section.13.1.1.2"><a href="#rfc.section.13.1.1.2">13.1.1.2.</a> <a href="#authenticate" id="authenticate">AUTHENTICATE</a></h1>
<p id="rfc.section.13.1.1.2.p.1">The <samp>AUTHENTICATE</samp> message is used with certain Authentication Methods. A <strong>Client</strong> having received a challenge is expected to respond by sending a signature or token.  </p>
<pre>
[AUTHENTICATE, Signature|string, Extra|dict]
</pre>
<h1 id="rfc.section.13.1.1.3"><a href="#rfc.section.13.1.1.3">13.1.1.3.</a> <a href="#cancel" id="cancel">CANCEL</a></h1>
<p id="rfc.section.13.1.1.3.p.1">The <samp>CANCEL</samp> message is used with the Call Canceling advanced feature. A <em>Caller</em> can cancel and issued call actively by sending a cancel message to the <em>Dealer</em>.  </p>
<pre>
[CANCEL, CALL.Request|id, Options|dict]
</pre>
<h1 id="rfc.section.13.1.1.4"><a href="#rfc.section.13.1.1.4">13.1.1.4.</a> <a href="#interrupt" id="interrupt">INTERRUPT</a></h1>
<p id="rfc.section.13.1.1.4.p.1">The <samp>INTERRUPT</samp> message is used with the Call Canceling advanced feature. Upon receiving a cancel for a pending call, a <em>Dealer</em> will issue an interrupt to the <em>Callee</em>.  </p>
<pre>
[INTERRUPT, INVOCATION.Request|id, Options|dict]
</pre>
<h1 id="rfc.section.13.1.2"><a href="#rfc.section.13.1.2">13.1.2.</a> <a href="#message-codes-and-direction-1" id="message-codes-and-direction-1">Message Codes and Direction</a></h1>
<p id="rfc.section.13.1.2.p.1">The following table list the message type code for <strong>the OPTIONAL messages</strong> defined in this part of the document and their direction between peer roles.  </p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="center">Cod</th>
      <th class="center">Message</th>
      <th class="center">Pub</th>
      <th class="center">Brk</th>
      <th class="center">Subs</th>
      <th class="center">Calr</th>
      <th class="center">Dealr</th>
      <th class="center">Callee</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="center">4</td>
      <td class="center">
        <samp>CHALLENGE</samp>
      </td>
      <td class="center">Rx</td>
      <td class="center">Tx</td>
      <td class="center">Rx</td>
      <td class="center">Rx</td>
      <td class="center">Tx</td>
      <td class="center">Rx</td>
    </tr>
    <tr>
      <td class="center">5</td>
      <td class="center">
        <samp>AUTHENTICATE</samp>
      </td>
      <td class="center">Tx</td>
      <td class="center">Rx</td>
      <td class="center">Tx</td>
      <td class="center">Tx</td>
      <td class="center">Rx</td>
      <td class="center">Tx</td>
    </tr>
    <tr>
      <td class="center">49</td>
      <td class="center">
        <samp>CANCEL</samp>
      </td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center">Tx</td>
      <td class="center">Rx</td>
      <td class="center"/>
    </tr>
    <tr>
      <td class="center">69</td>
      <td class="center">
        <samp>INTERRUPT</samp>
      </td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center">Tx</td>
      <td class="center">Rx</td>
    </tr>
  </tbody>
</table>
<p/>

<ul class="empty">
  <li>"Tx" ("Rx") means the message is sent (received) by a peer of the respective role.  </li>
</ul>
<h1 id="rfc.section.13.2"><a href="#rfc.section.13.2">13.2.</a> <a href="#features" id="features">Features</a></h1>
<p id="rfc.section.13.2.p.1">Support for advanced features must be announced by the peers which implement them. The following is a complete list of advanced features currently defined or proposed.  </p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="center">Status</th>
      <th class="center">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="center">sketch</td>
      <td class="center">There is a rough description of an itch to scratch, but the feature use case isn't clear, and there is no protocol proposal at all.</td>
    </tr>
    <tr>
      <td class="center">alpha</td>
      <td class="center">The feature use case is still fuzzy and/or the feature definition is unclear, but there is at least a protocol level proposal.</td>
    </tr>
    <tr>
      <td class="center">beta</td>
      <td class="center">The feature use case is clearly defined and the feature definition in the spec is sufficient to write a prototype implementation. The feature definition and details may still be incomplete and change.</td>
    </tr>
    <tr>
      <td class="center">stable</td>
      <td class="center">The feature definition in the spec is complete and stable and the feature use case is field proven in real applications. There are multiple, interoperatble implementations.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.section.13.2.1"><a href="#rfc.section.13.2.1">13.2.1.</a> <a href="#rpc-features" id="rpc-features">RPC Features</a></h1>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="center">Feature</th>
      <th class="center">Status</th>
      <th class="center">P</th>
      <th class="center">B</th>
      <th class="center">S</th>
      <th class="center">Cr</th>
      <th class="center">D</th>
      <th class="center">Ce</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="center">progressive_call_results</td>
      <td class="center">beta</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center">X</td>
      <td class="center">X</td>
      <td class="center">X</td>
    </tr>
    <tr>
      <td class="center">progressive_calls</td>
      <td class="center">sketch</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center">X</td>
      <td class="center">X</td>
      <td class="center">X</td>
    </tr>
    <tr>
      <td class="center">call_timeout</td>
      <td class="center">alpha</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center">X</td>
      <td class="center">X</td>
      <td class="center">X</td>
    </tr>
    <tr>
      <td class="center">call_canceling</td>
      <td class="center">alpha</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center">X</td>
      <td class="center">X</td>
      <td class="center">X</td>
    </tr>
    <tr>
      <td class="center">caller_identification</td>
      <td class="center">alpha</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center">X</td>
      <td class="center">X</td>
      <td class="center">X</td>
    </tr>
    <tr>
      <td class="center">call_trustlevels</td>
      <td class="center">alpha</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center">X</td>
      <td class="center">X</td>
    </tr>
    <tr>
      <td class="center">registration_meta_api</td>
      <td class="center">beta</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center">X</td>
      <td class="center"/>
    </tr>
    <tr>
      <td class="center">pattern_based_registration</td>
      <td class="center">beta</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center">X</td>
      <td class="center">X</td>
    </tr>
    <tr>
      <td class="center">shared_registration</td>
      <td class="center">beta</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center">X</td>
      <td class="center">X</td>
    </tr>
    <tr>
      <td class="center">sharded_registration</td>
      <td class="center">alpha</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center">X</td>
      <td class="center">X</td>
    </tr>
    <tr>
      <td class="center">registration_revocation</td>
      <td class="center">alpha</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center">X</td>
      <td class="center">X</td>
    </tr>
    <tr>
      <td class="center">procedure_reflection</td>
      <td class="center">sketch</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center">X</td>
      <td class="center"/>
    </tr>
  </tbody>
</table>
<h1 id="rfc.section.13.2.2"><a href="#rfc.section.13.2.2">13.2.2.</a> <a href="#pubsub-features" id="pubsub-features">PubSub Features</a></h1>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="center">Feature</th>
      <th class="center">Status</th>
      <th class="center">P</th>
      <th class="center">B</th>
      <th class="center">S</th>
      <th class="center">Cr</th>
      <th class="center">D</th>
      <th class="center">Ce</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="center">subscriber_blackwhite_listing</td>
      <td class="center">stable</td>
      <td class="center">X</td>
      <td class="center">X</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
    </tr>
    <tr>
      <td class="center">publisher_exclusion</td>
      <td class="center">stable</td>
      <td class="center">X</td>
      <td class="center">X</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
    </tr>
    <tr>
      <td class="center">publisher_identification</td>
      <td class="center">alpha</td>
      <td class="center">X</td>
      <td class="center">X</td>
      <td class="center">X</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
    </tr>
    <tr>
      <td class="center">publication_trustlevels</td>
      <td class="center">alpha</td>
      <td class="center"/>
      <td class="center">X</td>
      <td class="center">X</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
    </tr>
    <tr>
      <td class="center">session_meta_api</td>
      <td class="center">beta</td>
      <td class="center"/>
      <td class="center">X</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
    </tr>
    <tr>
      <td class="center">subscription_meta_api</td>
      <td class="center">beta</td>
      <td class="center"/>
      <td class="center">X</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
    </tr>
    <tr>
      <td class="center">pattern_based_subscription</td>
      <td class="center">beta</td>
      <td class="center"/>
      <td class="center">X</td>
      <td class="center">X</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
    </tr>
    <tr>
      <td class="center">sharded_subscription</td>
      <td class="center">alpha</td>
      <td class="center"/>
      <td class="center">X</td>
      <td class="center">X</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
    </tr>
    <tr>
      <td class="center">event_history</td>
      <td class="center">alpha</td>
      <td class="center"/>
      <td class="center">X</td>
      <td class="center">X</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
    </tr>
    <tr>
      <td class="center">topic_reflection</td>
      <td class="center">sketch</td>
      <td class="center"/>
      <td class="center">X</td>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
      <td class="center"/>
    </tr>
  </tbody>
</table>
<h1 id="rfc.section.13.2.3"><a href="#rfc.section.13.2.3">13.2.3.</a> <a href="#other-advanced-features" id="other-advanced-features">Other Advanced Features</a></h1>
<p/>

<ul>
  <li>authentication <ul><li>WAMP CRA</li><li>cookie (entirely missing)</li><li>OTP --&gt; ticket?</li></ul></li>
  <li>transports <ul><li>batched WS transport</li><li>longpoll transport</li><li>rawsocket transport</li><li>multiplexed transport</li></ul></li>
  <li>pre-defined URIs</li>
  <li>reflection</li>
  <li>session meta-api</li>
</ul>

<p> </p>
<p id="rfc.section.13.2.3.p.2">? </p>
<p/>

<ul>
  <li>partitioned registration</li>
  <li>partitioned subscription</li>
</ul>

<p> </p>
<h1 id="rfc.section.13.3"><a href="#rfc.section.13.3">13.3.</a> <a href="#advanced-rpc-features" id="advanced-rpc-features">Advanced RPC Features</a></h1>
<h1 id="rfc.section.13.3.1"><a href="#rfc.section.13.3.1">13.3.1.</a> <a href="#progressive-call-results" id="progressive-call-results">Progressive Call Results</a></h1>
<h1 id="rfc.section.13.3.1.1"><a href="#rfc.section.13.3.1.1">13.3.1.1.</a> <a href="#feature-definition" id="feature-definition">Feature Definition</a></h1>
<p id="rfc.section.13.3.1.1.p.1">A procedure implemented by a <em>Callee</em> and registered at a <em>Dealer</em> may produce progressive results. Progressive results can e.g. be used to return partial results for long-running operations, or to chunk the transmission of larger results sets.  </p>
<p id="rfc.section.13.3.1.1.p.2">The message flow for progressive results involves: </p>
<pre>
 ,------.           ,------.          ,------.
 |Caller|           |Dealer|          |Callee|
 `--+---'           `--+---'          `--+---'
    |       CALL       |                 |
    | -----------------&gt;                 |
    |                  |                 |
    |                  |    INVOCATION   |
    |                  | ----------------&gt;
    |                  |                 |
    |                  | YIELD (progress)|
    |                  | &lt;----------------
    |                  |                 |
    | RESULT (progress)|                 |
    | &lt;-----------------                 |
    |                  |                 |
    |                  | YIELD (progress)|
    |                  | &lt;----------------
    |                  |                 |
    | RESULT (progress)|                 |
    | &lt;-----------------                 |
    |                  |                 |
    |                  |                 |
    |       ...        |       ...       |
    |                  |                 |
    |                  |  YIELD or ERROR |
    |                  | &lt;----------------
    |                  |                 |
    |  RESULT or ERROR |                 |
    | &lt;-----------------                 |
 ,--+---.           ,--+---.          ,--+---.
 |Caller|           |Dealer|          |Callee|
 `------'           `------'          `------'
</pre>
<p id="rfc.section.13.3.1.1.p.3">A <em>Caller</em> indicates its willingness to receive progressive results by setting </p>
<pre>
    CALL.Options.receive_progress|bool := true
</pre>
<p><em>Example.</em> Caller-to-Dealer <samp>CALL</samp> </p>
<pre>
    [
        48,
        77133,
        {
            "receive_progress": true
        },
        "com.myapp.compute_revenue",
        [2010, 2011, 2012]
    ]
</pre>
<p id="rfc.section.13.3.1.1.p.5">If the <em>Callee</em> supports progressive calls, the <em>Dealer</em> will forward the <em>Caller's</em> willingness to receive progressive results by setting </p>
<pre>
    INVOCATION.Options.receive_progress|bool := true
</pre>
<p><em>Example.</em> Dealer-to-Callee <samp>INVOCATION</samp> </p>
<pre>
    [
        68,
        87683,
        324,
        {
            "receive_progress": true
        },
        [2010, 2011, 2012]
    ]
</pre>
<p id="rfc.section.13.3.1.1.p.7">An endpoint implementing the procedure produces progressive results by sending <samp>YIELD</samp> messages to the <em>Dealer</em> with </p>
<pre>
    YIELD.Options.progress|bool := true
</pre>
<p><em>Example.</em> Callee-to-Dealer progressive <samp>YIELDs</samp> </p>
<pre>
    [
        70,
        87683,
        {
            "progress": true
        },
        ["Y2010", 120]
    ]
</pre>
<pre>
    [
        70,
        87683,
        {
            "progress": true
        },
        ["Y2011", 205]
    ]
</pre>
<p id="rfc.section.13.3.1.1.p.9">Upon receiving an <samp>YIELD</samp> message from a <em>Callee</em> with <samp>YIELD.Options.progress == true</samp> (for a call that is still ongoing), the <em>Dealer</em> will <strong>immediately</strong> send a <samp>RESULT</samp> message to the original <em>Caller</em> with </p>
<pre>
    RESULT.Details.progress|bool := true
</pre>
<p><em>Example.</em> Dealer-to-Caller progressive <samp>RESULTs</samp> </p>
<pre>
    [
        50,
        77133,
        {
            "progress": true
        },
        ["Y2010", 120]
    ]
</pre>
<pre>
    [
        50,
        77133,
        {
            "progress": true
        },
        ["Y2011", 205]
    ]
</pre>
<p id="rfc.section.13.3.1.1.p.11">...  </p>
<p id="rfc.section.13.3.1.1.p.12">An invocation MUST <em>always</em> end in either a <em>normal</em> <samp>RESULT</samp> or <samp>ERROR</samp> message being sent by the <em>Callee</em> and received by the <em>Dealer</em>.  </p>
<p><em>Example.</em> Callee-to-Dealer final <samp>YIELD</samp> </p>
<pre>
    [
        70,
        87683,
        {},
        ["Total", 490]
    ]
</pre>
<p><em>Example.</em> Callee-to-Dealer final <samp>ERROR</samp> </p>
<pre>
    [
        4,
        87683,
        {},
        "com.myapp.invalid_revenue_year",
        [1830]
    ]
</pre>
<p id="rfc.section.13.3.1.1.p.15">A call MUST <em>always</em> end in either a <em>normal</em> <samp>RESULT</samp> or <samp>ERROR</samp> message being sent by the <em>Dealer</em> and received by the <em>Caller</em>.  </p>
<p><em>Example.</em> Dealer-to-Caller final <samp>RESULT</samp> </p>
<pre>
    [
        50,
        77133,
        {},
        ["Total", 490]
    ]
</pre>
<p><em>Example.</em> Dealer-to-Caller final <samp>ERROR</samp> </p>
<pre>
    [
        4,
        77133,
        {},
        "com.myapp.invalid_revenue_year",
        [1830]
    ]
</pre>
<p id="rfc.section.13.3.1.1.p.18">In other words: <samp>YIELD</samp> with <samp>YIELD.Options.progress == true</samp> and <samp>RESULT</samp> with <samp>RESULT.Details.progress == true</samp> messages may only be sent <em>during</em> a call or invocation is still ongoing.  </p>
<p id="rfc.section.13.3.1.1.p.19">The final <samp>YIELD</samp> and final <samp>RESULT</samp> may also be empty, e.g. when all actual results have already been transmitted in progressive result messages.  </p>
<p><em>Example.</em> Callee-to-Dealer <samp>YIELDs</samp> </p>
<pre>
    [70, 87683, {"progress": true}, ["Y2010", 120]]
    [70, 87683, {"progress": true}, ["Y2011", 205]]
     ...
    [70, 87683, {"progress": true}, ["Total", 490]]
    [70, 87683, {}]
</pre>
<p><em>Example.</em> Dealer-to-Caller <samp>RESULTs</samp> </p>
<pre>
    [50, 77133, {"progress": true}, ["Y2010", 120]]
    [50, 77133, {"progress": true}, ["Y2011", 205]]
     ...
    [50, 77133, {"progress": true}, ["Total", 490]]
    [50, 77133, {}]
</pre>
<p id="rfc.section.13.3.1.1.p.22">The progressive <samp>YIELD</samp> and progressive <samp>RESULT</samp> may also be empty, e.g. when those messages are only used to signal that the procedure is still running and working, and the actual result is completely delivered in the final <samp>YIELD</samp> and <samp>RESULT</samp>: </p>
<p><em>Example.</em> Callee-to-Dealer <samp>YIELDs</samp> </p>
<pre>
    [70, 87683, {"progress": true}]
    [70, 87683, {"progress": true}]
    ...
    [70, 87683, {}, [["Y2010", 120], ["Y2011", 205], ...,
        ["Total", 490]]]
</pre>
<p><em>Example.</em> Dealer-to-Caller <samp>RESULTs</samp> </p>
<pre>
    [50, 77133, {"progress": true}]
    [50, 77133, {"progress": true}]
    ...
    [50, 77133, {}, [["Y2010", 120], ["Y2011", 205], ...,
        ["Total", 490]]]
</pre>
<p/>

<ul class="empty">
  <li>Note that intermediate, progressive results and/or the final result MAY have different structure. The WAMP peer implementation is responsible for mapping everything into a form suitable for consumption in the host language.  </li>
</ul>
<p><em>Example.</em> Callee-to-Dealer <samp>YIELDs</samp> </p>
<pre>
    [70, 87683, {"progress": true}, ["partial 1", 10]]
    [70, 87683, {"progress": true}, [], {"foo": 10,
        "bar": "partial 1"}]
     ...
    [70, 87683, {}, [1, 2, 3], {"moo": "hello"}]
</pre>
<p><em>Example.</em> Dealer-to-Caller <samp>RESULTs</samp> </p>
<pre>
    [50, 77133, {"progress": true}, ["partial 1", 10]]
    [50, 77133, {"progress": true}, [], {"foo": 10,
        "bar": "partial 1"}]
     ...
    [50, 77133, {}, [1, 2, 3], {"moo": "hello"}]
</pre>
<p id="rfc.section.13.3.1.1.p.28">Even if a <em>Caller</em> has indicated it's expectation to receive progressive results by setting <samp>CALL.Options.receive_progress|bool := true</samp>, a <em>Callee</em> is <strong>not required</strong> to produce progressive results. <samp>CALL.Options.receive_progress</samp> and <samp>INVOCATION.Options.receive_progress</samp> are simply indications that the <em>Caller</em> is prepared to process progressive results, should there be any produced. In other words, <em>Callees</em> are free to ignore such <samp>receive_progress</samp> hints at any time.  </p>
<h1 id="rfc.section.13.3.1.2"><a href="#rfc.section.13.3.1.2">13.3.1.2.</a> <a href="#feature-announcement" id="feature-announcement">Feature Announcement</a></h1>
<p id="rfc.section.13.3.1.2.p.1">Support for this advanced feature MUST be announced by <em>Callers</em> (<samp>role := "caller"</samp>), <em>Callees</em> (<samp>role := "callee"</samp>) and <em>Dealers</em> (<samp>role := "dealer"</samp>) via </p>
<pre>
    HELLO.Details.roles.&lt;role&gt;.features.
         progressive_call_results|bool := true
</pre>
<h1 id="rfc.section.13.3.2"><a href="#rfc.section.13.3.2">13.3.2.</a> <a href="#progressive-calls" id="progressive-calls">Progressive Calls</a></h1>
<h1 id="rfc.section.13.3.2.1"><a href="#rfc.section.13.3.2.1">13.3.2.1.</a> <a href="#feature-definition-1" id="feature-definition-1">Feature Definition</a></h1>
<p id="rfc.section.13.3.2.1.p.1">A procedure implemented by a <em>Callee</em> and registered at a <em>Dealer</em> may receive a progressive call. Progressive results can e.g. be used to start processing initial data where a larger data set may not yet have been generated or received by the <em>Caller</em>.  </p>
<p id="rfc.section.13.3.2.1.p.2">See this GitHub issue for more discussion: <span>&lt;</span><a href="https://github.com/wamp-proto/wamp-proto/issues/167">https://github.com/wamp-proto/wamp-proto/issues/167</a><span>&gt;</span> </p>
<h1 id="rfc.section.13.3.3"><a href="#rfc.section.13.3.3">13.3.3.</a> <a href="#call-timeouts" id="call-timeouts">Call Timeouts</a></h1>
<h1 id="rfc.section.13.3.3.1"><a href="#rfc.section.13.3.3.1">13.3.3.1.</a> <a href="#feature-definition-2" id="feature-definition-2">Feature Definition</a></h1>
<p id="rfc.section.13.3.3.1.p.1">A <em>Caller</em> might want to issue a call providing a <em>timeout</em> for the call to finish.  </p>
<p id="rfc.section.13.3.3.1.p.2">A <em>timeout</em> allows to <strong>automatically</strong> cancel a call after a specified time either at the <em>Callee</em> or at the <em>Dealer</em>.  </p>
<p id="rfc.section.13.3.3.1.p.3">A <em>Caller</em> specifies a timeout by providing </p>
<pre>
    CALL.Options.timeout|integer
</pre>
<p id="rfc.section.13.3.3.1.p.4">in ms. A timeout value of <samp>0</samp> deactivates automatic call timeout. This is also the default value.  </p>
<p id="rfc.section.13.3.3.1.p.5">The timeout option is a companion to, but slightly different from the <samp>CANCEL</samp> and <samp>INTERRUPT</samp> messages that allow a <em>Caller</em> and <em>Dealer</em> to <strong>actively</strong> cancel a call or invocation.  </p>
<p id="rfc.section.13.3.3.1.p.6">In fact, a timeout timer might run at three places: </p>
<p/>

<ul>
  <li>
    <em>Caller</em>
  </li>
  <li>
    <em>Dealer</em>
  </li>
  <li>
    <em>Callee</em>
  </li>
</ul>

<p> </p>
<h1 id="rfc.section.13.3.3.2"><a href="#rfc.section.13.3.3.2">13.3.3.2.</a> <a href="#feature-announcement-1" id="feature-announcement-1">Feature Announcement</a></h1>
<p id="rfc.section.13.3.3.2.p.1">Support for this feature MUST be announced by <em>Callers</em> (<samp>role := "caller"</samp>), <em>Callees</em> (<samp>role := "callee"</samp>) and <em>Dealers</em> (<samp>role := "dealer"</samp>) via </p>
<pre>
    HELLO.Details.roles.&lt;role&gt;.features.call_timeout|bool := true
</pre>
<h1 id="rfc.section.13.3.4"><a href="#rfc.section.13.3.4">13.3.4.</a> <a href="#call-canceling" id="call-canceling">Call Canceling</a></h1>
<h1 id="rfc.section.13.3.4.1"><a href="#rfc.section.13.3.4.1">13.3.4.1.</a> <a href="#feature-definition-3" id="feature-definition-3">Feature Definition</a></h1>
<p id="rfc.section.13.3.4.1.p.1">A <em>Caller</em> might want to actively cancel a call that was issued, but not has yet returned. An example where this is useful could be a user triggering a long running operation and later changing his mind or no longer willing to wait.  </p>
<p id="rfc.section.13.3.4.1.p.2">The message flow between <em>Callers</em>, a <em>Dealer</em> and <em>Callees</em> for canceling remote procedure calls involves the following messages: </p>
<p/>

<ul>
  <li>
    <samp>CANCEL</samp>
  </li>
  <li>
    <samp>INTERRUPT</samp>
  </li>
</ul>

<p> </p>
<p id="rfc.section.13.3.4.1.p.4">A call may be cancelled at the <em>Callee</em> </p>
<pre>
    ,------.          ,------.          ,------.
    |Caller|          |Dealer|          |Callee|
    `--+---'          `--+---'          `--+---'
       |       CALL      |                 |    
       | ----------------&gt;                 |    
       |                 |                 |    
       |                 |    INVOCATION   |    
       |                 | ----------------&gt;    
       |                 |                 |    
       |      CANCEL     |                 |    
       | ----------------&gt;                 |    
       |                 |                 |    
       |                 |    INTERRUPT    |    
       |                 | ----------------&gt;    
       |                 |                 |    
       |                 |      ERROR      |    
       |                 | &lt;----------------    
       |                 |                 |    
       |      ERROR      |                 |    
       | &lt;----------------                 |    
    ,--+---.          ,--+---.          ,--+---.
    |Caller|          |Dealer|          |Callee|
    `------'          `------'          `------'
</pre>
<p id="rfc.section.13.3.4.1.p.5">A call may be cancelled at the <em>Dealer</em> </p>
<pre>
    ,------.          ,------.          ,------.
    |Caller|          |Dealer|          |Callee|
    `--+---'          `--+---'          `--+---'
       |       CALL      |                 |    
       | ----------------&gt;                 |    
       |                 |                 |    
       |                 |    INVOCATION   |    
       |                 | ----------------&gt;    
       |                 |                 |    
       |      CANCEL     |                 |    
       | ----------------&gt;                 |    
       |                 |                 |    
       |      ERROR      |                 |    
       | &lt;----------------                 |    
       |                 |                 |    
       |                 |    INTERRUPT    |    
       |                 | ----------------&gt;    
       |                 |                 |    
       |                 |      ERROR      |    
       |                 | &lt;----------------    
    ,--+---.          ,--+---.          ,--+---.
    |Caller|          |Dealer|          |Callee|
    `------'          `------'          `------'
</pre>
<p id="rfc.section.13.3.4.1.p.6">A <em>Caller</em> cancels a remote procedure call initiated (but not yet finished) by sending a <samp>CANCEL</samp> message to the <em>Dealer</em>: </p>
<pre>
    [CANCEL, CALL.Request|id, Options|dict]
</pre>
<p id="rfc.section.13.3.4.1.p.7">A <em>Dealer</em> cancels an invocation of an endpoint initiated (but not yet finished) by sending a <samp>INTERRUPT</samp> message to the <em>Callee</em>: </p>
<pre>
    [INTERRUPT, INVOCATION.Request|id, Options|dict]
</pre>
<p id="rfc.section.13.3.4.1.p.8">Options: </p>
<pre>
    CANCEL.Options.mode|string == "skip" | "kill" | "killnowait"
</pre>
<h1 id="rfc.section.13.3.4.2"><a href="#rfc.section.13.3.4.2">13.3.4.2.</a> <a href="#feature-announcement-2" id="feature-announcement-2">Feature Announcement</a></h1>
<p id="rfc.section.13.3.4.2.p.1">Support for this feature MUST be announced by <em>Callers</em> (<samp>role := "caller"</samp>), <em>Callees</em> (<samp>role := "callee"</samp>) and <em>Dealers</em> (<samp>role := "dealer"</samp>) via </p>
<pre>
    HELLO.Details.roles.&lt;role&gt;.features.call_canceling|bool := true
</pre>
<h1 id="rfc.section.13.3.5"><a href="#rfc.section.13.3.5">13.3.5.</a> <a href="#caller-identification" id="caller-identification">Caller Identification</a></h1>
<h1 id="rfc.section.13.3.5.1"><a href="#rfc.section.13.3.5.1">13.3.5.1.</a> <a href="#feature-definition-4" id="feature-definition-4">Feature Definition</a></h1>
<p id="rfc.section.13.3.5.1.p.1">A <em>Caller</em> MAY <strong>request</strong> the disclosure of its identity (its WAMP session ID) to endpoints of a routed call via </p>
<pre>
    CALL.Options.disclose_me|bool := true
</pre>
<p><em>Example</em> </p>
<pre>
    [48, 7814135, {"disclose_me": true}, "com.myapp.echo",
        ["Hello, world!"]]
</pre>
<p id="rfc.section.13.3.5.1.p.3">If above call is issued by a <em>Caller</em> with WAMP session ID <samp>3335656</samp>, the <em>Dealer</em> sends an <samp>INVOCATION</samp> message to <em>Callee</em> with the <em>Caller's</em> WAMP session ID in <samp>INVOCATION.Details.caller</samp>: </p>
<p><em>Example</em> </p>
<pre>
    [68, 6131533, 9823526, {"caller": 3335656}, ["Hello, world!"]]
</pre>
<p id="rfc.section.13.3.5.1.p.5">Note that a <em>Dealer</em> MAY disclose the identity of a <em>Caller</em> even without the <em>Caller</em> having explicitly requested to do so when the <em>Dealer</em> configuration (for the called procedure) is setup to do so.  </p>
<p id="rfc.section.13.3.5.1.p.6">A <em>Dealer</em> MAY deny a <em>Caller's</em> request to disclose its identity: </p>
<p><em>Example</em> </p>
<pre>
    [8, 7814135, "wamp.error.disclose_me.not_allowed"]
</pre>
<p id="rfc.section.13.3.5.1.p.8">A <em>Callee</em> MAY <strong>request</strong> the disclosure of caller identity via </p>
<pre>
    REGISTER.Options.disclose_caller|bool := true
</pre>
<p><em>Example</em> </p>
<pre>
    [64, 927639114088448, {"disclose_caller":true},
        "com.maypp.add2"]
</pre>
<p id="rfc.section.13.3.5.1.p.10">With the above registration, the registered procedure is called with the caller's sessionID as part of the call details object.  </p>
<h1 id="rfc.section.13.3.5.2"><a href="#rfc.section.13.3.5.2">13.3.5.2.</a> <a href="#feature-announcement-3" id="feature-announcement-3">Feature Announcement</a></h1>
<p id="rfc.section.13.3.5.2.p.1">Support for this feature MUST be announced by <em>Callers</em> (<samp>role := "caller"</samp>), <em>Callees</em> (<samp>role := "callee"</samp>) and <em>Dealers</em> (<samp>role := "dealer"</samp>) via </p>
<pre>
    HELLO.Details.roles.&lt;role&gt;.features.
         caller_identification|bool := true
</pre>
<h1 id="rfc.section.13.3.6"><a href="#rfc.section.13.3.6">13.3.6.</a> <a href="#call-trust-levels" id="call-trust-levels">Call Trust Levels</a></h1>
<h1 id="rfc.section.13.3.6.1"><a href="#rfc.section.13.3.6.1">13.3.6.1.</a> <a href="#feature-defintion" id="feature-defintion">Feature Defintion</a></h1>
<p id="rfc.section.13.3.6.1.p.1">A <em>Dealer</em> may be configured to automatically assign <em>trust levels</em> to calls issued by <em>Callers</em> according to the <em>Dealer</em> configuration on a per-procedure basis and/or depending on the application defined role of the (authenticated) <em>Caller</em>.  </p>
<p id="rfc.section.13.3.6.1.p.2">A <em>Dealer</em> supporting trust level will provide </p>
<pre>
    INVOCATION.Details.trustlevel|integer
</pre>
<p id="rfc.section.13.3.6.1.p.3">in an <samp>INVOCATION</samp> message sent to a <em>Callee</em>. The trustlevel <samp>0</samp> means lowest trust, and higher integers represent (application-defined) higher levels of trust.  </p>
<p><em>Example</em> </p>
<pre>
    [68, 6131533, 9823526, {"trustlevel": 2}, ["Hello, world!"]]
</pre>
<p id="rfc.section.13.3.6.1.p.5">In above event, the <em>Dealer</em> has (by configuration and/or other information) deemed the call (and hence the invocation) to be of trustlevel <samp>2</samp>.  </p>
<h1 id="rfc.section.13.3.6.2"><a href="#rfc.section.13.3.6.2">13.3.6.2.</a> <a href="#feature-announcement-4" id="feature-announcement-4">Feature Announcement</a></h1>
<p id="rfc.section.13.3.6.2.p.1">Support for this feature MUST be announced by <em>Callees</em> (<samp>role := "callee"</samp>) and <em>Dealers</em> (<samp>role := "dealer"</samp>) via </p>
<pre>
    HELLO.Details.roles.&lt;role&gt;.features.call_trustlevels|bool := true
</pre>
<h1 id="rfc.section.13.3.7"><a href="#rfc.section.13.3.7">13.3.7.</a> <a href="#registration-meta-api" id="registration-meta-api">Registration Meta API</a></h1>
<h1 id="rfc.section.13.3.7.1"><a href="#rfc.section.13.3.7.1">13.3.7.1.</a> <a href="#feature-definition-5" id="feature-definition-5">Feature Definition</a></h1>
<h1 id="rfc.section.13.3.7.1.1"><a href="#rfc.section.13.3.7.1.1">13.3.7.1.1.</a> <a href="#introduction-1" id="introduction-1">Introduction</a></h1>
<p><strong>Registration Meta Events</strong> are fired when registrations are first created, when <em>Callees</em> are attached (removed) to (from) a registration, and when registrations are finally destroyed.  </p>
<p id="rfc.section.13.3.7.1.1.p.2">Furthermore, WAMP allows actively retrieving information about registrations via <strong>Registration Meta Procedures</strong>.  </p>
<p id="rfc.section.13.3.7.1.1.p.3">Meta-events are created by the router itself. This means that the events as well as the data received when calling a meta-procedure can be accorded the same trust level as the router.  </p>
<p/>

<ul class="empty">
  <li>Note that an implementation that only supports a <em>Broker</em> or <em>Dealer</em> role, not both at the same time, essentially cannot offer the <strong>Registration Meta API</strong>, as it requires both roles to support this feature.  </li>
</ul>
<h1 id="rfc.section.13.3.7.1.2"><a href="#rfc.section.13.3.7.1.2">13.3.7.1.2.</a> <a href="#registration-meta-events" id="registration-meta-events">Registration Meta Events</a></h1>
<p id="rfc.section.13.3.7.1.2.p.1">A client can subscribe to the following registration meta-events, which cover the lifecycle of a registration: </p>
<p/>

<ul>
  <li><samp>wamp.registration.on_create</samp>: Fired when a registration is created through a registration request for an URI which was previously without a registration.</li>
  <li><samp>wamp.registration.on_register</samp>: Fired when a <em>Callee</em> session is added to a registration.</li>
  <li><samp>wamp.registration.on_unregister</samp>: Fired when a <em>Callee</em> session is removed from a registration.</li>
  <li><samp>wamp.registration.on_delete</samp>: Fired when a registration is deleted after the last <em>Callee</em> session attached to it has been removed.</li>
</ul>

<p> </p>
<p id="rfc.section.13.3.7.1.2.p.3">A <samp>wamp.registration.on_register</samp> event MUST be fired subsequent to a <samp>wamp.registration.on_create</samp> event, since the first registration results in both the creation of the registration and the addition of a session.  </p>
<p id="rfc.section.13.3.7.1.2.p.4">Similarly, the <samp>wamp.registration.on_delete</samp> event MUST be preceded by a <samp>wamp.registration.on_unregister</samp> event.  </p>
<p><strong>Registration Meta Events</strong> MUST be dispatched by the router to the same realm as the WAMP session which triggered the event.  </p>
<h1 id="rfc.section.13.3.7.1.2.1"><a href="#rfc.section.13.3.7.1.2.1">13.3.7.1.2.1.</a> <a href="#wampregistrationoncreate" id="wampregistrationoncreate">wamp.registration.on_create</a></h1>
<p id="rfc.section.13.3.7.1.2.1.p.1">Fired when a registration is created through a registration request for an URI which was previously without a registration.  </p>
<p><strong>Event Arguments</strong> </p>
<p/>

<ul>
  <li><samp>session|id</samp>: The session ID performing the registration request.</li>
  <li><samp>RegistrationDetails|dict</samp>: Information on the created registration.</li>
</ul>

<p> </p>
<p><strong>Object Schemas</strong> </p>
<pre>
    RegistrationDetails :=
    {
        "id": registration|id,
        "created": time_created|iso_8601_string,
        "uri": procedure|uri,
        "match": match_policy|string,
        "invoke": invocation_policy|string
    }
</pre>
<p id="rfc.section.13.3.7.1.2.1.p.5">See <a href="pattern-based-registration.md">Pattern-based Registrations</a> for a description of <samp>match_policy</samp>.  </p>
<p/>

<ul class="empty">
  <li>NOTE: invocation_policy IS NOT YET DESCRIBED IN THE ADVANCED SPEC </li>
</ul>
<h1 id="rfc.section.13.3.7.1.2.2"><a href="#rfc.section.13.3.7.1.2.2">13.3.7.1.2.2.</a> <a href="#wampregistrationonregister" id="wampregistrationonregister">wamp.registration.on_register</a></h1>
<p id="rfc.section.13.3.7.1.2.2.p.1">Fired when a session is added to a registration.  </p>
<p><strong>Event Arguments</strong> </p>
<p/>

<ul>
  <li><samp>session|id</samp>: The ID of the session being added to a registration.</li>
  <li><samp>registration|id</samp>: The ID of the registration to which a session is being added.</li>
</ul>

<p> </p>
<h1 id="rfc.section.13.3.7.1.2.3"><a href="#rfc.section.13.3.7.1.2.3">13.3.7.1.2.3.</a> <a href="#wampregistrationonunregister" id="wampregistrationonunregister">wamp.registration.on_unregister</a></h1>
<p id="rfc.section.13.3.7.1.2.3.p.1">Fired when a session is removed from a subscription.  </p>
<p><strong>Event Arguments</strong> </p>
<p/>

<ul>
  <li><samp>session|id</samp>: The ID of the session being removed from a registration.</li>
  <li><samp>registration|id</samp>: The ID of the registration from which a session is being removed.</li>
</ul>

<p> </p>
<h1 id="rfc.section.13.3.7.1.2.4"><a href="#rfc.section.13.3.7.1.2.4">13.3.7.1.2.4.</a> <a href="#wampregistrationondelete" id="wampregistrationondelete">wamp.registration.on_delete</a></h1>
<p id="rfc.section.13.3.7.1.2.4.p.1">Fired when a registration is deleted after the last session attached to it has been removed.  </p>
<p><strong>Event Arguments</strong> </p>
<p/>

<ul>
  <li><samp>session|id</samp>: The ID of the last session being removed from a registration.</li>
  <li><samp>registration|id</samp>: The ID of the registration being deleted.</li>
</ul>

<p> </p>
<h1 id="rfc.section.13.3.7.1.3"><a href="#rfc.section.13.3.7.1.3">13.3.7.1.3.</a> <a href="#registration-metaprocedures" id="registration-metaprocedures">Registration Meta-Procedures</a></h1>
<p id="rfc.section.13.3.7.1.3.p.1">A client can actively retrieve information about registrations via the following meta-procedures: </p>
<p/>

<ul>
  <li><samp>wamp.registration.list</samp>: Retrieves registration IDs listed according to match policies.</li>
  <li><samp>wamp.registration.lookup</samp>: Obtains the registration (if any) managing a procedure, according to some match policy.</li>
  <li><samp>wamp.registration.match</samp>: Obtains the registration best matching a given procedure URI.</li>
  <li><samp>wamp.registration.get</samp>: Retrieves information on a particular registration.</li>
  <li><samp>wamp.registration.list_callees</samp>: Retrieves a list of session IDs for sessions currently attached to the registration.</li>
  <li><samp>wamp.registration.count_callees</samp>: Obtains the number of sessions currently attached to the registration.</li>
</ul>

<p> </p>
<h1 id="rfc.section.13.3.7.1.3.1"><a href="#rfc.section.13.3.7.1.3.1">13.3.7.1.3.1.</a> <a href="#wampregistrationlist" id="wampregistrationlist">wamp.registration.list</a></h1>
<p id="rfc.section.13.3.7.1.3.1.p.1">Retrieves registration IDs listed according to match policies.  </p>
<p><strong>Arguments</strong> </p>
<p/>

<ul>
  <li>None</li>
</ul>

<p> </p>
<p><strong>Results</strong> </p>
<p/>

<ul>
  <li><samp>RegistrationLists|dict</samp>: A dictionary with a list of registration IDs for each match policy.</li>
</ul>

<p> </p>
<p><strong>Object Schemas</strong> </p>
<pre>
    RegistrationLists :=
    {
        "exact": registration_ids|list,
        "prefix": registration_ids|list,
        "wildcard": registration_ids|list
    }
</pre>
<p id="rfc.section.13.3.7.1.3.1.p.7">See <a href="pattern-based-registration.md">Pattern-based Registrations</a> for a description of match policies.  </p>
<h1 id="rfc.section.13.3.7.1.3.2"><a href="#rfc.section.13.3.7.1.3.2">13.3.7.1.3.2.</a> <a href="#wampregistrationlookup" id="wampregistrationlookup">wamp.registration.lookup</a></h1>
<p id="rfc.section.13.3.7.1.3.2.p.1">Obtains the registration (if any) managing a procedure, according to some match policy.  </p>
<p><strong>Arguments</strong> </p>
<p/>

<ul>
  <li><samp>procedure|uri</samp>: The procedure to lookup the registration for.</li>
  <li>(Optional) <samp>options|dict</samp>: Same options as when registering a procedure.</li>
</ul>

<p> </p>
<p><strong>Results</strong> </p>
<p/>

<ul>
  <li>(Nullable) <samp>registration|id</samp>: The ID of the registration managing the procedure, if found, or null.</li>
</ul>

<p> </p>
<h1 id="rfc.section.13.3.7.1.3.3"><a href="#rfc.section.13.3.7.1.3.3">13.3.7.1.3.3.</a> <a href="#wampregistrationmatch" id="wampregistrationmatch">wamp.registration.match</a></h1>
<p id="rfc.section.13.3.7.1.3.3.p.1">Obtains the registration best matching a given procedure URI.  </p>
<p><strong>Arguments</strong> </p>
<p/>

<ul>
  <li><samp>procedure|uri</samp>: The procedure URI to match</li>
</ul>

<p> </p>
<p><strong>Results</strong> </p>
<p/>

<ul>
  <li>(Nullable) <samp>registration|id</samp>: The ID of best matching registration, or null.</li>
</ul>

<p> </p>
<h1 id="rfc.section.13.3.7.1.3.4"><a href="#rfc.section.13.3.7.1.3.4">13.3.7.1.3.4.</a> <a href="#wampregistrationget" id="wampregistrationget">wamp.registration.get</a></h1>
<p id="rfc.section.13.3.7.1.3.4.p.1">Retrieves information on a particular registration.  </p>
<p><strong>Arguments</strong> </p>
<p/>

<ul>
  <li><samp>registration|id</samp>: The ID of the registration to retrieve.</li>
</ul>

<p> </p>
<p><strong>Results</strong> </p>
<p/>

<ul>
  <li><samp>RegistrationDetails|dict</samp>: Details on the registration.</li>
</ul>

<p> </p>
<p><strong>Error URIs</strong> </p>
<p/>

<ul>
  <li><samp>wamp.error.no_such_registration</samp>: No registration with the given ID exists on the router.</li>
</ul>

<p> </p>
<p><strong>Object Schemas</strong> </p>
<pre>
    RegistrationDetails :=
    {
        "id": registration|id,
        "created": time_created|iso_8601_string,
        "uri": procedure|uri,
        "match": match_policy|string,
        "invoke": invocation_policy|string
    }
</pre>
<p id="rfc.section.13.3.7.1.3.4.p.9">See <a href="pattern-based-registration.md">Pattern-based Registrations</a> for a description of match policies.  </p>
<p><em>NOTE: invocation_policy IS NOT YET DESCRIBED IN THE ADVANCED SPEC</em> </p>
<h1 id="rfc.section.13.3.7.1.3.5"><a href="#rfc.section.13.3.7.1.3.5">13.3.7.1.3.5.</a> <a href="#wampregistrationlistcallees" id="wampregistrationlistcallees">wamp.registration.list_callees</a></h1>
<p id="rfc.section.13.3.7.1.3.5.p.1">Retrieves a list of session IDs for sessions currently attached to the registration.  </p>
<p><strong>Arguments</strong> </p>
<p/>

<ul>
  <li><samp>registration|id</samp>: The ID of the registration to get calles for.</li>
</ul>

<p> </p>
<p><strong>Results</strong> </p>
<p/>

<ul>
  <li><samp>callee_ids|list</samp>: A list of WAMP session IDs of callees currently attached to the registration.</li>
</ul>

<p> </p>
<p><strong>Error URIs</strong> </p>
<p/>

<ul>
  <li><samp>wamp.error.no_such_registration</samp>: No registration with the given ID exists on the router.</li>
</ul>

<p> </p>
<h1 id="rfc.section.13.3.7.1.3.6"><a href="#rfc.section.13.3.7.1.3.6">13.3.7.1.3.6.</a> <a href="#wampregistrationcountcallees" id="wampregistrationcountcallees">wamp.registration.count_callees</a></h1>
<p id="rfc.section.13.3.7.1.3.6.p.1">Obtains the number of sessions currently attached to a registration.  </p>
<p><strong>Arguments</strong> </p>
<p/>

<ul>
  <li><samp>registration|id</samp>: The ID of the registration to get the number of callees for.</li>
</ul>

<p> </p>
<p><strong>Results</strong> </p>
<p/>

<ul>
  <li><samp>count|int</samp>: The number of callees currently attached to a registration.</li>
</ul>

<p> </p>
<p><strong>Error URIs</strong> </p>
<p/>

<ul>
  <li><samp>wamp.error.no_such_registration</samp>: No registration with the given ID exists on the router.</li>
</ul>

<p> </p>
<h1 id="rfc.section.13.3.7.2"><a href="#rfc.section.13.3.7.2">13.3.7.2.</a> <a href="#feature-announcement-5" id="feature-announcement-5">Feature Announcement</a></h1>
<p id="rfc.section.13.3.7.2.p.1">Support for this feature MUST be announced by a <em>Dealers</em> (<samp>role := "dealer"</samp>) via: </p>
<pre>
    HELLO.Details.roles.&lt;role&gt;.features.
        session_meta_api|bool := true
</pre>
<p><strong>Example</strong> </p>
<p id="rfc.section.13.3.7.2.p.3">Here is a <samp>WELCOME</samp> message from a <em>Router</em> with support for both the <em>Broker</em> and <em>Dealer</em> role, and with support for <strong>Registration Meta API</strong>: </p>
<pre>
    [
        2,
        4580268554656113,
        {
            "authid":"OL3AeppwDLXiAAPbqm9IVhnw",
            "authrole": "anonymous",
            "authmethod": "anonymous",
            "roles": {
                "broker": {
                    "features": {
                    }
                },
                "dealer": {
                    "features": {
                        "registration_meta_api": true
                    }
                }
            }
        }
    ]
</pre>
<h1 id="rfc.section.13.3.8"><a href="#rfc.section.13.3.8">13.3.8.</a> <a href="#patternbased-registrations" id="patternbased-registrations">Pattern-based Registrations</a></h1>
<h1 id="rfc.section.13.3.8.1"><a href="#rfc.section.13.3.8.1">13.3.8.1.</a> <a href="#feature-definition-6" id="feature-definition-6">Feature Definition</a></h1>
<h1 id="rfc.section.13.3.8.1.1"><a href="#rfc.section.13.3.8.1.1">13.3.8.1.1.</a> <a href="#introduction-2" id="introduction-2">Introduction</a></h1>
<p id="rfc.section.13.3.8.1.1.p.1">By default, <em>Callees</em> register procedures with <strong>exact matching policy</strong>. That is a call will only be routed to a <em>Callee</em> by the <em>Dealer</em> if the procedure called (<samp>CALL.Procedure</samp>) <em>exactly</em> matches the endpoint registered (<samp>REGISTER.Procedure</samp>).  </p>
<p id="rfc.section.13.3.8.1.1.p.2">A <em>Callee</em> might want to register procedures based on a <em>pattern</em>. This can be useful to reduce the number of individual registrations to be set up or to subscribe to a open set of topics, not known beforehand by the <em>Subscriber</em>.  </p>
<p id="rfc.section.13.3.8.1.1.p.3">If the <em>Dealer</em> and the <em>Callee</em> support <strong>pattern-based registrations</strong>, this matching can happen by </p>
<p/>

<ul>
  <li>
    <strong>prefix-matching policy</strong>
  </li>
  <li>
    <strong>wildcard-matching policy</strong>
  </li>
</ul>

<p> </p>
<h1 id="rfc.section.13.3.8.1.2"><a href="#rfc.section.13.3.8.1.2">13.3.8.1.2.</a> <a href="#prefix-matching" id="prefix-matching">Prefix Matching</a></h1>
<p id="rfc.section.13.3.8.1.2.p.1">A <em>Callee</em> requests <strong>prefix-matching policy</strong> with a registration request by setting </p>
<pre>
    REGISTER.Options.match|string := "prefix"
</pre>
<p><em>Example</em> </p>
<pre>
    [
        64,
        612352435,
        {
            "match": "prefix"
        },
        "com.myapp.myobject1"
    ]
</pre>
<p id="rfc.section.13.3.8.1.2.p.3">When a <strong>prefix-matching policy</strong> is in place, any call with a procedure that has <samp>REGISTER.Procedure</samp> as a <em>prefix</em> will match the registration, and potentially be routed to <em>Callees</em> on that registration.  </p>
<p id="rfc.section.13.3.8.1.2.p.4">In above example, the following calls with <samp>CALL.Procedure</samp> </p>
<p/>

<ul>
  <li>
    <samp>com.myapp.myobject1.myprocedure1</samp>
  </li>
  <li>
    <samp>com.myapp.myobject1-mysubobject1</samp>
  </li>
  <li>
    <samp>com.myapp.myobject1.mysubobject1.myprocedure1</samp>
  </li>
  <li>
    <samp>com.myapp.myobject1</samp>
  </li>
</ul>

<p> </p>
<p id="rfc.section.13.3.8.1.2.p.6">will all apply for call routing. A call with one of the following <samp>CALL.Procedure</samp> </p>
<p/>

<ul>
  <li>
    <samp>com.myapp.myobject2</samp>
  </li>
  <li>
    <samp>com.myapp.myobject</samp>
  </li>
</ul>

<p> </p>
<p id="rfc.section.13.3.8.1.2.p.8">will not apply.  </p>
<h1 id="rfc.section.13.3.8.1.3"><a href="#rfc.section.13.3.8.1.3">13.3.8.1.3.</a> <a href="#wildcard-matching" id="wildcard-matching">Wildcard Matching</a></h1>
<p id="rfc.section.13.3.8.1.3.p.1">A <em>Callee</em> requests <strong>wildcard-matching policy</strong> with a registration request by setting </p>
<pre>
    REGISTER.Options.match|string := "wildcard"
</pre>
<p id="rfc.section.13.3.8.1.3.p.2">Wildcard-matching allows to provide wildcards for <strong>whole</strong> URI components.  </p>
<p><em>Example</em> </p>
<pre>
    [
        64,
        612352435,
        {
            "match": "wildcard"
        },
        "com.myapp..myprocedure1"
    ]
</pre>
<p id="rfc.section.13.3.8.1.3.p.4">In the above registration request, the 3rd URI component is empty, which signals a wildcard in that URI component position. In this example, calls with <samp>CALL.Procedure</samp> e.g.  </p>
<p/>

<ul>
  <li>
    <samp>com.myapp.myobject1.myprocedure1</samp>
  </li>
  <li>
    <samp>com.myapp.myobject2.myprocedure1</samp>
  </li>
</ul>

<p> </p>
<p id="rfc.section.13.3.8.1.3.p.6">will all apply for call routing. Calls with <samp>CALL.Procedure</samp> e.g.  </p>
<p/>

<ul>
  <li>
    <samp>com.myapp.myobject1.myprocedure1.mysubprocedure1</samp>
  </li>
  <li>
    <samp>com.myapp.myobject1.myprocedure2</samp>
  </li>
  <li>
    <samp>com.myapp2.myobject1.myprocedure1</samp>
  </li>
</ul>

<p> </p>
<p id="rfc.section.13.3.8.1.3.p.8">will not apply for call routing.  </p>
<p id="rfc.section.13.3.8.1.3.p.9">When a single call matches more than one of a <em>Callees</em> registrations, the call MAY be routed for invocation on multiple registrations, depending on call settings.  </p>
<h1 id="rfc.section.13.3.8.1.4"><a href="#rfc.section.13.3.8.1.4">13.3.8.1.4.</a> <a href="#general" id="general">General</a></h1>
<h1 id="rfc.section.13.3.8.1.4.1"><a href="#rfc.section.13.3.8.1.4.1">13.3.8.1.4.1.</a> <a href="#no-set-semantics" id="no-set-semantics">No set semantics</a></h1>
<p id="rfc.section.13.3.8.1.4.1.p.1">Since each <em>Callee</em>'s' registrations "stands on it's own", there is no <em>set semantics</em> implied by pattern-based registrations.  </p>
<p id="rfc.section.13.3.8.1.4.1.p.2">E.g. a <em>Callee</em> cannot register to a broad pattern, and then unregister from a subset of that broad pattern to form a more complex registration. Each registration is separate.  </p>
<h1 id="rfc.section.13.3.8.1.4.2"><a href="#rfc.section.13.3.8.1.4.2">13.3.8.1.4.2.</a> <a href="#calls-matching-multiple-registrations" id="calls-matching-multiple-registrations">Calls matching multiple registrations</a></h1>
<p id="rfc.section.13.3.8.1.4.2.p.1">The behavior when a single call matches more than one of a <em>Callee's</em> registrations or more than one registration in general is still being discussed - see <span>&lt;</span><a href="https://github.com/tavendo/WAMP/issues/182">https://github.com/tavendo/WAMP/issues/182</a><span>&gt;</span>.  </p>
<h1 id="rfc.section.13.3.8.1.4.3"><a href="#rfc.section.13.3.8.1.4.3">13.3.8.1.4.3.</a> <a href="#concrete-procedure-called" id="concrete-procedure-called">Concrete procedure called</a></h1>
<p id="rfc.section.13.3.8.1.4.3.p.1">If an endpoint was registered with a pattern-based matching policy, a <em>Dealer</em> MUST supply the original <samp>CALL.Procedure</samp> as provided by the <em>Caller</em> in </p>
<pre>
    INVOCATION.Details.procedure
</pre>
<p id="rfc.section.13.3.8.1.4.3.p.2">to the <em>Callee</em>.  </p>
<p><em>Example</em> </p>
<pre>
    [
        68,
        6131533,
        9823527,
        {
            "procedure": "com.myapp.procedure.proc1"
        },
        ["Hello, world!"]
    ]
</pre>
<h1 id="rfc.section.13.3.8.2"><a href="#rfc.section.13.3.8.2">13.3.8.2.</a> <a href="#feature-announcement-6" id="feature-announcement-6">Feature Announcement</a></h1>
<p id="rfc.section.13.3.8.2.p.1">Support for this feature MUST be announced by <em>Callees</em> (<samp>role := "callee"</samp>) and <em>Dealers</em> (<samp>role := "dealer"</samp>) via </p>
<pre>
    HELLO.Details.roles.&lt;role&gt;.features.
        pattern_based_registration|bool := true
</pre>
<h1 id="rfc.section.13.3.9"><a href="#rfc.section.13.3.9">13.3.9.</a> <a href="#shared-registration" id="shared-registration">Shared Registration</a></h1>
<p id="rfc.section.13.3.9.p.1">Feature status: <strong>alpha</strong> </p>
<h1 id="rfc.section.13.3.9.1"><a href="#rfc.section.13.3.9.1">13.3.9.1.</a> <a href="#feature-definition-7" id="feature-definition-7">Feature Definition</a></h1>
<p id="rfc.section.13.3.9.1.p.1">As a default, only a single <strong>Callee</strong> may register a procedure for an URI.  </p>
<p id="rfc.section.13.3.9.1.p.2">There are use cases where more flexibility is required. As an example, for an application component with a high computing load, several instances may run, and load balancing of calls across these may be desired. As another example, in an an application a second or third component providing a procedure may run, which are only to be called in case the primary component is no longer reachable (hot standby).  </p>
<p id="rfc.section.13.3.9.1.p.3">When shared registrations are supported, then the first <strong>Callee</strong> to register a procedure for a particular URI MAY determine that additional registrations for this URI are allowed, and what <strong>Invocation Rules</strong> to apply in case such additional registrations are made.  </p>
<p id="rfc.section.13.3.9.1.p.4">This is done through setting </p>
<pre>
    REGISTER.Options.invoke|string := &lt;invocation_policy&gt;
</pre>
<p id="rfc.section.13.3.9.1.p.5">where  is one of </p>
<p/>

<ul>
  <li>'single'</li>
  <li>'roundrobin'</li>
  <li>'random'</li>
  <li>'first'</li>
  <li>'last'</li>
</ul>

<p> </p>
<p id="rfc.section.13.3.9.1.p.7">If the option is not set, 'single' is applied as a default.  </p>
<p id="rfc.section.13.3.9.1.p.8">With 'single', the <strong>Dealer</strong> MUST fail all subsequent attempts to register a procedure for the URI while the registration remains in existence.  </p>
<p id="rfc.section.13.3.9.1.p.9">With the other values, the <strong>Dealer</strong> MUST fail all subsequent attempst to register a procedure for the URI where the value for this option does not match that of the initial registration.  </p>
<h1 id="rfc.section.13.3.9.1.1"><a href="#rfc.section.13.3.9.1.1">13.3.9.1.1.</a> <a href="#load-balancing" id="load-balancing">Load Balancing</a></h1>
<p id="rfc.section.13.3.9.1.1.p.1">For sets of registrations registered using either 'roundrobin' or 'random', load balancing is performed across calls to the URI.  </p>
<p id="rfc.section.13.3.9.1.1.p.2">For 'roundrobin', callees are picked subsequently from the list of registrations (ordered by the order of registration), with the picking looping back to the beginning of the list once the end has been reached.  </p>
<p id="rfc.section.13.3.9.1.1.p.3">For 'random' a callee is picked randomly from the list of registrations for each call.  </p>
<h1 id="rfc.section.13.3.9.1.2"><a href="#rfc.section.13.3.9.1.2">13.3.9.1.2.</a> <a href="#hot-standby" id="hot-standby">Hot Stand-By</a></h1>
<p id="rfc.section.13.3.9.1.2.p.1">For sets of registrations registered using either 'first' or 'last', the first respectively last callee on the current list of registrations (ordered by the order of registration) is called.  </p>
<h1 id="rfc.section.13.3.9.2"><a href="#rfc.section.13.3.9.2">13.3.9.2.</a> <a href="#feature-announcement-7" id="feature-announcement-7">Feature Announcement</a></h1>
<p id="rfc.section.13.3.9.2.p.1">Support for this feature MUST be announced by <em>Callees</em> (<samp>role := "callee"</samp>) and <em>Dealers</em> (<samp>role := "dealer"</samp>) via </p>
<pre>
    HELLO.Details.roles.&lt;role&gt;.features.
        shared_registration|bool := true
</pre>
<h1 id="rfc.section.13.3.10"><a href="#rfc.section.13.3.10">13.3.10.</a> <a href="#sharded-registration" id="sharded-registration">Sharded Registration</a></h1>
<p id="rfc.section.13.3.10.p.1">Feature status: <strong>sketch</strong> </p>
<h1 id="rfc.section.13.3.10.1"><a href="#rfc.section.13.3.10.1">13.3.10.1.</a> <a href="#feature-definition-8" id="feature-definition-8">Feature Definition</a></h1>
<p><strong>Sharded Registrations</strong> are intended to allow calling a procedure which is offered by a sharded database, by routing the call to a single shard.  </p>
<h1 id="rfc.section.13.3.10.2"><a href="#rfc.section.13.3.10.2">13.3.10.2.</a> <a href="#partitioned-calls" id="partitioned-calls">"Partitioned" Calls</a></h1>
<p id="rfc.section.13.3.10.2.p.1">If <samp>CALL.Options.runmode == "partition"</samp>, then <samp>CALL.Options.rkey</samp> MUST be present.  </p>
<p id="rfc.section.13.3.10.2.p.2">The call is then routed to all endpoints that were registered ..  </p>
<p id="rfc.section.13.3.10.2.p.3">The call is then processed as for "All" Calls.  </p>
<h1 id="rfc.section.13.3.10.3"><a href="#rfc.section.13.3.10.3">13.3.10.3.</a> <a href="#feature-announcement-8" id="feature-announcement-8">Feature Announcement</a></h1>
<p id="rfc.section.13.3.10.3.p.1">Support for this feature MUST be announced by <em>Callers</em> (<samp>role := "caller"</samp>), <em>Callees</em> (<samp>role := "callee"</samp>) and <em>Dealers</em> (<samp>role := "dealer"</samp>) via </p>
<pre>
HELLO.Details.roles.&lt;role&gt;.features.sharded_registration|bool := true
</pre>
<h1 id="rfc.section.13.3.11"><a href="#rfc.section.13.3.11">13.3.11.</a> <a href="#registration-revocation" id="registration-revocation">Registration Revocation</a></h1>
<h1 id="rfc.section.13.3.11.1"><a href="#rfc.section.13.3.11.1">13.3.11.1.</a> <a href="#feature-definition-9" id="feature-definition-9">Feature Definition</a></h1>
<p id="rfc.section.13.3.11.1.p.1">Actively and forcefully revoke a previously granted registration from a session.  </p>
<h1 id="rfc.section.13.3.11.2"><a href="#rfc.section.13.3.11.2">13.3.11.2.</a> <a href="#feature-announcement-9" id="feature-announcement-9">Feature Announcement</a></h1>
<h1 id="rfc.section.13.3.12"><a href="#rfc.section.13.3.12">13.3.12.</a> <a href="#procedure-reflection" id="procedure-reflection">Procedure Reflection</a></h1>
<p id="rfc.section.13.3.12.p.1">Feature status: <strong>sketch</strong> </p>
<p><em>Reflection</em> denotes the ability of WAMP peers to examine the procedures, topics and errors provided or used by other peers.  </p>
<p id="rfc.section.13.3.12.p.3">I.e. a WAMP <em>Caller</em>, <em>Callee</em>, <em>Subscriber</em> or <em>Publisher</em> may be interested in retrieving a machine readable list and description of WAMP procedures and topics it is authorized to access or provide in the context of a WAMP session with a <em>Dealer</em> or <em>Broker</em>.  </p>
<p id="rfc.section.13.3.12.p.4">Reflection may be useful in the following cases: </p>
<p/>

<ul>
  <li>documentation</li>
  <li>discoverability</li>
  <li>generating stubs and proxies</li>
</ul>

<p> </p>
<p id="rfc.section.13.3.12.p.6">WAMP predefines the following procedures for performing run-time reflection on WAMP peers which act as <em>Brokers</em> and/or <em>Dealers</em>.  </p>
<p id="rfc.section.13.3.12.p.7">Predefined WAMP reflection procedures to <em>list</em> resources by type: </p>
<pre>
    wamp.reflection.topic.list
    wamp.reflection.procedure.list
    wamp.reflection.error.list
</pre>
<p id="rfc.section.13.3.12.p.8">Predefined WAMP reflection procedures to <em>describe</em> resources by type: </p>
<pre>
    wamp.reflection.topic.describe
    wamp.reflection.procedure.describe
    wamp.reflection.error.describe
</pre>
<p id="rfc.section.13.3.12.p.9">A peer that acts as a <em>Broker</em> SHOULD announce support for the reflection API by sending </p>
<pre>
    HELLO.Details.roles.broker.reflection|bool := true
</pre>
<p id="rfc.section.13.3.12.p.10">A peer that acts as a <em>Dealer</em> SHOULD announce support for the reflection API by sending </p>
<pre>
    HELLO.Details.roles.dealer.reflection|bool := true
</pre>
<p/>

<ul class="empty">
  <li>Since <em>Brokers</em> might provide (broker) procedures and <em>Dealers</em> might provide (dealer) topics, both SHOULD implement the complete API above (even if the peer only implements one of <em>Broker</em> or <em>Dealer</em> roles).  </li>
</ul>
<p><strong>Reflection</strong> </p>
<p id="rfc.section.13.3.12.p.13">A topic or procedure is defined for reflection: </p>
<pre>
    wamp.reflect.define
</pre>
<p id="rfc.section.13.3.12.p.14">A topic or procedure was asked to be described (reflected upon): </p>
<pre>
    wamp.reflect.describe
</pre>
<p><strong>Reflection</strong> </p>
<p id="rfc.section.13.3.12.p.16">A topic or procedure has been defined for reflection: </p>
<pre>
    wamp.reflect.on_define
</pre>
<p id="rfc.section.13.3.12.p.17">A topic or procedure has been unfined from reflection: </p>
<pre>
    wamp.reflect.on_undefine
</pre>
<h1 id="rfc.section.13.4"><a href="#rfc.section.13.4">13.4.</a> <a href="#advanced-pubsub-features" id="advanced-pubsub-features">Advanced PubSub Features</a></h1>
<h1 id="rfc.section.13.4.1"><a href="#rfc.section.13.4.1">13.4.1.</a> <a href="#subscriber-black-and-whitelisting" id="subscriber-black-and-whitelisting">Subscriber Black- and Whitelisting</a></h1>
<h1 id="rfc.section.13.4.1.1"><a href="#rfc.section.13.4.1.1">13.4.1.1.</a> <a href="#introduction-3" id="introduction-3">Introduction</a></h1>
<p><strong>Subscriber Black- and Whitelisting</strong> is an advanced <em>Broker</em> feature where a <em>Publisher</em> is able to restrict the set of receivers of a published event.  </p>
<p id="rfc.section.13.4.1.1.p.2">Under normal Publish &amp; Subscriber event dispatching, a <em>Broker</em> will dispatch a published event to all (authorized) <em>Subscribers</em> other than the <em>Publisher</em> itself. This set of receivers can be further reduced on a per-publication basis by the <em>Publisher</em> using <strong>Subscriber Black- and Whitelisting</strong>.  </p>
<p id="rfc.section.13.4.1.1.p.3">The <em>Publisher</em> can explicitly <strong>exclude</strong> <em>Subscribers</em> based on WAMP <samp>sessionid</samp>, <samp>authid</samp> or <samp>authrole</samp>. This is referred to as <strong>Blacklisting</strong>.  </p>
<p id="rfc.section.13.4.1.1.p.4">A <em>Publisher</em> may also explicitly define a <strong>eligible</strong> list of *Subscribers** based on WAMP <samp>sessionid</samp>, <samp>authid</samp> or <samp>authrole</samp>. This is referred to as <strong>Whitelisting</strong>.  </p>
<h1 id="rfc.section.13.4.1.2"><a href="#rfc.section.13.4.1.2">13.4.1.2.</a> <a href="#use-cases" id="use-cases">Use Cases</a></h1>
<h1 id="rfc.section.13.4.1.2.1"><a href="#rfc.section.13.4.1.2.1">13.4.1.2.1.</a> <a href="#avoiding-callers-from-being-selfnotified" id="avoiding-callers-from-being-selfnotified">Avoiding Callers from being self-notified</a></h1>
<p id="rfc.section.13.4.1.2.1.p.1">Consider an application that exposes a procedure to update a product price. The procedure might not only actually update the product price (e.g. in a backend database), but additionally publish an event with the updated product price, so that <strong>all</strong> application components get notified actively of the new price.  </p>
<p id="rfc.section.13.4.1.2.1.p.2">However, the application might want to exclude the originator of the product price update (the <strong>Caller</strong> of the price update procedure) from receiving the update event - as the originator naturally already knows the new price, and might get confused when it receives an update the <strong>Caller</strong> has triggered himself.  </p>
<p id="rfc.section.13.4.1.2.1.p.3">The product price update procedure can use <samp>PUBLISH.Options.exclude|list[int]</samp> to exclude the <strong>Caller</strong> of the procedure.  </p>
<p/>

<ul class="empty">
  <li>Note that the product price update procedure needs to know the session ID of the <strong>Caller</strong> to be able to exclude him. For this, please see <strong>Caller Identification</strong>.  </li>
</ul>
<p id="rfc.section.13.4.1.2.1.p.5">A similar approach can be used for other CRUD-like procedures.  </p>
<h1 id="rfc.section.13.4.1.2.2"><a href="#rfc.section.13.4.1.2.2">13.4.1.2.2.</a> <a href="#restricting-receivers-of-sensitive-information" id="restricting-receivers-of-sensitive-information">Restricting receivers of sensitive information</a></h1>
<p id="rfc.section.13.4.1.2.2.p.1">Consider an application with users that have different <samp>authroles</samp>, such as "manager" and "staff" that publishes events with updates to "customers". The topics being published to could be structured like </p>
<pre>
    com.example.myapp.customer.&lt;customer ID&gt;
</pre>
<p id="rfc.section.13.4.1.2.2.p.2">The application might want to restrict the receivers of customer updates depending on the <samp>authrole</samp> of the user. E.g. a user authenticated under <samp>authrole</samp> "manager" might be allowed to receive any kind of customer update, including personal and business sensitive information. A user under <samp>authrole</samp> "staff" might only be allowed to receive a subset of events.  </p>
<p id="rfc.section.13.4.1.2.2.p.3">The application can publish <strong>all</strong> customer updates to the <strong>same</strong> topic <samp>com.example.myapp.customer.&lt;customer ID&gt;</samp> and use <samp>PUBLISH.Options.eligible_authrole|list[string]</samp> to safely restrict the set of actual receivers as desired.  </p>
<h1 id="rfc.section.13.4.1.3"><a href="#rfc.section.13.4.1.3">13.4.1.3.</a> <a href="#feature-definition-10" id="feature-definition-10">Feature Definition</a></h1>
<p id="rfc.section.13.4.1.3.p.1">A <em>Publisher</em> may restrict the actual receivers of an event from the set of <em>Subscribers</em> through the use of </p>
<p/>

<ul>
  <li>Blacklisting Options <ul><li><samp>PUBLISH.Options.exclude|list[int]</samp></li><li><samp>PUBLISH.Options.exclude_authid|list[string]</samp></li><li><samp>PUBLISH.Options.exclude_authrole|list[string]</samp></li></ul></li>
  <li>Whitelisting Options <ul><li><samp>PUBLISH.Options.eligible|list[int]</samp></li><li><samp>PUBLISH.Options.eligible_authid|list[string]</samp></li><li><samp>PUBLISH.Options.eligible_authrole|list[string]</samp></li></ul></li>
</ul>

<p> </p>
<p><samp>PUBLISH.Options.exclude</samp> is a list of integers with WAMP <samp>sessionids</samp> providing an explicit list of (potential) <em>Subscribers</em> that won't receive a published event, even though they may be subscribed. In other words, <samp>PUBLISH.Options.exclude</samp> is a <strong>blacklist</strong> of (potential) <em>Subscribers</em>.  </p>
<p><samp>PUBLISH.Options.eligible</samp> is a list of integeres with WAMP WAMP <samp>sessionids</samp> providing an explicit list of (potential) <em>Subscribers</em> that are allowed to receive a published event. In other words, <samp>PUBLISH.Options.eligible</samp> is a <strong>whitelist</strong> of (potential) <em>Subscribers</em>.  </p>
<p id="rfc.section.13.4.1.3.p.5">The <samp>exclude_authid</samp>, <samp>exclude_authrole</samp>, <samp>eligible_authid</samp> and <samp>eligible_authrole</samp> options work similar, but not on the basis of WAMP <samp>sessionid</samp>, but <samp>authid</samp> and <samp>authrole</samp>.  </p>
<p id="rfc.section.13.4.1.3.p.6">An (authorized) <em>Subscriber</em> to topic T will receive an event published to T if and only if all of the following statements hold true: </p>
<p/>

<ol>
  <li>if there is an <samp>eligible</samp> attribute present, the <em>Subscriber</em>'s <samp>sessionid</samp> is in this list</li>
  <li>if there is an <samp>eligible_authid</samp> attribute present, the <em>Subscriber</em>'s <samp>authid</samp> is in this list</li>
  <li>if there is an <samp>eligible_authrole</samp> attribute present, the <em>Subscriber</em>'s <samp>authrole</samp> is in this list</li>
  <li>if there is an <samp>exclude attribute</samp> present, the <em>Subscriber</em>'s <samp>sessionid</samp> is NOT in this list</li>
  <li>if there is an <samp>exclude_authid</samp> attribute present, the <em>Subscriber</em>'s <samp>authid</samp> is NOT in this list</li>
  <li>if there is an <samp>exclude_authrole</samp> attribute present, the <em>Subscriber</em>'s <samp>authrole</samp> is NOT in this list</li>
</ol>

<p> </p>
<p id="rfc.section.13.4.1.3.p.8">For example, if both <samp>PUBLISH.Options.exclude</samp> and <samp>PUBLISH.Options.eligible</samp> are present, the <em>Broker</em> will dispatch events published only to <em>Subscribers</em> that are not explicitly excluded in <samp>PUBLISH.Options.exclude</samp> <strong>and</strong> which are explicitly eligible via <samp>PUBLISH.Options.eligible</samp>.  </p>
<p><em>Example</em> </p>
<pre>
    [
       16,
       239714735,
       {
          "exclude": [
             7891255,
             1245751
          ]
       },
       "com.myapp.mytopic1",
       [
          "Hello, world!"
       ]
    ]
</pre>
<p id="rfc.section.13.4.1.3.p.10">The above event will get dispatched to all <em>Subscribers</em> of <samp>com.myapp.mytopic1</samp>, but not WAMP sessions with IDs <samp>7891255</samp> or <samp>1245751</samp> (and also not the publishing session).  </p>
<p><em>Example</em> </p>
<pre>
    [
       16,
       239714735,
       {
          "eligible": [
             7891255,
             1245751
          ]
       },
       "com.myapp.mytopic1",
       [
          "Hello, world!"
       ]
    ]
</pre>
<p id="rfc.section.13.4.1.3.p.12">The above event will get dispatched to WAMP sessions with IDs <samp>7891255</samp> or <samp>1245751</samp> only - but only if those are actually subscribed to the topic <samp>com.myapp.mytopic1</samp>.  </p>
<p><em>Example</em> </p>
<pre>
    [
       16,
       239714735,
       {
          "eligible": [
             7891255,
             1245751,
             9912315
          ],
          "exclude": [
             7891255
          ]
       },
       "com.myapp.mytopic1",
       [
          "Hello, world!"
       ]
    ]
</pre>
<p id="rfc.section.13.4.1.3.p.14">The above event will get dispatched to WAMP sessions with IDs <samp>1245751</samp> or <samp>9912315</samp> only, since <samp>7891255</samp> is excluded - but only if those are actually subscribed to the topic <samp>com.myapp.mytopic1</samp>.  </p>
<h1 id="rfc.section.13.4.1.4"><a href="#rfc.section.13.4.1.4">13.4.1.4.</a> <a href="#feature-announcement-10" id="feature-announcement-10">Feature Announcement</a></h1>
<p id="rfc.section.13.4.1.4.p.1">Support for this feature MUST be announced by <em>Publishers</em> (<samp>role := "publisher"</samp>) and <em>Brokers</em> (<samp>role := "broker"</samp>) via </p>
<pre>
    HELLO.Details.roles.&lt;role&gt;.features.
        subscriber_blackwhite_listing|bool := true
</pre>
<h1 id="rfc.section.13.4.2"><a href="#rfc.section.13.4.2">13.4.2.</a> <a href="#publisher-exclusion" id="publisher-exclusion">Publisher Exclusion</a></h1>
<h1 id="rfc.section.13.5"><a href="#rfc.section.13.5">13.5.</a> <a href="#feature-definition-11" id="feature-definition-11">Feature Definition</a></h1>
<p id="rfc.section.13.5.p.1">By default, a <em>Publisher</em> of an event will <strong>not</strong> itself receive an event published, even when subscribed to the <samp>Topic</samp> the <em>Publisher</em> is publishing to. This behavior can be overridden using this feature.  </p>
<p id="rfc.section.13.5.p.2">To override the exclusion of a publisher from it's own publication, the <samp>PUBLISH</samp> message must include the following option: </p>
<pre>
    PUBLISH.Options.exclude_me|bool
</pre>
<p id="rfc.section.13.5.p.3">When publishing with <samp>PUBLISH.Options.exclude_me := false</samp>, the <em>Publisher</em> of the event will receive that event, if it is subscribed to the <samp>Topic</samp> published to.  </p>
<p><em>Example</em> </p>
<pre>
    [
        16,
        239714735,
        {
            "exclude_me": false
        },
        "com.myapp.mytopic1",
        ["Hello, world!"]
    ]
</pre>
<p id="rfc.section.13.5.p.5">In this example, the <em>Publisher</em> will receive the published event, if it is subscribed to <samp>com.myapp.mytopic1</samp>.  </p>
<h1 id="rfc.section.13.6"><a href="#rfc.section.13.6">13.6.</a> <a href="#feature-announcement-11" id="feature-announcement-11">Feature Announcement</a></h1>
<p id="rfc.section.13.6.p.1">Support for this feature MUST be announced by <em>Publishers</em> (<samp>role := "publisher"</samp>) and <em>Brokers</em> (<samp>role := "broker"</samp>) via </p>
<pre>
    HELLO.Details.roles.&lt;role&gt;.features.
        publisher_exclusion|bool := true
</pre>
<h1 id="rfc.section.13.6.1"><a href="#rfc.section.13.6.1">13.6.1.</a> <a href="#publisher-identification" id="publisher-identification">Publisher Identification</a></h1>
<h1 id="rfc.section.13.6.1.1"><a href="#rfc.section.13.6.1.1">13.6.1.1.</a> <a href="#feature-definition-12" id="feature-definition-12">Feature Definition</a></h1>
<p id="rfc.section.13.6.1.1.p.1">A <em>Publisher</em> may request the disclosure of its identity (its WAMP session ID) to receivers of a published event by setting </p>
<pre>
    PUBLISH.Options.disclose_me|bool := true
</pre>
<p><em>Example</em> </p>
<pre>
    [16, 239714735, {"disclose_me": true}, "com.myapp.mytopic1",
        ["Hello, world!"]]
</pre>
<p id="rfc.section.13.6.1.1.p.3">If above event is published by a <em>Publisher</em> with WAMP session ID <samp>3335656</samp>, the <em>Broker</em> would send an <samp>EVENT</samp> message to <em>Subscribers</em> with the <em>Publisher's</em> WAMP session ID in <samp>EVENT.Details.publisher</samp>: </p>
<p><em>Example</em> </p>
<pre>
    [36, 5512315355, 4429313566, {"publisher": 3335656},
        ["Hello, world!"]]
</pre>
<p id="rfc.section.13.6.1.1.p.5">Note that a <em>Broker</em> may deny a <em>Publisher's</em> request to disclose its identity: </p>
<p><em>Example</em> </p>
<pre>
    [8, 239714735, {}, "wamp.error.option_disallowed.disclose_me"]
</pre>
<p id="rfc.section.13.6.1.1.p.7">A <em>Broker</em> may also (automatically) disclose the identity of a <em>Publisher</em> even without the <em>Publisher</em> having explicitly requested to do so when the <em>Broker</em> configuration (for the publication topic) is set up to do so.  </p>
<h1 id="rfc.section.13.6.1.2"><a href="#rfc.section.13.6.1.2">13.6.1.2.</a> <a href="#feature-announcement-12" id="feature-announcement-12">Feature Announcement</a></h1>
<p id="rfc.section.13.6.1.2.p.1">Support for this feature MUST be announced by <em>Publishers</em> (<samp>role := "publisher"</samp>), <em>Brokers</em> (<samp>role := "broker"</samp>) and <em>Subscribers</em> (<samp>role := "subscriber"</samp>) via </p>
<pre>
    HELLO.Details.roles.&lt;role&gt;.features.
        publisher_identification|bool := true
</pre>
<h1 id="rfc.section.13.6.2"><a href="#rfc.section.13.6.2">13.6.2.</a> <a href="#publication-trust-levels" id="publication-trust-levels">Publication Trust Levels</a></h1>
<h1 id="rfc.section.13.6.2.1"><a href="#rfc.section.13.6.2.1">13.6.2.1.</a> <a href="#feature-definition-13" id="feature-definition-13">Feature Definition</a></h1>
<p id="rfc.section.13.6.2.1.p.1">A <em>Broker</em> may be configured to automatically assign <em>trust levels</em> to events published by <em>Publishers</em> according to the <em>Broker</em> configuration on a per-topic basis and/or depending on the application defined role of the (authenticated) <em>Publisher</em>.  </p>
<p id="rfc.section.13.6.2.1.p.2">A <em>Broker</em> supporting trust level will provide </p>
<pre>
    EVENT.Details.trustlevel|integer
</pre>
<p id="rfc.section.13.6.2.1.p.3">in an <samp>EVENT</samp> message sent to a <em>Subscriber</em>. The trustlevel <samp>0</samp> means lowest trust, and higher integers represent (application-defined) higher levels of trust.  </p>
<p><em>Example</em> </p>
<pre>
    [36, 5512315355, 4429313566, {"trustlevel": 2}, 
        ["Hello, world!"]]
</pre>
<p id="rfc.section.13.6.2.1.p.5">In above event, the <em>Broker</em> has (by configuration and/or other information) deemed the event publication to be of trustlevel <samp>2</samp>.  </p>
<h1 id="rfc.section.13.6.2.2"><a href="#rfc.section.13.6.2.2">13.6.2.2.</a> <a href="#feature-announcement-13" id="feature-announcement-13">Feature Announcement</a></h1>
<p id="rfc.section.13.6.2.2.p.1">Support for this feature MUST be announced by <em>Subscribers</em> (<samp>role := "subscriber"</samp>) and <em>Brokers</em> (<samp>role := "broker"</samp>) via </p>
<pre>
    HELLO.Details.roles.&lt;role&gt;.features.
        publication_trustlevels|bool := true
</pre>
<h1 id="rfc.section.13.6.3"><a href="#rfc.section.13.6.3">13.6.3.</a> <a href="#subscription-meta-api" id="subscription-meta-api">Subscription Meta API</a></h1>
<p id="rfc.section.13.6.3.p.1">Within an application, it may be desirable for a publisher to know whether a publication to a specific topic currently makes sense, i.e. whether there are any subscribers who would receive an event based on the publication. It may also be desirable to keep a current count of subscribers to a topic to then be able to filter out any subscribers who are not supposed to receive an event.  </p>
<p id="rfc.section.13.6.3.p.2">Subscription <em>meta-events</em> are fired when topics are first created, when clients subscribe/unsubscribe to them, and when topics are deleted. WAMP allows retrieving information about subscriptions via subscription <em>meta-procedures</em>.  </p>
<p id="rfc.section.13.6.3.p.3">Support for this feature MUST be announced by Brokers via </p>
<pre>
    HELLO.Details.roles.broker.features.subscription_meta_api|
        bool := true
</pre>
<p id="rfc.section.13.6.3.p.4">Meta-events are created by the router itself. This means that the events as well as the data received when calling a meta-procedure can be accorded the same trust level as the router.  </p>
<h1 id="rfc.section.13.6.3.1"><a href="#rfc.section.13.6.3.1">13.6.3.1.</a> <a href="#subscription-metaevents" id="subscription-metaevents">Subscription Meta-Events</a></h1>
<p id="rfc.section.13.6.3.1.p.1">A client can subscribe to the following session meta-events, which cover the lifecycle of a subscription: </p>
<p/>

<ul>
  <li><samp>wamp.subscription.on_create</samp>: Fired when a subscription is created through a subscription request for a topic which was previously without subscribers.</li>
  <li><samp>wamp.subscription.on_subscribe</samp>: Fired when a session is added to a subscription.</li>
  <li><samp>wamp.subscription.on_unsubscribe</samp>: Fired when a session is removed from a subscription.</li>
  <li><samp>wamp.subscription.on_delete</samp>: Fired when a subscription is deleted after the last session attached to it has been removed.</li>
</ul>

<p> </p>
<p id="rfc.section.13.6.3.1.p.3">A <samp>wamp.subscription.on_subscribe</samp> event MUST always be fired subsequent to a <samp>wamp.subscription.on_create</samp> event, since the first subscribe results in both the creation of the subscription and the addition of a session. Similarly, the <samp>wamp.subscription.on_delete</samp> event MUST always be preceded by a <samp>wamp.subscription.on_unsubscribe</samp> event.  </p>
<p id="rfc.section.13.6.3.1.p.4">The WAMP subscription meta events shall be dispatched by the router to the same realm as the WAMP session which triggered the event.  </p>
<h1 id="rfc.section.13.6.3.1.1"><a href="#rfc.section.13.6.3.1.1">13.6.3.1.1.</a> <a href="#metaevent-specifications" id="metaevent-specifications">Meta-Event Specifications</a></h1>
<h1 id="rfc.section.13.6.3.1.1.1"><a href="#rfc.section.13.6.3.1.1.1">13.6.3.1.1.1.</a> <a href="#wampsubscriptiononcreate" id="wampsubscriptiononcreate">wamp.subscription.on_create</a></h1>
<p id="rfc.section.13.6.3.1.1.1.p.1">Fired when a subscription is created through a subscription request for a topic which was previously without subscribers.  </p>
<p><strong>Event Arguments</strong> </p>
<p/>

<ul>
  <li><samp>session|id</samp>: ID of the session performing the subscription request.</li>
  <li><samp>SubscriptionDetails|dict</samp>: Information on the created subscription.</li>
</ul>

<p> </p>
<p><strong>Object Schemas</strong> </p>
<pre>
      SubscriptionDetails :=
      {
          "id": subscription|id,
          "created": time_created|iso_8601_string,
          "uri": topic|uri,
          "match": match_policy|string
      }
</pre>
<p id="rfc.section.13.6.3.1.1.1.p.5">See <a href="#pattern-based-subscriptions">Section 13.6.4</a> for a description of <samp>match_policy</samp>.  </p>
<h1 id="rfc.section.13.6.3.1.1.2"><a href="#rfc.section.13.6.3.1.1.2">13.6.3.1.1.2.</a> <a href="#wampsubscriptiononsubscribe" id="wampsubscriptiononsubscribe">wamp.subscription.on_subscribe</a></h1>
<p id="rfc.section.13.6.3.1.1.2.p.1">Fired when a session is added to a subscription.  </p>
<p><strong>Event Arguments</strong> </p>
<p/>

<ul>
  <li><samp>session|id</samp>: ID of the session being added to a subscription.</li>
  <li><samp>subscription|id</samp>: ID of the subscription to which the session is being added.</li>
</ul>

<p> </p>
<h1 id="rfc.section.13.6.3.1.1.3"><a href="#rfc.section.13.6.3.1.1.3">13.6.3.1.1.3.</a> <a href="#wampsubscriptiononunsubscribe" id="wampsubscriptiononunsubscribe">wamp.subscription.on_unsubscribe</a></h1>
<p id="rfc.section.13.6.3.1.1.3.p.1">Fired when a session is removed from a subscription.  </p>
<p><strong>Event Arguments</strong> </p>
<p/>

<ul>
  <li><samp>session|id</samp>: ID of the session being removed from a subscription.</li>
  <li><samp>subscription|id</samp>: ID of the subscription from which the session is being removed.</li>
</ul>

<p> </p>
<h1 id="rfc.section.13.6.3.1.1.4"><a href="#rfc.section.13.6.3.1.1.4">13.6.3.1.1.4.</a> <a href="#wampsubscriptionondelete" id="wampsubscriptionondelete">wamp.subscription.on_delete</a></h1>
<p id="rfc.section.13.6.3.1.1.4.p.1">Fired when a subscription is deleted after the last session attached to it has been removed.  </p>
<p><strong>Arguments</strong> </p>
<p/>

<ul>
  <li><samp>session|id</samp>: ID of the last session being removed from a subscription.</li>
  <li><samp>subscription|id</samp>: ID of the subscription being deleted.</li>
</ul>

<p> </p>
<h1 id="rfc.section.13.6.3.2"><a href="#rfc.section.13.6.3.2">13.6.3.2.</a> <a href="#subscription-metaprocedures" id="subscription-metaprocedures">Subscription Meta-Procedures</a></h1>
<p id="rfc.section.13.6.3.2.p.1">A client can actively retrieve information about subscriptions via the following meta-procedures: </p>
<p/>

<ul>
  <li><samp>wamp.subscription.list</samp>: Retrieves subscription IDs listed according to match policies.</li>
  <li><samp>wamp.subscription.lookup</samp>: Obtains the subscription (if any) managing a topic, according to some match policy.</li>
  <li><samp>wamp.subscription.match</samp>: Retrieves a list of IDs of subscriptions matching a topic URI, irrespective of match policy.</li>
  <li><samp>wamp.subscription.get</samp>: Retrieves information on a particular subscription.</li>
  <li><samp>wamp.subscription.list_subscribers</samp>: Retrieves a list of session IDs for sessions currently attached to the subscription.</li>
  <li><samp>wamp.subscription.count_subscribers</samp>: Obtains the number of sessions currently attached to the subscription.</li>
</ul>

<p> </p>
<h1 id="rfc.section.13.6.3.2.1"><a href="#rfc.section.13.6.3.2.1">13.6.3.2.1.</a> <a href="#metaprocedure-specifications" id="metaprocedure-specifications">Meta-Procedure Specifications</a></h1>
<h1 id="rfc.section.13.6.3.2.1.1"><a href="#rfc.section.13.6.3.2.1.1">13.6.3.2.1.1.</a> <a href="#wampsubscriptionlist" id="wampsubscriptionlist">wamp.subscription.list</a></h1>
<p id="rfc.section.13.6.3.2.1.1.p.1">Retrieves subscription IDs listed according to match policies.  </p>
<p><strong>Arguments</strong> </p>
<p/>

<ul>
  <li>None</li>
</ul>

<p> </p>
<p><strong>Results</strong> </p>
<p/>

<ul>
  <li><samp>SubscriptionLists|dict</samp>: A dictionary with a list of subscription IDs for each match policy.</li>
</ul>

<p> </p>
<p><strong>Object Schemas</strong> </p>
<pre>
      SubscriptionLists :=
      {
          "exact": subscription_ids|list,
          "prefix": subscription_ids|list,
          "wildcard": subscription_ids|list
      }
</pre>
<p id="rfc.section.13.6.3.2.1.1.p.7">See <a href="#pattern-based-subscriptions">Section 13.6.4</a> for information on match policies.  </p>
<h1 id="rfc.section.13.6.3.2.1.2"><a href="#rfc.section.13.6.3.2.1.2">13.6.3.2.1.2.</a> <a href="#wampsubscriptionlookup" id="wampsubscriptionlookup">wamp.subscription.lookup</a></h1>
<p id="rfc.section.13.6.3.2.1.2.p.1">Obtains the subscription (if any) managing a topic, according to some match policy.  </p>
<p><strong>Arguments</strong> </p>
<p/>

<ul>
  <li><samp>topic|uri</samp>: The URI of the topic.</li>
  <li>(Optional) <samp>options|dict</samp>: Same options as when subscribing to a topic.</li>
</ul>

<p> </p>
<p><strong>Results</strong> </p>
<p/>

<ul>
  <li>(Nullable) <samp>subscription|id</samp>: The ID of the subscription managing the topic, if found, or null.</li>
</ul>

<p> </p>
<h1 id="rfc.section.13.6.3.2.1.3"><a href="#rfc.section.13.6.3.2.1.3">13.6.3.2.1.3.</a> <a href="#wampsubscriptionmatch" id="wampsubscriptionmatch">wamp.subscription.match</a></h1>
<p id="rfc.section.13.6.3.2.1.3.p.1">Retrieves a list of IDs of subscriptions matching a topic URI, irrespective of match policy.  </p>
<p><strong>Arguments</strong> </p>
<p/>

<ul>
  <li><samp>topic|uri</samp>: The topic to match.</li>
</ul>

<p> </p>
<p><strong>Results</strong> </p>
<p/>

<ul>
  <li>(Nullable) <samp>subscription_ids|list</samp>: A list of all matching subscription IDs, or null.</li>
</ul>

<p> </p>
<h1 id="rfc.section.13.6.3.2.1.4"><a href="#rfc.section.13.6.3.2.1.4">13.6.3.2.1.4.</a> <a href="#wampsubscriptionget" id="wampsubscriptionget">wamp.subscription.get</a></h1>
<p id="rfc.section.13.6.3.2.1.4.p.1">Retrieves information on a particular subscription.  </p>
<p><strong>Arguments</strong> </p>
<p/>

<ul>
  <li><samp>subscription|id</samp>: The ID of the subscription to retrieve.</li>
</ul>

<p> </p>
<p><strong>Results</strong> </p>
<p/>

<ul>
  <li><samp>SubscriptionDetails|dict</samp>: Details on the subscription.</li>
</ul>

<p> </p>
<p><strong>Error URIs</strong> </p>
<p/>

<ul>
  <li><samp>wamp.error.no_such_subscription</samp>: No subscription with the given ID exists on the router.</li>
</ul>

<p> </p>
<p><strong>Object Schemas</strong> </p>
<pre>
      SubscriptionDetails :=
      {
          "id": subscription|id,
          "created": time_created|iso_8601_string,
          "uri": topic|uri,
          "match": match_policy|string
      }
</pre>
<p id="rfc.section.13.6.3.2.1.4.p.9">See <a href="#pattern-based-subscriptions">Section 13.6.4</a> for information on match policies.  </p>
<h1 id="rfc.section.13.6.3.2.1.5"><a href="#rfc.section.13.6.3.2.1.5">13.6.3.2.1.5.</a> <a href="#wampsubscriptionlistsubscribers" id="wampsubscriptionlistsubscribers">wamp.subscription.list_subscribers</a></h1>
<p id="rfc.section.13.6.3.2.1.5.p.1">Retrieves a list of session IDs for sessions currently attached to the subscription.  </p>
<p><strong>Arguments</strong> </p>
<p/>

<ul>
  <li><samp>subscription|id</samp>: The ID of the subscription to get subscribers for.</li>
</ul>

<p> </p>
<p><strong>Results</strong> </p>
<p/>

<ul>
  <li><samp>subscribers_ids|list</samp>: A list of WAMP session IDs of subscribers currently attached to the subscription.</li>
</ul>

<p> </p>
<p><strong>Error URIs</strong> </p>
<p/>

<ul>
  <li><samp>wamp.error.no_such_subscription</samp>: No subscription with the given ID exists on the router.</li>
</ul>

<p> </p>
<h1 id="rfc.section.13.6.3.2.1.6"><a href="#rfc.section.13.6.3.2.1.6">13.6.3.2.1.6.</a> <a href="#wampsubscriptioncountsubscribers" id="wampsubscriptioncountsubscribers">wamp.subscription.count_subscribers</a></h1>
<p id="rfc.section.13.6.3.2.1.6.p.1">Obtains the number of sessions currently attached to a subscription.  </p>
<p><strong>Arguments</strong> </p>
<p/>

<ul>
  <li><samp>subscription|id</samp>: The ID of the subscription to get the number of subscribers for.</li>
</ul>

<p> </p>
<p><strong>Results</strong> </p>
<p/>

<ul>
  <li><samp>count|int</samp>: The number of sessions currently attached to a subscription.</li>
</ul>

<p> </p>
<p><strong>Error URIs</strong> </p>
<p/>

<ul>
  <li><samp>wamp.error.no_such_subscription</samp>: No subscription with the given ID exists on the router.</li>
</ul>

<p> </p>
<h1 id="rfc.section.13.6.4"><a href="#rfc.section.13.6.4">13.6.4.</a> <a href="#pattern-based-subscriptions" id="pattern-based-subscriptions">Pattern-based Subscriptions</a></h1>
<h1 id="rfc.section.13.6.4.1"><a href="#rfc.section.13.6.4.1">13.6.4.1.</a> <a href="#introdution" id="introdution">Introdution</a></h1>
<p id="rfc.section.13.6.4.1.p.1">By default, <em>Subscribers</em> subscribe to topics with <strong>exact matching policy</strong>. That is an event will only be dispatched to a <em>Subscriber</em> by the <em>Broker</em> if the topic published to (<samp>PUBLISH.Topic</samp>) <em>exactly</em> matches the topic subscribed to (<samp>SUBSCRIBE.Topic</samp>).  </p>
<p id="rfc.section.13.6.4.1.p.2">A <em>Subscriber</em> might want to subscribe to topics based on a <em>pattern</em>. This can be useful to reduce the number of individual subscriptions to be set up and to subscribe to topics the <em>Subscriber</em> is not aware of at the time of subscription, or which do not yet exist at this time.  </p>
<p id="rfc.section.13.6.4.1.p.3">If the <em>Broker</em> and the <em>Subscriber</em> support <strong>pattern-based subscriptions</strong>, this matching can happen by </p>
<p/>

<ul>
  <li>prefix-matching policy</li>
  <li>wildcard-matching policy</li>
</ul>

<p> </p>
<h1 id="rfc.section.13.6.4.2"><a href="#rfc.section.13.6.4.2">13.6.4.2.</a> <a href="#prefix-matching-1" id="prefix-matching-1">Prefix Matching</a></h1>
<p id="rfc.section.13.6.4.2.p.1">A <em>Subscriber</em> requests <strong>prefix-matching policy</strong> with a subscription request by setting </p>
<pre>
    SUBSCRIBE.Options.match|string := "prefix"
</pre>
<p><em>Example</em> </p>
<pre>
    [
        32,
        912873614,
        {
            "match": "prefix"
        },
        "com.myapp.topic.emergency"
    ]
</pre>
<p id="rfc.section.13.6.4.2.p.3">When a <strong>prefix-matching policy</strong> is in place, any event with a topic that has <samp>SUBSCRIBE.Topic</samp> as a <em>prefix</em> will match the subscription, and potentially be delivered to <em>Subscribers</em> on the subscription.  </p>
<p id="rfc.section.13.6.4.2.p.4">In the above example, events with <samp>PUBLISH.Topic</samp> </p>
<p/>

<ul>
  <li>
    <samp>com.myapp.topic.emergency.11</samp>
  </li>
  <li>
    <samp>com.myapp.topic.emergency-low</samp>
  </li>
  <li>
    <samp>com.myapp.topic.emergency.category.severe</samp>
  </li>
  <li>
    <samp>com.myapp.topic.emergency</samp>
  </li>
</ul>

<p> </p>
<p id="rfc.section.13.6.4.2.p.6">will all apply for dispatching. An event with <samp>PUBLISH.Topic</samp> e.g. <samp>com.myapp.topic.emerge</samp> will not apply.  </p>
<h1 id="rfc.section.13.6.4.3"><a href="#rfc.section.13.6.4.3">13.6.4.3.</a> <a href="#wildcard-matching-1" id="wildcard-matching-1">Wildcard Matching</a></h1>
<p id="rfc.section.13.6.4.3.p.1">A <em>Subscriber</em> requests <strong>wildcard-matching policy</strong> with a subscription request by setting </p>
<pre>
    SUBSCRIBE.Options.match|string := "wildcard"
</pre>
<p id="rfc.section.13.6.4.3.p.2">Wildcard-matching allows to provide wildcards for <strong>whole</strong> URI components.  </p>
<p><em>Example</em> </p>
<pre>
    [
        32,
        912873614,
        {
            "match": "wildcard"
        },
        "com.myapp..userevent"
    ]
</pre>
<p id="rfc.section.13.6.4.3.p.4">In above subscription request, the 3rd URI component is empty, which signals a wildcard in that URI component position. In this example, events with <samp>PUBLISH.Topic</samp> </p>
<p/>

<ul>
  <li>
    <samp>com.myapp.foo.userevent</samp>
  </li>
  <li>
    <samp>com.myapp.bar.userevent</samp>
  </li>
  <li>
    <samp>com.myapp.a12.userevent</samp>
  </li>
</ul>

<p> </p>
<p id="rfc.section.13.6.4.3.p.6">will all apply for dispatching. Events with <samp>PUBLISH.Topic</samp> </p>
<p/>

<ul>
  <li>
    <samp>com.myapp.foo.userevent.bar</samp>
  </li>
  <li>
    <samp>com.myapp.foo.user</samp>
  </li>
  <li>
    <samp>com.myapp2.foo.userevent</samp>
  </li>
</ul>

<p> </p>
<p id="rfc.section.13.6.4.3.p.8">will not apply for dispatching.  </p>
<h1 id="rfc.section.13.6.4.4"><a href="#rfc.section.13.6.4.4">13.6.4.4.</a> <a href="#general-1" id="general-1">General</a></h1>
<h1 id="rfc.section.13.6.4.4.1"><a href="#rfc.section.13.6.4.4.1">13.6.4.4.1.</a> <a href="#no-set-semantics-1" id="no-set-semantics-1">No set semantics</a></h1>
<p id="rfc.section.13.6.4.4.1.p.1">Since each <em>Subscriber's</em> subscription "stands on its own", there is no <em>set semantics</em> implied by pattern-based subscriptions.  </p>
<p id="rfc.section.13.6.4.4.1.p.2">E.g. a <em>Subscriber</em> cannot subscribe to a broad pattern, and then unsubscribe from a subset of that broad pattern to form a more complex subscription. Each subscription is separate.  </p>
<h1 id="rfc.section.13.6.4.4.2"><a href="#rfc.section.13.6.4.4.2">13.6.4.4.2.</a> <a href="#events-matching-multiple-subscriptions" id="events-matching-multiple-subscriptions">Events matching multiple subscriptions</a></h1>
<p id="rfc.section.13.6.4.4.2.p.1">When a single event matches more than one of a <em>Subscriber's</em> subscriptions, the event will be delivered for each subscription.  </p>
<p id="rfc.section.13.6.4.4.2.p.2">The <em>Subscriber</em> can detect the delivery of that same event on multiple subscriptions via <samp>EVENT.PUBLISHED.Publication</samp>, which will be identical.  </p>
<h1 id="rfc.section.13.6.4.4.3"><a href="#rfc.section.13.6.4.4.3">13.6.4.4.3.</a> <a href="#concrete-topic-published-to" id="concrete-topic-published-to">Concrete topic published to</a></h1>
<p id="rfc.section.13.6.4.4.3.p.1">If a subscription was established with a pattern-based matching policy, a <em>Broker</em> MUST supply the original <samp>PUBLISH.Topic</samp> as provided by the <em>Publisher</em> in </p>
<pre>
    EVENT.Details.topic|uri
</pre>
<p id="rfc.section.13.6.4.4.3.p.2">to the <em>Subscribers</em>.  </p>
<p><em>Example</em> </p>
<pre>
    [
        36,
        5512315355,
        4429313566,
        {
            "topic": "com.myapp.topic.emergency.category.severe"
        },
        ["Hello, world!"]
    ]
</pre>
<h1 id="rfc.section.13.6.4.5"><a href="#rfc.section.13.6.4.5">13.6.4.5.</a> <a href="#feature-announcement-14" id="feature-announcement-14">Feature Announcement</a></h1>
<p id="rfc.section.13.6.4.5.p.1">Support for this feature MUST be announced by <em>Subscribers</em> (<samp>role := "subscriber"</samp>) and <em>Brokers</em> (<samp>role := "broker"</samp>) via </p>
<pre>
    HELLO.Details.roles.&lt;role&gt;.features.
        pattern_based_subscription|bool := true
</pre>
<h1 id="rfc.section.13.6.5"><a href="#rfc.section.13.6.5">13.6.5.</a> <a href="#sharded-subscriptions" id="sharded-subscriptions">Sharded Subscriptions</a></h1>
<p id="rfc.section.13.6.5.p.1">Feature status: <strong>alpha</strong> </p>
<p id="rfc.section.13.6.5.p.2">Support for this feature MUST be announced by <em>Publishers</em> (<samp>role := "publisher"</samp>), <em>Subscribers</em> (<samp>role := "subscriber"</samp>) and <em>Brokers</em> (<samp>role := "broker"</samp>) via </p>
<pre>
    HELLO.Details.roles.&lt;role&gt;.features.shareded_subscriptions|
        bool := true
</pre>
<p id="rfc.section.13.6.5.p.3">Resource keys: <samp>PUBLISH.Options.rkey|string</samp> is a stable, technical <strong>resource key</strong>.  </p>
<p/>

<ul class="empty">
  <li>E.g. if your sensor has a unique serial identifier, you can use that.  </li>
</ul>
<p><em>Example</em> </p>
<pre>
    [16, 239714735, {"rkey": "sn239019"}, "com.myapp.sensor.sn239019. 
        temperature", [33.9]]
</pre>
<p id="rfc.section.13.6.5.p.6">Node keys: <samp>SUBSCRIBE.Options.nkey|string</samp> is a stable, technical <strong>node key</strong>.  </p>
<p/>

<ul class="empty">
  <li>E.g. if your backend process runs on a dedicated host, you can use its hostname.  </li>
</ul>
<p><em>Example</em> </p>
<pre>
    [32, 912873614, {"match": "wildcard", "nkey": "node23"}, 
        "com.myapp.sensor..temperature"]
</pre>
<h1 id="rfc.section.13.6.6"><a href="#rfc.section.13.6.6">13.6.6.</a> <a href="#event-history" id="event-history">Event History</a></h1>
<h1 id="rfc.section.13.6.6.1"><a href="#rfc.section.13.6.6.1">13.6.6.1.</a> <a href="#feature-definition-14" id="feature-definition-14">Feature Definition</a></h1>
<p id="rfc.section.13.6.6.1.p.1">Instead of complex QoS for message delivery, a <em>Broker</em> may provide <em>message history</em>. A <em>Subscriber</em> is responsible to handle overlaps (duplicates) when it wants "exactly-once" message processing across restarts.  </p>
<p id="rfc.section.13.6.6.1.p.2">The <em>Broker</em> may allow for configuration on a per-topic basis.  </p>
<p id="rfc.section.13.6.6.1.p.3">The event history may be transient or persistent message history (surviving <em>Broker</em> restarts).  </p>
<p id="rfc.section.13.6.6.1.p.4">A <em>Broker</em> that implements <em>event history</em> must (also) announce role <samp>HELLO.roles.callee</samp>, indicate <samp>HELLO.roles.broker.history == 1</samp> and provide the following (builtin) procedures.  </p>
<p id="rfc.section.13.6.6.1.p.5">A <em>Caller</em> can request message history by calling the <em>Broker</em> procedure </p>
<pre>
    wamp.topic.history.last
</pre>
<p id="rfc.section.13.6.6.1.p.6">with <samp>Arguments = [topic|uri, limit|integer]</samp> where </p>
<p/>

<ul>
  <li><samp>topic</samp> is the topic to retrieve event history for</li>
  <li><samp>limit</samp> indicates the number of last N events to retrieve</li>
</ul>

<p> </p>
<p id="rfc.section.13.6.6.1.p.8">or by calling </p>
<pre>
    wamp.topic.history.since
</pre>
<p id="rfc.section.13.6.6.1.p.9">with <samp>Arguments = [topic|uri, timestamp|string]</samp> where </p>
<p/>

<ul>
  <li><samp>topic</samp> is the topic to retrieve event history for</li>
  <li><samp>timestamp</samp> indicates the UTC timestamp since when to retrieve the events in the ISO-8601 format <samp>yyyy-MM-ddThh:mm:ss:SSSZ</samp> (e.g. <samp>"2013-12-21T13:43:11:000Z"</samp>)</li>
</ul>

<p> </p>
<p id="rfc.section.13.6.6.1.p.11">or by calling </p>
<pre>
    wamp.topic.history.after
</pre>
<p id="rfc.section.13.6.6.1.p.12">with <samp>Arguments = [topic|uri, publication|id]</samp> </p>
<p/>

<ul>
  <li><samp>topic</samp> is the topic to retrieve event history for</li>
  <li><samp>publication</samp> is the id of an event which marks the start of the events to retrieve from history</li>
</ul>

<p> </p>
<p><em>FIXME</em> </p>
<p/>

<ol>
  <li>Should we use <samp>topic|uri</samp> or <samp>subscription|id</samp> in <samp>Arguments</samp>? <ul><li>Since we need to be able to get history for pattern-based subscriptions as well, a subscription|id makes more sense: create pattern-based subscription, then get the event history for this.</li><li>The only restriction then is that we may not get event history without a current subscription covering the events. This is a minor inconvenience at worst.</li></ul></li>
  <li>Can <samp>wamp.topic.history.after</samp> be implemented (efficiently) at all?</li>
  <li>How does that interact with pattern-based subscriptions?</li>
  <li>The same question as with the subscriber lists applies where: to stay within our separation of roles, we need a broker + a separate peer which implements the callee role. Here we do not have a mechanism to get the history from the broker.</li>
</ol>

<p> </p>
<h1 id="rfc.section.13.6.6.2"><a href="#rfc.section.13.6.6.2">13.6.6.2.</a> <a href="#feature-announcement-15" id="feature-announcement-15">Feature Announcement</a></h1>
<p id="rfc.section.13.6.6.2.p.1">Support for this feature MUST be announced by <em>Subscribers</em> (<samp>role := "subscriber"</samp>) and <em>Brokers</em> (<samp>role := "broker"</samp>) via </p>
<pre>
    HELLO.Details.roles.&lt;role&gt;.features.event_history|bool := true
</pre>
<h1 id="rfc.section.13.6.7"><a href="#rfc.section.13.6.7">13.6.7.</a> <a href="#registration-revocation-1" id="registration-revocation-1">Registration Revocation</a></h1>
<h1 id="rfc.section.13.6.7.1"><a href="#rfc.section.13.6.7.1">13.6.7.1.</a> <a href="#feature-definition-15" id="feature-definition-15">Feature Definition</a></h1>
<p id="rfc.section.13.6.7.1.p.1">Actively and forcefully revoke a previously granted subscription from a session.  </p>
<h1 id="rfc.section.13.6.7.2"><a href="#rfc.section.13.6.7.2">13.6.7.2.</a> <a href="#feature-announcement-16" id="feature-announcement-16">Feature Announcement</a></h1>
<h1 id="rfc.section.13.6.8"><a href="#rfc.section.13.6.8">13.6.8.</a> <a href="#topic-reflection" id="topic-reflection">Topic Reflection</a></h1>
<p/>

<ul>
  <li>see <strong>Procedure Reflection</strong> for now</li>
</ul>

<p> </p>
<h1 id="rfc.section.13.7"><a href="#rfc.section.13.7">13.7.</a> <a href="#other-advanced-features-1" id="other-advanced-features-1">Other Advanced Features</a></h1>
<h1 id="rfc.section.13.7.1"><a href="#rfc.section.13.7.1">13.7.1.</a> <a href="#session-meta-api" id="session-meta-api">Session Meta API</a></h1>
<h1 id="rfc.section.13.7.1.1"><a href="#rfc.section.13.7.1.1">13.7.1.1.</a> <a href="#introduction-4" id="introduction-4">Introduction</a></h1>
<p id="rfc.section.13.7.1.1.p.1">WAMP enables the monitoring of when sessions join a realm on the router or when they leave it via <strong>Session Meta Events</strong>. It also allows retrieving information about currently connected sessions via <strong>Session Meta Procedures</strong>.  </p>
<p id="rfc.section.13.7.1.1.p.2">Meta events are created by the router itself. This means that the events, as well as the data received when calling a meta procedure, can be accorded the same trust level as the router.  </p>
<p/>

<ul class="empty">
  <li>Note that an implementation that only supports a <em>Broker</em> or <em>Dealer</em> role, not both at the same time, essentially cannot offer the <strong>Session Meta API</strong>, as it requires both roles to support this feature.  </li>
</ul>
<h1 id="rfc.section.13.7.1.2"><a href="#rfc.section.13.7.1.2">13.7.1.2.</a> <a href="#session-meta-events" id="session-meta-events">Session Meta Events</a></h1>
<p id="rfc.section.13.7.1.2.p.1">A client can subscribe to the following session meta-events, which cover the lifecycle of a session: </p>
<p/>

<ul>
  <li><samp>wamp.session.on_join</samp>: Fired when a session joins a realm on the router.</li>
  <li><samp>wamp.session.on_leave</samp>: Fired when a session leaves a realm on the router or is disconnected.</li>
</ul>

<p> </p>
<p><strong>Session Meta Events</strong> MUST be dispatched by the <em>Router</em> to the same realm as the WAMP session which triggered the event.  </p>
<h1 id="rfc.section.13.7.1.2.1"><a href="#rfc.section.13.7.1.2.1">13.7.1.2.1.</a> <a href="#wampsessiononjoin" id="wampsessiononjoin">wamp.session.on_join</a></h1>
<p id="rfc.section.13.7.1.2.1.p.1">Fired when a session joins a realm on the router. The event payload consists of a single positional argument <samp>details|dict</samp>: </p>
<p/>

<ul>
  <li><samp>session|id</samp> - The session ID of the session that joined</li>
  <li><samp>authid|string</samp> - The authentication ID of the session that joined</li>
  <li><samp>authrole|string</samp> - The authentication role of the session that joined</li>
  <li><samp>authmethod|string</samp> - The authentication method that was used for authentication the session that joined</li>
  <li><samp>authprovider|string</samp>- The provider that performed the authentication of the session that joined</li>
  <li><samp>transport|dict</samp> - Optional, implementation defined information about the WAMP transport the joined session is running over.</li>
</ul>

<p> </p>
<p/>

<ul class="empty">
  <li>See <strong>Authentication</strong> for a description of the <samp>authid</samp>, <samp>authrole</samp>, <samp>authmethod</samp> and <samp>authprovider</samp> properties.  </li>
</ul>
<h1 id="rfc.section.13.7.1.2.2"><a href="#rfc.section.13.7.1.2.2">13.7.1.2.2.</a> <a href="#wampsessiononleave" id="wampsessiononleave">wamp.session.on_leave</a></h1>
<p id="rfc.section.13.7.1.2.2.p.1">Fired when a session leaves a realm on the router or is disconnected. The event payload consists of a single positional argument <samp>session|id</samp> with the session ID of the session that left.  </p>
<h1 id="rfc.section.13.7.1.3"><a href="#rfc.section.13.7.1.3">13.7.1.3.</a> <a href="#session-meta-procedures" id="session-meta-procedures">Session Meta Procedures</a></h1>
<p id="rfc.section.13.7.1.3.p.1">A client can actively retrieve information about sessions via the following meta-procedures: </p>
<p/>

<ul>
  <li><samp>wamp.session.count</samp>: Obtains the number of sessions currently attached to the realm.</li>
  <li><samp>wamp.session.list</samp>: Retrieves a list of the session IDs for all sessions currently attached to the realm.</li>
  <li><samp>wamp.session.get</samp>: Retrieves information on a specific session.</li>
</ul>

<p> </p>
<p id="rfc.section.13.7.1.3.p.3">Session meta procedures MUST be registered by the <em>Router</em> on the same realm as the WAMP session about which information is retrieved.  </p>
<h1 id="rfc.section.13.7.1.3.1"><a href="#rfc.section.13.7.1.3.1">13.7.1.3.1.</a> <a href="#wampsessioncount" id="wampsessioncount">wamp.session.count</a></h1>
<p id="rfc.section.13.7.1.3.1.p.1">Obtains the number of sessions currently attached to the realm: </p>
<p><strong>Positional arguments</strong> </p>
<p/>

<ol>
  <li><samp>filter_authroles|list[string]</samp> - Optional filter: if provided, only count sessions with an <samp>authrole</samp> from this list.</li>
</ol>

<p> </p>
<p><strong>Positional results</strong> </p>
<p/>

<ol>
  <li><samp>count|int</samp> - The number of sessions currently attached to the realm.</li>
</ol>

<p> </p>
<h1 id="rfc.section.13.7.1.3.2"><a href="#rfc.section.13.7.1.3.2">13.7.1.3.2.</a> <a href="#wampsessionlist" id="wampsessionlist">wamp.session.list</a></h1>
<p id="rfc.section.13.7.1.3.2.p.1">Retrieves a list of the session IDs for all sessions currently attached to the realm.  </p>
<p><strong>Positional arguments</strong> </p>
<p/>

<ol>
  <li><samp>filter_authroles|list[string]</samp> - Optional filter: if provided, only count sessions with an <samp>authrole</samp> from this list.</li>
</ol>

<p> </p>
<p><strong>Positional results</strong> </p>
<p/>

<ol>
  <li><samp>session_ids|list</samp> - List of WAMP session IDs (order undefined).</li>
</ol>

<p> </p>
<h1 id="rfc.section.13.7.1.3.3"><a href="#rfc.section.13.7.1.3.3">13.7.1.3.3.</a> <a href="#wampsessionget" id="wampsessionget">wamp.session.get</a></h1>
<p id="rfc.section.13.7.1.3.3.p.1">Retrieves information on a specific session.  </p>
<p><strong>Positional arguments</strong> </p>
<p/>

<ol>
  <li><samp>session|id</samp> - The session ID of the session to retrieve details for.</li>
</ol>

<p> </p>
<p><strong>Positional results</strong> </p>
<p/>

<ol>
  <li><samp>details|dict</samp> - Information on a particular session: <ul><li><samp>session|id</samp> - The session ID of the session that joined</li><li><samp>authid|string</samp> - The authentication ID of the session that joined</li><li><samp>authrole|string</samp> - The authentication role of the session that joined</li><li><samp>authmethod|string</samp> - The authentication method that was used for authentication the session that joined</li><li><samp>authprovider|string</samp>- The provider that performed the authentication of the session that joined</li><li><samp>transport|dict</samp> - Optional, implementation defined information about the WAMP transport the joined session is running over.</li></ul></li>
</ol>

<p> </p>
<p/>

<ul class="empty">
  <li>See <strong>Authentication</strong> for a description of the <samp>authid</samp>, <samp>authrole</samp>, <samp>authmethod</samp> and <samp>authprovider</samp> properties.  </li>
</ul>
<p><strong>Errors</strong> </p>
<p/>

<ul>
  <li><samp>wamp.error.no_such_session</samp> - No session with the given ID exists on the router.</li>
</ul>

<p> </p>
<h1 id="rfc.section.13.7.1.4"><a href="#rfc.section.13.7.1.4">13.7.1.4.</a> <a href="#feature-announcement-17" id="feature-announcement-17">Feature Announcement</a></h1>
<p id="rfc.section.13.7.1.4.p.1">Support for this feature MUST be announced by <strong>both</strong> <em>Dealers</em> and <em>Brokers</em> via: </p>
<pre>
    HELLO.Details.roles.&lt;role&gt;.features.
        session_meta_api|bool := true
</pre>
<p><strong>Example</strong> </p>
<p id="rfc.section.13.7.1.4.p.3">Here is a <samp>WELCOME</samp> message from a <em>Router</em> with support for both the <em>Broker</em> and <em>Dealer</em> role, and with support for <strong>Session Meta API</strong>: </p>
<pre>
    [
        2,
        4580268554656113,
        {
            "authid":"OL3AeppwDLXiAAPbqm9IVhnw",
            "authrole": "anonymous",
            "authmethod": "anonymous",
            "roles": {
                "broker": {
                    "features": {
                        "session_meta_api": true
                    }
                },
                "dealer": {
                    "features": {
                        "session_meta_api": true
                    }
                }
            }
        }
    ]
</pre>
<p/>

<ul class="empty">
  <li>Note in particular that the feature is announced on both the <em>Broker</em> and the <em>Dealer</em> roles.  </li>
</ul>
<h1 id="rfc.section.13.7.2"><a href="#rfc.section.13.7.2">13.7.2.</a> <a href="#authentication" id="authentication">Authentication</a></h1>
<p id="rfc.section.13.7.2.p.1">Authentication is a complex area.  </p>
<p id="rfc.section.13.7.2.p.2">Some applications might want to leverage authentication information coming from the transport underlying WAMP, e.g. HTTP cookies or TLS certificates.  </p>
<p id="rfc.section.13.7.2.p.3">Some transports might imply trust or implicit authentication by their very nature, e.g. Unix domain sockets with appropriate file system permissions in place.  </p>
<p id="rfc.section.13.7.2.p.4">Other application might want to perform their own authentication using external mechanisms (completely outside and independent of WAMP).  </p>
<p id="rfc.section.13.7.2.p.5">Some applications might want to perform their own authentication schemes by using basic WAMP mechanisms, e.g. by using application-defined remote procedure calls.  </p>
<p id="rfc.section.13.7.2.p.6">And some applications might want to use a transport independent scheme, nevertheless predefined by WAMP.  </p>
<h1 id="rfc.section.13.7.2.1"><a href="#rfc.section.13.7.2.1">13.7.2.1.</a> <a href="#wamplevel-authentication" id="wamplevel-authentication">WAMP-level Authentication</a></h1>
<p id="rfc.section.13.7.2.1.p.1">The message flow between Clients and Routers for establishing and tearing down sessions MAY involve the following messages which authenticate a session: </p>
<p/>

<ol>
  <li>
    <samp>CHALLENGE</samp>
  </li>
  <li>
    <samp>AUTHENTICATE</samp>
  </li>
</ol>

<p> </p>
<pre>
     ,------.          ,------.
     |Client|          |Router|
     `--+---'          `--+---'
        |      HELLO      |    
        | ----------------&gt;    
        |                 |    
        |    CHALLENGE    |    
        | &lt;----------------    
        |                 |    
        |   AUTHENTICATE  |    
        | ----------------&gt;    
        |                 |    
        | WELCOME or ABORT|    
        | &lt;----------------    
     ,--+---.          ,--+---.
     |Client|          |Router|
     `------'          `------'
</pre>
<p id="rfc.section.13.7.2.1.p.3">Concrete use of <samp>CHALLENGE</samp> and <samp>AUTHENTICATE</samp> messages depends on the specific authentication method.  </p>
<p id="rfc.section.13.7.2.1.p.4">See <a href="#wampcra">Section 13.7.2.3</a> or <a href="#ticketauth">Section 13.7.2.4</a> for the use in these authentication methods.  </p>
<p id="rfc.section.13.7.2.1.p.5">If two-factor authentication is desired, then two subsequent rounds of <samp>CHALLENGE</samp> and <samp>RESPONSE</samp> may be employed.  </p>
<h1 id="rfc.section.13.7.2.1.1"><a href="#rfc.section.13.7.2.1.1">13.7.2.1.1.</a> <a href="#challenge-1" id="challenge-1">CHALLENGE</a></h1>
<p id="rfc.section.13.7.2.1.1.p.1">An authentication MAY be required for the establishment of a session. Such requirement MAY be based on the <samp>Realm</samp> the connection is requested for.  </p>
<p id="rfc.section.13.7.2.1.1.p.2">To request authentication, the Router MUST send a <samp>CHALLENGE</samp> message to the <em>Endpoint</em>.  </p>
<pre>
    [CHALLENGE, AuthMethod|string, Extra|dict]
</pre>
<h1 id="rfc.section.13.7.2.1.2"><a href="#rfc.section.13.7.2.1.2">13.7.2.1.2.</a> <a href="#authenticate-1" id="authenticate-1">AUTHENTICATE</a></h1>
<p id="rfc.section.13.7.2.1.2.p.1">In response to a <samp>CHALLENGE</samp> message, the Client MUST send an <samp>AUTHENTICATION</samp> message.  </p>
<pre>
    [AUTHENTICATE, Signature|string, Extra|dict]
</pre>
<p id="rfc.section.13.7.2.1.2.p.2">If the authentication succeeds, the Router MUST send a <samp>WELCOME</samp> message, else it MUST send an <samp>ABORT</samp> message.  </p>
<h1 id="rfc.section.13.7.2.2"><a href="#rfc.section.13.7.2.2">13.7.2.2.</a> <a href="#transportlevel-authentication" id="transportlevel-authentication">Transport-level Authentication</a></h1>
<h1 id="rfc.section.13.7.2.2.1"><a href="#rfc.section.13.7.2.2.1">13.7.2.2.1.</a> <a href="#cookiebased-authentication" id="cookiebased-authentication">Cookie-based Authentication</a></h1>
<p id="rfc.section.13.7.2.2.1.p.1">When running WAMP over WebSocket, the transport provides HTTP client cookies during the WebSocket opening handshake. The cookies can be used to authenticate one peer (the client) against the other (the server). The other authentication direction cannot be supported by cookies.  </p>
<p id="rfc.section.13.7.2.2.1.p.2">This transport-level authentication information may be forward to the WAMP level within <samp>HELLO.Details.transport.auth|any</samp> in the client-to-server direction.  </p>
<h1 id="rfc.section.13.7.2.2.2"><a href="#rfc.section.13.7.2.2.2">13.7.2.2.2.</a> <a href="#tls-certificate-authentication" id="tls-certificate-authentication">TLS Certificate Authentication</a></h1>
<p id="rfc.section.13.7.2.2.2.p.1">When running WAMP over a TLS (either secure WebSocket or raw TCP) transport, a peer may authenticate to the other via the TLS certificate mechanism. A server might authenticate to the client, and a client may authenticate to the server (TLS client-certificate based authentication).  </p>
<p id="rfc.section.13.7.2.2.2.p.2">This transport-level authentication information may be forward to the WAMP level within <samp>HELLO.Details.transport.auth|any</samp> in both directions (if available).  </p>
<h1 id="rfc.section.13.7.2.3"><a href="#rfc.section.13.7.2.3">13.7.2.3.</a> <a href="#wampcra" id="wampcra">Challenge Response Authentication</a></h1>
<p id="rfc.section.13.7.2.3.p.1">WAMP Challenge-Response ("WAMP-CRA") authentication is a simple, secure authentication mechanism using a shared secret. The client and the server share a secret. The secret never travels the wire, hence WAMP-CRA can be used via non-TLS connections. The actual pre-sharing of the secret is outside the scope of the authentication mechanism.  </p>
<p id="rfc.section.13.7.2.3.p.2">A typical authentication begins with the client sending a <samp>HELLO</samp> message specifying the <samp>wampcra</samp> method as (one of) the authentication methods: </p>
<pre>
    [1, "realm1",
        {
            "roles": ...,
            "authmethods": ["wampcra"],
            "authid": "peter"
        }
    ]
</pre>
<p id="rfc.section.13.7.2.3.p.3">The <samp>HELLO.Details.authmethods|list</samp> is used by the client to announce the authentication methods it is prepared to perform. For WAMP-CRA, this MUST include <samp>"wampcra"</samp>.  </p>
<p id="rfc.section.13.7.2.3.p.4">The <samp>HELLO.Details.authid|string</samp> is the authentication ID (e.g. username) the client wishes to authenticate as. For WAMP-CRA, this MUST be provided.  </p>
<p id="rfc.section.13.7.2.3.p.5">If the server is unwilling or unable to perform WAMP-CRA authentication, it MAY either skip forward trying other authentication methods (if the client announced any) or send an <samp>ABORT</samp> message.  </p>
<p id="rfc.section.13.7.2.3.p.6">If the server is willing to let the client authenticate using WAMP-CRA, and the server recognizes the provided <samp>authid</samp>, it MUST send a <samp>CHALLENGE</samp> message: </p>
<pre>
    [4, "wampcra",
        {
            "challenge": "{ \"nonce\": \"LHRTC9zeOIrt_9U3\", 
                \"authprovider\": \"userdb\", \"authid\": \"peter\",
                \"timestamp\": \"2014-06-22T16:36:25.448Z\", 
                \"authrole\": \"user\", \"authmethod\": \"wampcra\", 
                \"session\": 3251278072152162}"
        }
    ]
</pre>
<p id="rfc.section.13.7.2.3.p.7">The <samp>CHALLENGE.Details.challenge|string</samp> is a string the client needs to create a signature for. The string MUST BE a JSON serialized object which MUST contain: </p>
<p/>

<ol>
  <li><samp>authid|string</samp>: The authentication ID the client will be authenticated as when the authentication succeeds.</li>
  <li><samp>authrole|string</samp>: The authentication role the client will be authenticated as when the authentication succeeds.</li>
  <li><samp>authmethod|string</samp>: The authentication methods, here <samp>"wampcra"</samp></li>
  <li><samp>authprovider|string</samp>: The actual provider of authentication. For WAMP-CRA, this can be freely chosen by the app, e.g. <samp>userdb</samp>.</li>
  <li><samp>nonce|string</samp>: A random value.</li>
  <li><samp>timestamp|string</samp>: The UTC timestamp (ISO8601 format) the authentication was started, e.g. <samp>2014-06-22T16:51:41.643Z</samp>.</li>
  <li><samp>session|int</samp>: The WAMP session ID that will be assigned to the session once it is authenticated successfully.</li>
</ol>

<p> </p>
<p id="rfc.section.13.7.2.3.p.9">The client needs to compute the signature as follows: </p>
<pre>
    signature := HMAC[SHA256]_{secret} (challenge)
</pre>
<p id="rfc.section.13.7.2.3.p.10">That is, compute the HMAC-SHA256 using the shared <samp>secret</samp> over the <samp>challenge</samp>.  </p>
<p id="rfc.section.13.7.2.3.p.11">After computing the signature, the client will send an <samp>AUTHENTICATE</samp> message containing the signature: </p>
<pre>
    [5, "gir1mSx+deCDUV7wRM5SGIn/+R/ClqLZuH4m7FJeBVI=", {}]
</pre>
<p id="rfc.section.13.7.2.3.p.12">The server will then check if </p>
<p/>

<ul>
  <li>the signature matches the one expected</li>
  <li>the <samp>AUTHENTICATE</samp> message was sent in due time</li>
</ul>

<p> </p>
<p id="rfc.section.13.7.2.3.p.14">If the authentication succeeds, the server will finally respond with a <samp>WELCOME</samp> message: </p>
<pre>
    [2, 3251278072152162,
        {
            "authid": "peter",
            "authrole": "user",
            "authmethod": "wampcra",
            "authprovider": "userdb",
            "roles": ...
        }
    ]
</pre>
<p id="rfc.section.13.7.2.3.p.15">The <samp>WELCOME.Details</samp> again contain the actual authentication information active.  </p>
<p id="rfc.section.13.7.2.3.p.16">If the authentication fails, the server will response with an <samp>ABORT</samp> message.  </p>
<h1 id="rfc.section.13.7.2.3.1"><a href="#rfc.section.13.7.2.3.1">13.7.2.3.1.</a> <a href="#serverside-verification" id="serverside-verification">Server-side Verification</a></h1>
<p id="rfc.section.13.7.2.3.1.p.1">The challenge sent during WAMP-CRA contains </p>
<p/>

<ol>
  <li>random information (the <samp>nonce</samp>) to make WAMP-CRA robust against replay attacks</li>
  <li>timestamp information (the <samp>timestamp</samp>) to allow WAMP-CRA timeout on authentication requests that took too long</li>
  <li>session information (the <samp>session</samp>) to bind the authentication to a WAMP session ID</li>
  <li>all the authentication information that relates to authorization like <samp>authid</samp> and <samp>authrole</samp></li>
</ol>

<p> </p>
<h1 id="rfc.section.13.7.2.3.2"><a href="#rfc.section.13.7.2.3.2">13.7.2.3.2.</a> <a href="#threelegged-authentication" id="threelegged-authentication">Three-legged Authentication</a></h1>
<p id="rfc.section.13.7.2.3.2.p.1">The signing of the challenge sent by the server usually is done directly on the client. However, this is no strict requirement.  </p>
<p id="rfc.section.13.7.2.3.2.p.2">E.g. a client might forward the challenge to another party (hence the "three-legged") for creating the signature. This can be used when the client was previously already authenticated to that third party, and WAMP-CRA should run piggy packed on that authentication.  </p>
<p id="rfc.section.13.7.2.3.2.p.3">The third party would, upon receiving a signing request, simply check if the client is already authenticated, and if so, create a signature for WAMP-CRA.  </p>
<p id="rfc.section.13.7.2.3.2.p.4">In this case, the secret is actually shared between the WAMP server who wants to authenticate clients using WAMP-CRA and the third party server, who shares a secret with the WAMP server.  </p>
<p id="rfc.section.13.7.2.3.2.p.5">This scenario is also the reason the challenge sent with WAMP-CRA is not simply a random value, but a JSON serialized object containing sufficient authentication information for the thrid party to check.  </p>
<h1 id="rfc.section.13.7.2.3.3"><a href="#rfc.section.13.7.2.3.3">13.7.2.3.3.</a> <a href="#password-salting" id="password-salting">Password Salting</a></h1>
<p id="rfc.section.13.7.2.3.3.p.1">WAMP-CRA operates using a shared secret. While the secret is never sent over the wire, a shared secret often requires storage of that secret on the client and the server - and storing a password verbatim (unencrypted) is not recommended in general.  </p>
<p id="rfc.section.13.7.2.3.3.p.2">WAMP-CRA allows the use of salted passwords following the <a href="http://en.wikipedia.org/wiki/PBKDF2">PBKDF2</a> key derivation scheme. With salted passwords, the password itself is never stored, but only a key derived from the password and a password salt. This derived key is then practically working as the new shared secret.  </p>
<p id="rfc.section.13.7.2.3.3.p.3">When the password is salted, the server will during WAMP-CRA send a <samp>CHALLENGE</samp> message containing additional information: </p>
<pre>
    [4, "wampcra",
        {
            "challenge": "{ \"nonce\": \"LHRTC9zeOIrt_9U3\", 
                \"authprovider\": \"userdb\", \"authid\": \"peter\",
                \"timestamp\": \"2014-06-22T16:36:25.448Z\", 
                \"authrole\": \"user\", \"authmethod\": \"wampcra\", 
                \"session\": 3251278072152162}",
            "salt": "salt123",
            "keylen": 32,
            "iterations": 1000
        }
    ]
</pre>
<p id="rfc.section.13.7.2.3.3.p.4">The <samp>CHALLENGE.Details.salt|string</samp> is the password salt in use. The <samp>CHALLENGE.Details.keylen|int</samp> and <samp>CHALLENGE.Details.iterations|int</samp> are parameters for the PBKDF2 algorithm.  </p>
<h1 id="rfc.section.13.7.2.4"><a href="#rfc.section.13.7.2.4">13.7.2.4.</a> <a href="#ticketauth" id="ticketauth">Ticket-based Authentication</a></h1>
<p id="rfc.section.13.7.2.4.p.1">With <em>Ticket-based authentication</em>, the client needs to present the server an authentication "ticket" - some magic value to authenticate itself to the server.  </p>
<p id="rfc.section.13.7.2.4.p.2">This "ticket" could be a long-lived, pre-agreed secret (e.g. a user password) or a short-lived authentication token (like a Kerberos token). WAMP does not care or interpret the ticket presented by the client.  </p>
<p/>

<ul class="empty">
  <li>Caution: This scheme is extremely simple and flexible, but the resulting security may be limited. E.g., the ticket value will be sent over the wire. If the transport WAMP is running over is not encrypted, a man-in-the-middle can sniff and possibly hijack the ticket. If the ticket value is reused, that might enable replay attacks.  </li>
</ul>
<p id="rfc.section.13.7.2.4.p.4">A typical authentication begins with the client sending a <samp>HELLO</samp> message specifying the <samp>ticket</samp> method as (one of) the authentication methods: </p>
<pre>
    [1, "realm1",
      {
        "roles": ...,
        "authmethods": ["ticket"],
        "authid": "joe"
      }
    ]
</pre>
<p id="rfc.section.13.7.2.4.p.5">The <samp>HELLO.Details.authmethods|list</samp> is used by the client to announce the authentication methods it is prepared to perform. For Ticket-based, this MUST include <samp>"ticket"</samp>.  </p>
<p id="rfc.section.13.7.2.4.p.6">The <samp>HELLO.Details.authid|string</samp> is the authentication ID (e.g. username) the client wishes to authenticate as. For Ticket-based authentication, this MUST be provided.  </p>
<p id="rfc.section.13.7.2.4.p.7">If the server is unwilling or unable to perform Ticket-based authentication, it'll either skip forward trying other authentication methods (if the client announced any) or send an <samp>ABORT</samp> message.  </p>
<p id="rfc.section.13.7.2.4.p.8">If the server is willing to let the client authenticate using a ticket and the server recognizes the provided <samp>authid</samp>, it'll send a <samp>CHALLENGE</samp> message: </p>
<pre>
    [4, "ticket", {}]
</pre>
<p id="rfc.section.13.7.2.4.p.9">The client will send an <samp>AUTHENTICATE</samp> message containing a ticket: </p>
<pre>
    [5, "secret!!!", {}]
</pre>
<p id="rfc.section.13.7.2.4.p.10">The server will then check if the ticket provided is permissible (for the <samp>authid</samp> given).  </p>
<p id="rfc.section.13.7.2.4.p.11">If the authentication succeeds, the server will finally respond with a <samp>WELCOME</samp> message: </p>
<pre>
    [2, 3251278072152162,
      {
        "authid": "joe",
        "authrole": "user",
        "authmethod": "ticket",
        "authprovider": "static",
        "roles": ...
      }
    ]
</pre>
<p id="rfc.section.13.7.2.4.p.12">where </p>
<p/>

<ol>
  <li><samp>authid|string</samp>: The authentication ID the client was (actually) authenticated as.</li>
  <li><samp>authrole|string</samp>: The authentication role the client was authenticated for.</li>
  <li><samp>authmethod|string</samp>: The authentication method, here <samp>"ticket"</samp></li>
  <li><samp>authprovider|string</samp>: The actual provider of authentication. For Ticket-based authentication, this can be freely chosen by the app, e.g. <samp>static</samp> or <samp>dynamic</samp>.</li>
</ol>

<p> </p>
<p id="rfc.section.13.7.2.4.p.14">The <samp>WELCOME.Details</samp> again contain the actual authentication information active. If the authentication fails, the server will response with an <samp>ABORT</samp> message.  </p>
<h1 id="rfc.section.13.7.3"><a href="#rfc.section.13.7.3">13.7.3.</a> <a href="#alternative-transports" id="alternative-transports">Alternative Transports</a></h1>
<p id="rfc.section.13.7.3.p.1">The only requirements that WAMP expects from a transport are: the transport must be message-based, bidirectional, reliable and ordered. This allows WAMP to run over different transports without any impact at the application layer.  </p>
<p id="rfc.section.13.7.3.p.2">Besides the WebSocket transport, the following WAMP transports are currently specified: </p>
<p/>

<ul>
  <li>
    <a href="#rawsocket">Section 13.7.3.1</a>
  </li>
  <li>
    <a href="#batchedwebsocket">Section 13.7.3.2</a>
  </li>
  <li>
    <a href="#longpoll">Section 13.7.3.3</a>
  </li>
  <li>
    <a href="#multiplexed">Section 13.7.3.4</a>
  </li>
</ul>

<p> </p>
<p/>

<ul class="empty">
  <li>Other transports such as HTTP 2.0 ("SPDY") or UDP might be defined in the future.  </li>
</ul>
<h1 id="rfc.section.13.7.3.1"><a href="#rfc.section.13.7.3.1">13.7.3.1.</a> <a href="#rawsocket" id="rawsocket">RawSocket Transport</a></h1>
<p><strong>WAMP-over-RawSocket</strong> is an (alternative) transport for WAMP that uses length-prefixed, binary messages - a message framing different from WebSocket.  </p>
<p id="rfc.section.13.7.3.1.p.2">Compared to WAMP-over-WebSocket, WAMP-over-RawSocket is simple to implement, since there is no need to implement the WebSocket protocol which has some features that make it non-trivial (like a full HTTP-based opening handshake, message fragmentation, masking and variable length integers).  </p>
<p id="rfc.section.13.7.3.1.p.3">WAMP-over-RawSocket has even lower overhead than WebSocket, which can be desirable in particular when running on local connections like loopback TCP or Unix domain sockets. It is also expected to allow implementations in microcontrollers in under 2KB RAM.  </p>
<p id="rfc.section.13.7.3.1.p.4">WAMP-over-RawSocket can run over TCP, TLS, Unix domain sockets or any reliable streaming underlying transport. When run over TLS on the standard port for secure HTTPS (443), it is also able to traverse most locked down networking environments such as enterprise or mobile networks (unless man-in-the-middle TLS intercepting proxies are in use).  </p>
<p id="rfc.section.13.7.3.1.p.5">However, WAMP-over-RawSocket cannot be used with Web browser clients, since browsers do not allow raw TCP connections. Browser extensions would do, but those need to be installed in a browser. WAMP-over-RawSocket also (currently) does not support transport-level compression as WebSocket does provide (<samp>permessage-deflate</samp> WebSocket extension).  </p>
<h1 id="rfc.section.13.7.3.1.1"><a href="#rfc.section.13.7.3.1.1">13.7.3.1.1.</a> <a href="#endianess" id="endianess">Endianess</a></h1>
<p id="rfc.section.13.7.3.1.1.p.1">WAMP-over-RawSocket uses <em>network byte order</em> ("big-endian"). That means, given a unsigned 32 bit integer </p>
<p id="rfc.section.13.7.3.1.1.p.2">0x 11 22 33 44 </p>
<p id="rfc.section.13.7.3.1.1.p.3">the first octet sent out to (or received from) the wire is <samp>0x11</samp> and the last octet sent out (or received) is <samp>0x44</samp>.  </p>
<p id="rfc.section.13.7.3.1.1.p.4">Here is how you would convert octets received from the wire into an integer in Python: </p>
<pre>
    import struct
    
    octets_received = b"\x11\x22\x33\x44"
    i = struct.unpack("&gt;L", octets_received)[0]
</pre>
<p id="rfc.section.13.7.3.1.1.p.5">The integer received has the value <samp>287454020</samp>.  </p>
<p id="rfc.section.13.7.3.1.1.p.6">And here is how you would send out an integer to the wire in Python: </p>
<pre>
    octets_to_be_send = struct.pack("&gt;L", i)
</pre>
<p id="rfc.section.13.7.3.1.1.p.7">The octets to be sent are <samp>b"\x11\x22\x33\x44"</samp>.  </p>
<h1 id="rfc.section.13.7.3.1.2"><a href="#rfc.section.13.7.3.1.2">13.7.3.1.2.</a> <a href="#handshake" id="handshake">Handshake</a></h1>
<p><strong>Client-to-Router Request</strong> </p>
<p id="rfc.section.13.7.3.1.2.p.2">WAMP-over-RawSocket starts with a handshake where the client connecting to a router sends 4 octets: </p>
<pre>
MSB                                 LSB
31                                    0
0111 1111 LLLL SSSS RRRR RRRR RRRR RRRR
</pre>
<p id="rfc.section.13.7.3.1.2.p.3">The <em>first octet</em> is a magic octet with value <samp>0x7F</samp>. This value is chosen to avoid any possible collision with the first octet of a valid HTTP request (see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1">here</a> and <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2">here</a>). No valid HTTP request can have <samp>0x7F</samp> as its first octet.  </p>
<p/>

<ul class="empty">
  <li>By using a magic first octet that cannot appear in a regular HTTP request, WAMP-over-RawSocket can be run e.g. on the same TCP listening port as WAMP-over-WebSocket or WAMP-over-LongPoll.  </li>
</ul>
<p id="rfc.section.13.7.3.1.2.p.5">The <em>second octet</em> consists of a 4 bit <samp>LENGTH</samp> field and a 4 bit <samp>SERIALIZER</samp> field.  </p>
<p id="rfc.section.13.7.3.1.2.p.6">The <samp>LENGTH</samp> value is used by the <em>Client</em> to signal the <strong>maximum message length</strong> of messages it is willing to <strong>receive</strong>. When the handshake completes successfully, a <em>Router</em> MUST NOT send messages larger than this size.  </p>
<p id="rfc.section.13.7.3.1.2.p.7">The possible values for <samp>LENGTH</samp> are: </p>
<pre>
 0: 2**9 octets
 1: 2**10 octets
...
15: 2**24 octets
</pre>
<p id="rfc.section.13.7.3.1.2.p.8">This means a <em>Client</em> can choose the maximum message length between <strong>512</strong> and <strong>16M</strong> octets.  </p>
<p id="rfc.section.13.7.3.1.2.p.9">The <samp>SERIALIZER</samp> value is used by the <em>Client</em> to request a specific serializer to be used. When the handshake completes successfully, the <em>Client</em> and <em>Router</em> will use the serializer requested by the <em>Client</em>.  </p>
<p id="rfc.section.13.7.3.1.2.p.10">The possible values for <samp>SERIALIZER</samp> are: </p>
<pre>
0: illegal
1: JSON
2: MsgPack
3 - 15: reserved for future serializers
</pre>
<p id="rfc.section.13.7.3.1.2.p.11">Here is a Python program that prints all (currently) permissible values for the <em>second octet</em>: </p>
<pre>
SERMAP = {
   1: 'json',
   2: 'msgpack'
}

## map serializer / max. msg length to RawSocket handshake request 
## or success reply (2nd octet)
##
for ser in SERMAP:
   for l in range(16):
      octet_2 = (l &lt;&lt; 4) | ser
      print("serializer: {}, maxlen: {} =&gt; 
          0x{:02x}".format(SERMAP[ser], 2 ** (l + 9), octet_2))
</pre>
<p id="rfc.section.13.7.3.1.2.p.12">The <em>third and forth octet</em> are <strong>reserved</strong> and MUST be all zeros for now.  </p>
<p><strong>Router-to-Client Reply</strong> </p>
<p id="rfc.section.13.7.3.1.2.p.14">After a <em>Client</em> has connected to a <em>Router</em>, the <em>Router</em> will first receive the 4 octets handshake request from the <em>Client</em>.  </p>
<p id="rfc.section.13.7.3.1.2.p.15">If the <em>first octet</em> differs from <samp>0x7F</samp>, it is not a WAMP-over-RawSocket request. Unless the <em>Router</em> also supports other transports on the connecting port (such as WebSocket or LongPoll), the <em>Router</em> MUST <strong>fail the connection</strong>.  </p>
<p id="rfc.section.13.7.3.1.2.p.16">Here is an example of how a <em>Router</em> could parse the <em>second octet</em> in a <em>Clients</em> handshake request: </p>
<pre>
## map RawSocket handshake request (2nd octet) to 
## serializer / max. msg length
##
for i in range(256):
   ser_id = i &amp; 0x0f
   if ser_id != 0:
      ser = SERMAP.get(ser_id, 'currently undefined')
      maxlen = 2 ** ((i &gt;&gt; 4) + 9)
      print("{:02x} =&gt; serializer: {}, maxlen: {}".
          format(i, ser, maxlen))
   else:
      print("fail the connection: illegal serializer value")
</pre>
<p id="rfc.section.13.7.3.1.2.p.17">When the <em>Router</em> is willing to speak the serializer requested by the <em>Client</em>, it will answer with a 4 octets response of identical structure as the <em>Client</em> request: </p>
<pre>
MSB                                 LSB
31                                    0
0111 1111 LLLL SSSS RRRR RRRR RRRR RRRR
</pre>
<p id="rfc.section.13.7.3.1.2.p.18">Again, the <em>first octet</em> MUST be the value <samp>0x7F</samp>. The <em>third and forth octets</em> are reserved and MUST be all zeros for now.  </p>
<p id="rfc.section.13.7.3.1.2.p.19">In the <em>second octet</em>, the <em>Router</em> MUST echo the serializer value in <samp>SERIALIZER</samp> as requested by the <em>Client</em>.  </p>
<p id="rfc.section.13.7.3.1.2.p.20">Similar to the <em>Client</em>, the <em>Router</em> sets the <samp>LENGTH</samp> field to request a limit on the length of messages sent by the <em>Client</em>.  </p>
<p id="rfc.section.13.7.3.1.2.p.21">During the connection, <em>Router</em> MUST NOT send messages to the <em>Client</em> longer than the <samp>LENGTH</samp> requested by the <em>Client</em>, and the <em>Client</em> MUST NOT send messages larger than the maximum requested by the <em>Router</em> in it's handshake reply.  </p>
<p id="rfc.section.13.7.3.1.2.p.22">If a message received during a connection exceeds the limit requested, a <em>Peer</em> MUST <strong>fail the connection</strong>.  </p>
<p id="rfc.section.13.7.3.1.2.p.23">When the <em>Router</em> is unable to speak the serializer requested by the <em>Client</em>, or it is denying the <em>Client</em> for other reasons, the <em>Router</em> replies with an error: </p>
<pre>
MSB                                 LSB
31                                    0
0111 1111 EEEE 0000 RRRR RRRR RRRR RRRR
</pre>
<p id="rfc.section.13.7.3.1.2.p.24">An error reply has 4 octets: the <em>first octet</em> is again the magic <samp>0x7F</samp>, and the <em>third and forth octet</em> are reserved and MUST all be zeros for now.  </p>
<p id="rfc.section.13.7.3.1.2.p.25">The <em>second octet</em> has its lower 4 bits zero'ed (which distinguishes the reply from an success/accepting reply) and the upper 4 bits encode the error: </p>
<pre>
0: illegal (must not be used)
1: serializer unsupported
2: maximum message length unacceptable
3: use of reserved bits (unsupported feature)
4: maximum connection count reached
5 - 15: reserved for future errors
</pre>
<p/>

<ul class="empty">
  <li>Note that the error code <samp>0</samp> MUST not be used. This is to allow storage of error state in a host language variable, while allowing <samp>0</samp> to signal the current state "no error" </li>
</ul>
<p id="rfc.section.13.7.3.1.2.p.27">Here is an example of how a <em>Router</em> might create the <em>second octet</em> in an error response: </p>
<pre>
ERRMAP = {
   0: "illegal (must not be used)",
   1: "serializer unsupported",
   2: "maximum message length unacceptable",
   3: "use of reserved bits (unsupported feature)",
   4: "maximum connection count reached"
}

## map error to RawSocket handshake error reply (2nd octet)
##
for err in ERRMAP:
   octet_2 = err &lt;&lt; 4
   print("error: {} =&gt; 0x{:02x}").format(ERRMAP[err], err)
</pre>
<p id="rfc.section.13.7.3.1.2.p.28">The <em>Client</em> - after having sent its handshake request - will wait for the 4 octets from <em>Router</em> handshake reply.  </p>
<p id="rfc.section.13.7.3.1.2.p.29">Here is an example of how a <em>Client</em> might parse the <em>second octet</em> in a <em>Router</em> handshake reply: </p>
<pre>
## map RawSocket handshake reply (2nd octet)
##
for i in range(256):
   ser_id = i &amp; 0x0f
   if ser_id:
      ## verify the serializer is the one we requested! 
      ## if not, fail the connection!
      ser = SERMAP.get(ser_id, 'currently undefined')
      maxlen = 2 ** ((i &gt;&gt; 4) + 9)
      print("{:02x} =&gt; serializer: {}, maxlen: {}".
          format(i, ser, maxlen))
   else:
      err = i &gt;&gt; 4
      print("error: {}".format(ERRMAP.get(err, 
          'currently undefined')))
</pre>
<h1 id="rfc.section.13.7.3.1.3"><a href="#rfc.section.13.7.3.1.3">13.7.3.1.3.</a> <a href="#serialization" id="serialization">Serialization</a></h1>
<p id="rfc.section.13.7.3.1.3.p.1">To send a WAMP message, the message is serialized according to the WAMP serializer agreed in the handshake (e.g. JSON or MsgPack).  </p>
<p id="rfc.section.13.7.3.1.3.p.2">The length of the serialized messages in octets MUST NOT exceed the maximum requested by the <em>Peer</em>.  </p>
<p id="rfc.section.13.7.3.1.3.p.3">If the serialized length exceed the maximum requested, the WAMP message can not be sent to the <em>Peer</em>. Handling situations like the latter is left to the implementation.  </p>
<p id="rfc.section.13.7.3.1.3.p.4">E.g. a <em>Router</em> that is to forward a WAMP <samp>EVENT</samp> to a <em>Client</em> which exceeds the maximum length requested by the <em>Client</em> when serialized might: </p>
<p/>

<ul>
  <li>drop the event (not forwarding to that specific client) and track dropped events</li>
  <li>prohibit publishing to the topic already</li>
  <li>remove the event payload, and send an event with extra information (<samp>payload_limit_exceeded = true</samp>)</li>
</ul>

<p> </p>
<h1 id="rfc.section.13.7.3.1.4"><a href="#rfc.section.13.7.3.1.4">13.7.3.1.4.</a> <a href="#framing" id="framing">Framing</a></h1>
<p id="rfc.section.13.7.3.1.4.p.1">The serialized octets for a message to be sent are prefixed with exactly 4 octets.  </p>
<pre>
MSB                                 LSB
31                                    0
RRRR RTTT LLLL LLLL LLLL LLLL LLLL LLLL
</pre>
<p id="rfc.section.13.7.3.1.4.p.2">The <em>first octet</em> has the following structure </p>
<pre>
MSB   LSB
7       0
RRRR RTTT
</pre>
<p id="rfc.section.13.7.3.1.4.p.3">The five bits <samp>RRRRR</samp> are reserved for future use and MUST be all zeros for now.  </p>
<p id="rfc.section.13.7.3.1.4.p.4">The three bits <samp>TTT</samp> encode the type of the transport message: </p>
<pre>
0: regular WAMP message
1: PING
2: PONG
3-7: reserved
</pre>
<p id="rfc.section.13.7.3.1.4.p.5">The <em>three remaining octets</em> constitute an unsigned 24 bit integer that provides the length of transport message payload following, excluding the 4 octets that constitute the prefix.  </p>
<p id="rfc.section.13.7.3.1.4.p.6">For a regular WAMP message (<samp>TTT == 0</samp>), the length is the length of the serialized WAMP message: the number of octets after serialization (excluding the 4 octets of the prefix).  </p>
<p id="rfc.section.13.7.3.1.4.p.7">For a <samp>PING</samp> message (<samp>TTT == 1</samp>), the length is the length of the arbitrary payload that follows. A <em>Peer</em> MUST reply to each <samp>PING</samp> by sending exactly one <samp>PONG</samp> immediately, and the <samp>PONG</samp> MUST echo back the payload of the <samp>PING</samp> exactly.  </p>
<p id="rfc.section.13.7.3.1.4.p.8">For receiving messages with WAMP-over-RawSocket, a <em>Peer</em> will usually read exactly 4 octets from the incoming stream, decode the transport level message type and payload length, and then receive as many octets as the length was giving.  </p>
<p id="rfc.section.13.7.3.1.4.p.9">When the transport level message type indicates a regular WAMP message, the transport level message payload is unserialized according to the serializer agreed in the handshake and the processed at the WAMP level.  </p>
<h1 id="rfc.section.13.7.3.2"><a href="#rfc.section.13.7.3.2">13.7.3.2.</a> <a href="#batchedwebsocket" id="batchedwebsocket">Batched WebSocket Transport for WAMP</a></h1>
<p><em>WAMP-over-Batched-WebSocket</em> is a variant of WAMP-over-WebSocket where multiple WAMP messages are sent in one WebSocket message.  </p>
<p id="rfc.section.13.7.3.2.p.2">Using WAMP message batching can increase wire level efficiency further. In particular when using TLS and the WebSocket implementation is forcing every WebSocket message into a new TLS segment.  </p>
<p id="rfc.section.13.7.3.2.p.3">WAMP-over-Batched-WebSocket is negotiated between Peers in the WebSocket opening handshake by agreeing on one of the following WebSocket subprotocols: </p>
<p/>

<ul>
  <li>
    <samp>wamp.2.json.batched</samp>
  </li>
  <li>
    <samp>wamp.2.msgpack.batched</samp>
  </li>
</ul>

<p> </p>
<p id="rfc.section.13.7.3.2.p.5">Batching with JSON works by serializing each WAMP message to JSON as normally, appending the single ASCII control character <samp>\30</samp> (<a href="http://en.wikipedia.org/wiki/Record_separator#Field_separators">record separator</a>) octet <samp>0x1e</samp> to <em>each</em> serialized messages, and packing a sequence of such serialized messages into a single WebSocket message: </p>
<pre>
    Serialized JSON WAMP Msg 1 | 0x1e | 
        Serialized JSON WAMP Msg 2 | 0x1e | ...
</pre>
<p id="rfc.section.13.7.3.2.p.6">Batching with MsgPack works by serializing each WAMP message to MsgPack as normally, prepending a 32 bit unsigned integer (4 octets in big-endian byte order) with the length of the serialized MsgPack message (excluding the 4 octets for the length prefix), and packing a sequence of such serialized (length-prefixed) messages into a single WebSocket message: </p>
<pre>
    Length of Msg 1 serialization (uint32) | 
        serialized MsgPack WAMP Msg 1 | ...
</pre>
<p id="rfc.section.13.7.3.2.p.7">With batched transport, even if only a single WAMP message is to be sent in a WebSocket message, the (single) WAMP message needs to be framed as described above. In other words, a single WAMP message is sent as a batch of length <strong>1</strong>. Sending a batch of length <strong>0</strong> (no WAMP message) is illegal and a <em>Peer</em> MUST fail the transport upon receiving such a transport message.  </p>
<h1 id="rfc.section.13.7.3.3"><a href="#rfc.section.13.7.3.3">13.7.3.3.</a> <a href="#longpoll" id="longpoll">A HTTP Longpoll Transport for WAMP</a></h1>
<p id="rfc.section.13.7.3.3.p.1">The <em>Long-Poll Transport</em> is able to transmit a WAMP session over plain old HTTP 1.0/1.1. This is realized by the Client issuing HTTP/POSTs requests, one for sending, and one for receiving. Those latter requests are kept open at the server when there are no messages currently pending to be received.  </p>
<p><strong>Opening a Session</strong> </p>
<p id="rfc.section.13.7.3.3.p.3">With the Long-Poll Transport, a Client opens a new WAMP session by sending a HTTP/POST request to a well-known URL, e.g.  </p>
<pre>
    http://mypp.com/longpoll/open
</pre>
<p id="rfc.section.13.7.3.3.p.4">Here, <samp>http://mypp.com/longpoll</samp> is the base URL for the Long-Poll Transport and <samp>/open</samp> is a path dedicated for opening new sessions.  </p>
<p id="rfc.section.13.7.3.3.p.5">The HTTP/POST request SHOULD have a <samp>Content-Type</samp> header set to <samp>application/json</samp> and MUST have a request body with a JSON document that is a dictionary: </p>
<pre>
    {
       "protocols": ["wamp.2.json"]
    }
</pre>
<p id="rfc.section.13.7.3.3.p.6">The (mandatory) <samp>protocols</samp> attribute specifies the protocols the client is willing to speak. The server will chose one from this list when establishing the session or fail the request when no protocol overlap was found.  </p>
<p id="rfc.section.13.7.3.3.p.7">The valid protocols are: </p>
<p/>

<ul>
  <li>
    <samp>wamp.2.json.batched</samp>
  </li>
  <li>
    <samp>wamp.2.json</samp>
  </li>
  <li>
    <samp>wamp.2.msgpack.batched</samp>
  </li>
  <li>
    <samp>wamp.2.msgpack</samp>
  </li>
</ul>

<p> </p>
<p/>

<ul class="empty">
  <li>The request path with this and subsequently described HTTP/POST requests MAY contain a query parameter <samp>x</samp> with some random or sequentially incremented value: </li>
  <li><span>&lt;</span><a href="http://mypp.com/longpoll/open?x=382913">http://mypp.com/longpoll/open?x=382913</a><span>&gt;</span> </li>
  <li>The value is ignored, but may help in certain situations to prevent intermediaries from caching the request.  </li>
</ul>
<p id="rfc.section.13.7.3.3.p.10">Returned is a JSON document containing a transport ID and the protocol to speak: </p>
<pre>
    {
       "protocol": "wamp.2.json",
       "transport": "kjmd3sBLOUnb3Fyr"
    }
</pre>
<p id="rfc.section.13.7.3.3.p.11">As an implied side-effect, two HTTP endpoints are created </p>
<pre>
    http://mypp.com/longpoll/&lt;transport_id&gt;/receive
    http://mypp.com/longpoll/&lt;transport_id&gt;/send
</pre>
<p id="rfc.section.13.7.3.3.p.12">where <samp>transport_id</samp> is the transport ID returned from <samp>open</samp>, e.g.  </p>
<pre>
    http://mypp.com/longpoll/kjmd3sBLOUnb3Fyr/receive
    http://mypp.com/longpoll/kjmd3sBLOUnb3Fyr/send
</pre>
<p><strong>Receiving WAMP Messages</strong> </p>
<p id="rfc.section.13.7.3.3.p.14">The Client will then issue HTTP/POST requests (with empty request body) to </p>
<pre>
    http://mypp.com/longpoll/kjmd3sBLOUnb3Fyr/receive
</pre>
<p id="rfc.section.13.7.3.3.p.15">When there are WAMP messages pending downstream, a request will return with a single WAMP message (unbatched modes) or a batch of serialized WAMP messages (batched mode).  </p>
<p id="rfc.section.13.7.3.3.p.16">The serialization format used is the one agreed during opening the session.  </p>
<p id="rfc.section.13.7.3.3.p.17">The batching uses the same scheme as with <samp>wamp.2.json.batched</samp> and <samp>wamp.2.msgpack.batched</samp> transport over WebSocket.  </p>
<p/>

<ul class="empty">
  <li>Note: In unbatched mode, when there is more than one message pending, there will be at most one message returned for each request. The other pending messages must be retrieved by new requests. With batched mode, all messages pending at request time will be returned in one batch of messages.  </li>
</ul>
<p><strong>Sending WAMP Messages</strong> </p>
<p id="rfc.section.13.7.3.3.p.20">For sending WAMP messages, the <em>Client</em> will issue HTTP/POST requests to </p>
<pre>
    http://mypp.com/longpoll/kjmd3sBLOUnb3Fyr/send
</pre>
<p id="rfc.section.13.7.3.3.p.21">with request body being a single WAMP message (unbatched modes) or a batch of serialized WAMP messages (batched mode).  </p>
<p id="rfc.section.13.7.3.3.p.22">The serialization format used is the one agreed during opening the session.  </p>
<p id="rfc.section.13.7.3.3.p.23">The batching uses the same scheme as with <samp>wamp.2.json.batched</samp> and <samp>wamp.2.msgpack.batched</samp> transport over WebSocket.  </p>
<p id="rfc.section.13.7.3.3.p.24">Upon success, the request will return with HTTP status code 202 ("no content"). Upon error, the request will return with HTTP status code 400 ("bad request").  </p>
<p><strong>Closing a Session</strong> </p>
<p id="rfc.section.13.7.3.3.p.26">To orderly close a session, a Client will issue a HTTP/POST to </p>
<pre>
    http://mypp.com/longpoll/kjmd3sBLOUnb3Fyr/close
</pre>
<p id="rfc.section.13.7.3.3.p.27">with an empty request body. Upon success, the request will return with HTTP status code 202 ("no content").  </p>
<h1 id="rfc.section.13.7.3.4"><a href="#rfc.section.13.7.3.4">13.7.3.4.</a> <a href="#multiplexed" id="multiplexed">Multiplexed Transport</a></h1>
<p id="rfc.section.13.7.3.4.p.1">A Transport may support the multiplexing of multiple logical transports over a single "physical" transport.  </p>
<p id="rfc.section.13.7.3.4.p.2">By using such a Transport, multiple WAMP sessions can be transported over a single underlying transport at the same time.  </p>
<p id="rfc.section.13.7.3.4.p.3">As an example, the proposed <a href="https://github.com/oberstet/permessage-priority/blob/master/draft-oberstein-hybi-permessage-priority.txt">WebSocket extension "permessage-priority"</a> would allow creating multiple logical Transports for WAMP over a single underlying WebSocket connection.  </p>
<p id="rfc.section.13.7.3.4.p.4">Sessions running over a multiplexed Transport are completely independent: they get assigned different session IDs, may join different realms and each session needs to authenticate itself.  </p>
<p id="rfc.section.13.7.3.4.p.5">Because of above, Multiplexed Transports for WAMP are actually not detailed in the WAMP spec, but a feature of the transport being used.  </p>
<p/>

<ul class="empty">
  <li>Note: Currently no WAMP transport supports multiplexing. The work on the MUX extension with WebSocket has stalled, and the <samp>permessage-priority</samp> proposal above is still just a proposal. However, with RawSocket, we should be able to add multiplexing in the the future (with downward compatibility).  </li>
</ul>
<h1 id="rfc.section.13.7.3.5"><a href="#rfc.section.13.7.3.5">13.7.3.5.</a> <a href="#ticketauth-1" id="ticketauth-1">Ticket-based Authentication</a></h1>
<p id="rfc.section.13.7.3.5.p.1">With <em>Ticket-based authentication</em>, the client needs to present the server an authentication "ticket" - some magic value to authenticate itself to the server.  </p>
<p id="rfc.section.13.7.3.5.p.2">This "ticket" could be a long-lived, pre-agreed secret (e.g. a user password) or a short-lived authentication token (like a Kerberos token). WAMP does not care or interpret the ticket presented by the client.  </p>
<p/>

<ul class="empty">
  <li>Caution: This scheme is extremely simple and flexible, but the resulting security may be limited. E.g., the ticket value will be sent over the wire. If the transport WAMP is running over is not encrypted, a man-in-the-middle can sniff and possibly hijack the ticket. If the ticket value is reused, that might enable replay attacks.  </li>
</ul>
<p id="rfc.section.13.7.3.5.p.4">A typical authentication begins with the client sending a <samp>HELLO</samp> message specifying the <samp>ticket</samp> method as (one of) the authentication methods: </p>
<pre>
    [1, "realm1",
      {
        "roles": ...,
        "authmethods": ["ticket"],
        "authid": "joe"
      }
    ]
</pre>
<p id="rfc.section.13.7.3.5.p.5">The <samp>HELLO.Details.authmethods|list</samp> is used by the client to announce the authentication methods it is prepared to perform. For Ticket-based, this MUST include <samp>"ticket"</samp>.  </p>
<p id="rfc.section.13.7.3.5.p.6">The <samp>HELLO.Details.authid|string</samp> is the authentication ID (e.g. username) the client wishes to authenticate as. For Ticket-based authentication, this MUST be provided.  </p>
<p id="rfc.section.13.7.3.5.p.7">If the server is unwilling or unable to perform Ticket-based authentication, it'll either skip forward trying other authentication methods (if the client announced any) or send an <samp>ABORT</samp> message.  </p>
<p id="rfc.section.13.7.3.5.p.8">If the server is willing to let the client authenticate using a ticket and the server recognizes the provided <samp>authid</samp>, it'll send a <samp>CHALLENGE</samp> message: </p>
<pre>
    [4, "ticket", {}]
</pre>
<p id="rfc.section.13.7.3.5.p.9">The client will send an <samp>AUTHENTICATE</samp> message containing a ticket: </p>
<pre>
    [5, "secret!!!", {}]
</pre>
<p id="rfc.section.13.7.3.5.p.10">The server will then check if the ticket provided is permissible (for the <samp>authid</samp> given).  </p>
<p id="rfc.section.13.7.3.5.p.11">If the authentication succeeds, the server will finally respond with a <samp>WELCOME</samp> message: </p>
<pre>
    [2, 3251278072152162,
      {
        "authid": "joe",
        "authrole": "user",
        "authmethod": "ticket",
        "authprovider": "static",
        "roles": ...
      }
    ]
</pre>
<p id="rfc.section.13.7.3.5.p.12">where </p>
<p/>

<ol>
  <li><samp>authid|string</samp>: The authentication ID the client was (actually) authenticated as.</li>
  <li><samp>authrole|string</samp>: The authentication role the client was authenticated for.</li>
  <li><samp>authmethod|string</samp>: The authentication method, here <samp>"ticket"</samp></li>
  <li><samp>authprovider|string</samp>: The actual provider of authentication. For Ticket-based authentication, this can be freely chosen by the app, e.g. <samp>static</samp> or <samp>dynamic</samp>.</li>
</ol>

<p> </p>
<p id="rfc.section.13.7.3.5.p.14">The <samp>WELCOME.Details</samp> again contain the actual authentication information active. If the authentication fails, the server will response with an <samp>ABORT</samp> message.  </p>
<h1 id="rfc.section.13.7.3.6"><a href="#rfc.section.13.7.3.6">13.7.3.6.</a> <a href="#ticketauth-2" id="ticketauth-2">Ticket-based Authentication</a></h1>
<p id="rfc.section.13.7.3.6.p.1">With <em>Ticket-based authentication</em>, the client needs to present the server an authentication "ticket" - some magic value to authenticate itself to the server.  </p>
<p id="rfc.section.13.7.3.6.p.2">This "ticket" could be a long-lived, pre-agreed secret (e.g. a user password) or a short-lived authentication token (like a Kerberos token). WAMP does not care or interpret the ticket presented by the client.  </p>
<p/>

<ul class="empty">
  <li>Caution: This scheme is extremely simple and flexible, but the resulting security may be limited. E.g., the ticket value will be sent over the wire. If the transport WAMP is running over is not encrypted, a man-in-the-middle can sniff and possibly hijack the ticket. If the ticket value is reused, that might enable replay attacks.  </li>
</ul>
<p id="rfc.section.13.7.3.6.p.4">A typical authentication begins with the client sending a <samp>HELLO</samp> message specifying the <samp>ticket</samp> method as (one of) the authentication methods: </p>
<pre>
    [1, "realm1",
      {
        "roles": ...,
        "authmethods": ["ticket"],
        "authid": "joe"
      }
    ]
</pre>
<p id="rfc.section.13.7.3.6.p.5">The <samp>HELLO.Details.authmethods|list</samp> is used by the client to announce the authentication methods it is prepared to perform. For Ticket-based, this MUST include <samp>"ticket"</samp>.  </p>
<p id="rfc.section.13.7.3.6.p.6">The <samp>HELLO.Details.authid|string</samp> is the authentication ID (e.g. username) the client wishes to authenticate as. For Ticket-based authentication, this MUST be provided.  </p>
<p id="rfc.section.13.7.3.6.p.7">If the server is unwilling or unable to perform Ticket-based authentication, it'll either skip forward trying other authentication methods (if the client announced any) or send an <samp>ABORT</samp> message.  </p>
<p id="rfc.section.13.7.3.6.p.8">If the server is willing to let the client authenticate using a ticket and the server recognizes the provided <samp>authid</samp>, it'll send a <samp>CHALLENGE</samp> message: </p>
<pre>
    [4, "ticket", {}]
</pre>
<p id="rfc.section.13.7.3.6.p.9">The client will send an <samp>AUTHENTICATE</samp> message containing a ticket: </p>
<pre>
    [5, "secret!!!", {}]
</pre>
<p id="rfc.section.13.7.3.6.p.10">The server will then check if the ticket provided is permissible (for the <samp>authid</samp> given).  </p>
<p id="rfc.section.13.7.3.6.p.11">If the authentication succeeds, the server will finally respond with a <samp>WELCOME</samp> message: </p>
<pre>
    [2, 3251278072152162,
      {
        "authid": "joe",
        "authrole": "user",
        "authmethod": "ticket",
        "authprovider": "static",
        "roles": ...
      }
    ]
</pre>
<p id="rfc.section.13.7.3.6.p.12">where </p>
<p/>

<ol>
  <li><samp>authid|string</samp>: The authentication ID the client was (actually) authenticated as.</li>
  <li><samp>authrole|string</samp>: The authentication role the client was authenticated for.</li>
  <li><samp>authmethod|string</samp>: The authentication method, here <samp>"ticket"</samp></li>
  <li><samp>authprovider|string</samp>: The actual provider of authentication. For Ticket-based authentication, this can be freely chosen by the app, e.g. <samp>static</samp> or <samp>dynamic</samp>.</li>
</ol>

<p> </p>
<p id="rfc.section.13.7.3.6.p.14">The <samp>WELCOME.Details</samp> again contain the actual authentication information active. If the authentication fails, the server will response with an <samp>ABORT</samp> message.  </p>
<h1 id="rfc.section.14"><a href="#rfc.section.14">14.</a> <a href="#binary-conversion-of-json-strings" id="binary-conversion-of-json-strings">Binary conversion of JSON Strings</a></h1>
<p id="rfc.section.14.p.1">Binary data follows a convention for conversion to JSON strings.  </p>
<p id="rfc.section.14.p.2">A <strong>byte array</strong> is converted to a <strong>JSON string</strong> as follows: </p>
<p/>

<ol>
  <li>convert the byte array to a Base64 encoded (host language) string</li>
  <li>prepend the string with a <samp>\0</samp> character</li>
  <li>serialize the string to a JSON string</li>
</ol>

<p> </p>
<p><em>Example</em> </p>
<p id="rfc.section.14.p.5">Consider the byte array (hex representation): </p>
<pre>
    10e3ff9053075c526f5fc06d4fe37cdb
</pre>
<p id="rfc.section.14.p.6">This will get converted to Base64 </p>
<pre>
    EOP/kFMHXFJvX8BtT+N82w==
</pre>
<p id="rfc.section.14.p.7">prepended with <samp>\0</samp> </p>
<pre>
    \x00EOP/kFMHXFJvX8BtT+N82w==
</pre>
<p id="rfc.section.14.p.8">and serialized to a JSON string </p>
<pre>
    "\\u0000EOP/kFMHXFJvX8BtT+N82w=="
</pre>
<p id="rfc.section.14.p.9">A <strong>JSON string</strong> is unserialized to either a <strong>string</strong> or a <strong>byte array</strong> using the following procedure: </p>
<p/>

<ol>
  <li>Unserialize a JSON string to a host language (Unicode) string</li>
  <li>If the string starts with a <samp>\0</samp> character, interpret the rest (after the first character) as Base64 and decode to a byte array</li>
  <li>Otherwise, return the Unicode string</li>
</ol>

<p> </p>
<p id="rfc.section.14.p.11">Below are complete Python and JavaScript code examples for conversion between byte arrays and JSON strings.  </p>
<h1 id="rfc.section.14.1"><a href="#rfc.section.14.1">14.1.</a> <a href="#python" id="python">Python</a></h1>
<p id="rfc.section.14.1.p.1">Here is a complete example in Python showing how byte arrays are converted to and from JSON: </p>
<pre>
    ```python
    &lt;CODE BEGINS&gt;

    import os, base64, json, sys, binascii
    PY3 = sys.version_info &gt;= (3,)
    if PY3:
       unicode = str

    data_in = os.urandom(16)
    print("In:   {}".format(binascii.hexlify(data_in)))

    ## encoding
    encoded = json.dumps('\0' + base64.b64encode(data_in).
                                          decode('ascii'))

    print("JSON: {}".format(encoded))

    ## decoding
    decoded = json.loads(encoded)
    if type(decoded) == unicode:
       if decoded[0] == '\0':
          data_out = base64.b64decode(decoded[1:])
       else:
          data_out = decoded

    print("Out:  {}".format(binascii.hexlify(data_out)))

    assert(data_out == data_in)

    &lt;CODE ENDS&gt;
    ```
</pre>
<h1 id="rfc.section.14.2"><a href="#rfc.section.14.2">14.2.</a> <a href="#javascript" id="javascript">JavaScript</a></h1>
<p id="rfc.section.14.2.p.1">Here is a complete example in JavaScript showing how byte arrays are converted to and from JSON: </p>
<pre>
    ```javascript
    &lt;CODE BEGINS&gt;

    var data_in = new Uint8Array(new ArrayBuffer(16));

    // initialize test data
    for (var i = 0; i &lt; data_in.length; ++i) {
       data_in[i] = i;
    }
    console.log(data_in);

    // convert byte array to raw string
    var raw_out = '';
    for (var i = 0; i &lt; data_in.length; ++i) {
       raw_out += String.fromCharCode(data_in[i]);
    }

    // base64 encode raw string, prepend with \0
    // and serialize to JSON
    var encoded = JSON.stringify("\0" + window.btoa(raw_out));
    console.log(encoded); // "\u0000AAECAwQFBgcICQoLDA0ODw=="

    // unserialize from JSON
    var decoded = JSON.parse(encoded);

    var data_out;
    if (decoded.charCodeAt(0) === 0) {
       // strip first character and decode base64 to raw string
       var raw = window.atob(decoded.substring(1));

       // convert raw string to byte array
       var data_out = new Uint8Array(new ArrayBuffer(raw.length));
       for (var i = 0; i &lt; raw.length; ++i) {
          data_out[i] = raw.charCodeAt(i);
       }
    } else {
       data_out = decoded;
    }

    console.log(data_out);

    &lt;CODE ENDS&gt;
    ```
</pre>
<h1 id="rfc.section.15"><a href="#rfc.section.15">15.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a></h1>
<p id="rfc.section.15.p.1">-- write me -- </p>
<h1 id="rfc.section.16"><a href="#rfc.section.16">16.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a></h1>
<p id="rfc.section.16.p.1">TBD </p>
<h1 id="rfc.section.17"><a href="#rfc.section.17">17.</a> <a href="#contributors" id="contributors">Contributors</a></h1>
<h1 id="rfc.section.18"><a href="#rfc.section.18">18.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a></h1>
<h1 id="rfc.references"><a href="#rfc.references">19.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">19.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC3629">[RFC3629]</b>
      </td>
      <td class="top"><a>Yergeau, F.</a>, "<a href="http://tools.ietf.org/html/rfc3629">UTF-8, a transformation format of ISO 10646</a>", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3986">[RFC3986]</b>
      </td>
      <td class="top"><a>Berners-Lee, T.</a>, <a>Fielding, R.</a> and <a>L. Masinter</a>, "<a href="http://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6455">[RFC6455]</b>
      </td>
      <td class="top"><a>Fette, I.</a> and <a>A. Melnikov</a>, "<a href="http://tools.ietf.org/html/rfc6455">The WebSocket Protocol</a>", RFC 6455, DOI 10.17487/RFC6455, December 2011.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">19.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Tobias G. Oberstein</span> 
	  <span class="n hidden">
		<span class="family-name">Oberstein</span>
	  </span>
	</span>
	<span class="org vcardline">Tavendo GmbH</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:tobias.oberstein@tavendo.de">tobias.oberstein@tavendo.de</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Alexander Goedde</span> 
	  <span class="n hidden">
		<span class="family-name">Goedde</span>
	  </span>
	</span>
	<span class="org vcardline">Tavendo GmbH</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:alexander.goedde@tavendo.de">alexander.goedde@tavendo.de</a></span>

  </address>
</div>

</body>
</html>

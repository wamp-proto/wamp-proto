<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd' []>
<rfc ipr="trust200902" category="std" docName="draft-oberstet-hybi-crossbar-wamp-01">
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc private=""?>
<?rfc topblock="yes"?>
<?rfc comments="no"?>
<front>
<title abbrev="WAMP">The Web Application Messaging Protocol</title>

<author initials="T.O." surname="Oberstein" fullname="Tobias G. Oberstein">
<organization>Crossbar.io Technologies GmbH</organization>
<address>
<postal>
<street></street>
<city></city>
<code></code>
<country></country>
<region></region>
</postal>
<phone></phone>
<email>tobias.oberstein@crossbario.com</email>
<uri></uri>
</address>
</author>
<author initials="A.G." surname="Goedde" fullname="Alexander Goedde">
<organization>Crossbar.io Technologies GmbH</organization>
<address>
<postal>
<street></street>
<city></city>
<code></code>
<country></country>
<region></region>
</postal>
<phone></phone>
<email>alexander.goedde@crossbario.com</email>
<uri></uri>
</address>
</author>
<date year="2017" month="March" day="19"/>

<area>Applications and Real-Time (art)</area>
<workgroup>BiDirectional or Server-Initiated HTTP</workgroup>
<keyword>WebSocket, WAMP, real-time, RPC, PubSub</keyword>


<abstract>
<t>This document defines the Web Application Messaging Protocol (WAMP). WAMP is a routed protocol that provides two messaging patterns: Publish &amp; Subscribe and routed Remote Procedure Calls. It is intended to connect application components in distributed applications. WAMP uses WebSocket as its default transport, but can be transmitted via any other protocol that allows for ordered, reliable, bi-directional, and message-oriented communications.
</t>
</abstract>

</front>

<middle>

<section anchor="introduction" title="Introduction">

<section anchor="background" title="Background">
<t><spanx style="emph">This section is non-normative.</spanx>
</t>
<t>The WebSocket protocol brings bi-directional real-time connections to the browser. It defines an API at the message level, requiring users who want to use WebSocket connections in their applications to define their own semantics on top of it.
</t>
<t>The Web Application Messaging Protocol (WAMP) is intended to provide application developers with the semantics they need to handle messaging between components in distributed applications.
</t>
<t>WAMP was initially defined as a WebSocket sub-protocol, which provided Publish &amp; Subscribe (PubSub) functionality as well as Remote Procedure Calls (RPC) for procedures implemented in a WAMP router. Feedback from implementers and users of this was included in a second version of the protocol which this document defines. Among the changes was that WAMP can now run over any transport which is message-oriented, ordered, reliable, and bi-directional.
</t>
<t>WAMP is a routed protocol, with all components connecting to a <spanx style="emph">WAMP Router</spanx>, where the WAMP Router performs message routing between the components.
</t>
<t>WAMP provides two messaging patterns: <spanx style="emph">Publish &amp; Subscribe</spanx> and <spanx style="emph">routed Remote Procedure Calls</spanx>.
</t>
<t>Publish &amp; Subscribe (PubSub) is an established messaging pattern where a component, the <spanx style="emph">Subscriber</spanx>, informs the router that it wants to receive information on a topic (i.e., it subscribes to a topic). Another component, a <spanx style="emph">Publisher</spanx>, can then publish to this topic, and the router distributes events to all Subscribers.
</t>
<t>Routed Remote Procedure Calls (RPCs) rely on the same sort of decoupling that is used by the Publish &amp; Subscribe pattern. A component, the <spanx style="emph">Callee</spanx>, announces to the router that it provides a certain procedure, identified by a procedure name. Other components, <spanx style="emph">Callers</spanx>, can then call the procedure, with the router invoking the procedure on the Callee, receiving the procedure's result, and then forwarding this result back to the Caller. Routed RPCs differ from traditional client-server RPCs in that the router serves as an intermediary between the Caller and the Callee.
</t>
<t>The decoupling in routed RPCs arises from the fact that the Caller is no longer required to have knowledge of the Callee; it merely needs to know the identifier of the procedure it wants to call. There is also no longer a need for a direct connection between the caller and the callee, since all traffic is routed. This enables the calling of procedures in components which are not reachable externally (e.g. on a NATted connection) but which can establish an outgoing connection to the WAMP router.
</t>
<t>Combining these two patterns into a single protocol allows it to be used for the entire messaging requirements of an application, thus reducing technology stack complexity, as well as networking overheads.
</t>
</section>

<section anchor="protocol-overview" title="Protocol Overview">
<t><spanx style="emph">This section is non-normative.</spanx>
</t>
<t>The PubSub messaging pattern defines three roles: <spanx style="emph">Subscribers</spanx> and <spanx style="emph">Publishers</spanx>, which communicate via a <spanx style="emph">Broker</spanx>.
</t>
<t>The routed RPC messaging pattern also defines three roles: <spanx style="emph">Callers</spanx> and <spanx style="emph">Callees</spanx>, which communicate via a <spanx style="emph">Dealer</spanx>.
</t>
<t>A <spanx style="emph">Router</spanx> is a component which implements one or both of the Broker and Dealer roles. A <spanx style="emph">Client</spanx> is a component which implements any or all of the Subscriber, Publisher, Caller, or Callee roles.
</t>
<t>WAMP <spanx style="emph">Connections</spanx> are established by Clients to a Router. Connections can use any <spanx style="emph">transport</spanx> that is message-based, ordered, reliable and bi-directional, with WebSocket as the default transport.
</t>
<t>WAMP <spanx style="emph">Sessions</spanx> are established over a WAMP Connection. A WAMP Session is joined to a <spanx style="emph">Realm</spanx> on a Router. Routing occurs only between WAMP Sessions that have joined the same Realm.
</t>
<t>The <spanx style="emph">WAMP Basic Profile</spanx> defines the parts of the protocol that are required to establish a WAMP connection, as well as for basic interactions between the four client and two router roles. WAMP implementations are required to implement the Basic Profile, at minimum.
</t>
<t>The <spanx style="emph">WAMP Advanced Profile</spanx> defines additions to the Basic Profile which greatly extend the utility of WAMP in real-world applications. WAMP implementations may support any subset of the Advanced Profile features. They are required to announce those supported features during session establishment.
</t>
</section>

<section anchor="design-philosophy" title="Design Philosophy">
<t><spanx style="emph">This section is non-normative.</spanx>
</t>
<t>WAMP was designed to be performant, safe and easy to implement. Its entire design was driven by a implement, get feedback, adjust cycle.
</t>
<t>An initial version of the protocol was publicly released in March 2012. The intent was to gain insight through implementation and use, and integrate these into a second version of the protocol, where there would be no regard for compatibility between the two versions. Several interoperable, independent implementations were released, and feedback from the implementers and users was collected.
</t>
<t>The second version of the protocol, which this RFC covers, integrates this feedback. Routed Remote Procedure Calls are one outcome of this, where the initial version of the protocol only allowed the calling of procedures provided by the router. Another, related outcome was the strict separation of routing and application logic.
</t>
<t>While WAMP was originally developed to use WebSocket as a transport, with JSON for serialization, experience in the field revealed that other transports and serialization formats were better suited to some use cases. For instance, with the use of WAMP in the Internet of Things sphere, resource constraints play a much larger role than in the browser, so any reduction of resource usage in WAMP implementations counts. This lead to the decoupling of WAMP from any particular transport or serialization, with the establishment of minimum requirements for both.
</t>

<section anchor="basic-and-advanced-profiles" title="Basic and Advanced Profiles">
<t>This document first describes a Basic Profile for WAMP in its entirety, before describing an Advanced Profile which extends the basic functionality of WAMP.
</t>
<t>The separation into Basic and Advanced Profiles is intended to extend the reach of the protocol. It allows implementations to start out with a minimal, yet operable and useful set of features, and to expand that set from there. It also allows implementations that are tailored for resource-constrained environments, where larger feature sets would not be possible. Here implementers can weigh between resource constraints and functionality requirements, then implement an optimal feature set for the circumstances.
</t>
<t>Advanced Profile features are announced during session establishment, so that different implementations can adjust their interactions to fit the commonly supported feature set.
</t>
</section>

<section anchor="application-code" title="Application Code">
<t>WAMP is designed for application code to run within Clients, i.e. <spanx style="emph">Peers</spanx> having the roles Callee, Caller, Publisher, and Subscriber.
</t>
<t>Routers, i.e. Peers of the roles Brokers and Dealers are responsible for <spanx style="strong">generic call and event routing</spanx> and do not run application code.
</t>
<t>This allows the transparent exchange of Broker and Dealer implementations without affecting the application and to distribute and deploy application components flexibly.
</t>
<t><list style="empty">
<t>Note that a <spanx style="strong">program</spanx> that implements, for instance, the Dealer role might at the same time implement, say, a built-in Callee. It is the Dealer and Broker that are generic, not the program.
</t>
</list></t>
</section>

<section anchor="language-agnostic" title="Language Agnostic">
<t>WAMP is language agnostic, i.e. can be implemented in any programming language. At the level of arguments that may be part of a WAMP message, WAMP takes a 'superset of all' approach. WAMP implementations may support features of the implementing language for use in arguments, e.g. keyword arguments.
</t>
</section>

<section anchor="router-implementation-specifics" title="Router Implementation Specifics">
<t>This specification only deals with the protocol level. Specific WAMP Broker and Dealer implementations may differ in aspects such as support for:
</t>
<t>
<list style="symbols">
<t>router networks (clustering and federation),</t>
<t>authentication and authorization schemes,</t>
<t>message persistence, and,</t>
<t>management and monitoring.</t>
</list>
</t>
<t>The definition and documentation of such Router features is outside the scope of this document.
</t>
</section>
</section>

<section anchor="relationship-to-websocket" title="Relationship to WebSocket">
<t>WAMP uses WebSocket as its default transport binding, and is a registered WebSocket subprotocol.
</t>
</section>
</section>

<section anchor="conformance-requirements" title="Conformance Requirements">
<t>All diagrams, examples, and notes in this specification are non-normative, as are all sections explicitly marked non-normative. Everything else in this specification is normative.
</t>
<t>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
&quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in
this document are to be interpreted as described in RFC 2119 <xref target="RFC2119"/>.
</t>
<t>Requirements phrased in the imperative as part of algorithms (such as &quot;strip any leading space characters&quot; or &quot;return false and abort these steps&quot;) are to be interpreted with the meaning of the key word (&quot;MUST&quot;, &quot;SHOULD&quot;, &quot;MAY&quot;, etc.) used in introducing the algorithm.
</t>
<t>Conformance requirements phrased as algorithms or specific steps MAY  be implemented in any manner, so long as the end result is equivalent.
</t>

<section anchor="terminology-and-other-conventions" title="Terminology and Other Conventions">
<t>Key terms such as named algorithms or definitions are indicated like <spanx style="emph">this</spanx> when they first occur, and are capitalized throughout the text.
</t>
</section>
</section>

<section anchor="realms-sessions-and-transports" title="Realms, Sessions and Transports">
<t>A Realm is a WAMP routing and administrative domain, optionally protected by authentication and authorization. WAMP messages are only routed within a Realm.
</t>
<t>A Session is a transient conversation between two Peers attached to a Realm and running over a Transport.
</t>
<t>A Transport connects two WAMP Peers and provides a channel over which WAMP messages for a WAMP Session can flow in both directions.
</t>
<t>WAMP can run over any Transport which is message-based, bidirectional,  reliable and ordered.
</t>
<t>The default transport for WAMP is WebSocket <xref target="RFC6455"/>, where WAMP is an <eref target="http://www.iana.org/assignments/websocket/websocket.xml">officially registered</eref> subprotocol.
</t>
</section>

<section anchor="peers-and-roles" title="Peers and Roles">
<t>A WAMP Session connects two Peers, a Client and a Router. Each WAMP Peer MUST implement one role, and MAY implement more roles.
</t>
<t>A Client MAY implement any combination of the Roles:
</t>
<t>
<list style="symbols">
<t>Callee</t>
<t>Caller</t>
<t>Publisher</t>
<t>Subscriber</t>
</list>
</t>
<t>and a Router MAY implement either or both of the Roles:
</t>
<t>
<list style="symbols">
<t>Dealer</t>
<t>Broker</t>
</list>
</t>
<t><list style="empty">
<t>This document describes WAMP as in client-to-router communication. Direct client-to-client communication is not supported by WAMP. Router-to-router communication MAY be defined by a specific router implementation.
</t>
</list></t>

<section anchor="symmetric-messaging" title="Symmetric Messaging">
<t>It is important to note that though the establishment of a Transport might have a inherent asymmetry (like a TCP client establishing a WebSocket connection to a server), and Clients establish WAMP sessions by attaching to Realms on Routers, WAMP itself is designed to be fully symmetric for application components.
</t>
<t>After the transport and a session have been established, any application component may act as Caller, Callee, Publisher and Subscriber at the same time. And Routers provide the fabric on top of which WAMP runs a symmetric application messaging service.
</t>
</section>

<section anchor="remote-procedure-call-roles" title="Remote Procedure Call Roles">
<t>The Remote Procedure Call messaging pattern involves peers of three different roles:
</t>
<t>
<list style="symbols">
<t>Callee (Client)</t>
<t>Caller (Client)</t>
<t>Dealer (Router)</t>
</list>
</t>
<t>A Caller issues calls to remote procedures by providing the procedure URI and any arguments for the call.
The Callee will execute the procedure using the supplied arguments to the call and return the result of the call to the Caller.
</t>
<t>Callees register procedures they provide with Dealers. Callers initiate procedure calls first to Dealers. Dealers route calls incoming from Callers to Callees implementing the procedure called, and route call results back from Callees to Callers.
</t>
<t>The Caller and Callee will usually run application code, while the Dealer works as a generic router for remote procedure calls decoupling Callers and Callees.
</t>
</section>

<section anchor="publish--subscribe-roles" title="Publish &amp; Subscribe Roles">
<t>The Publish &amp; Subscribe messaging pattern involves peers of three different roles:
</t>
<t>
<list style="symbols">
<t>Subscriber (Client)</t>
<t>Publisher (Client)</t>
<t>Broker (Router)</t>
</list>
</t>
<t>A Publisher publishes events to topics by providing the topic URI and any payload for the event. Subscribers of the topic will receive the event together with the event payload.
</t>
<t>Subscribers subscribe to topics they are interested in with Brokers. Publishers initiate publication first at Brokers. Brokers route events incoming from Publishers to Subscribers that are subscribed to respective topics.
</t>
<t>The Publisher and Subscriber will usually run application code, while the Broker works as a generic router for events decoupling Publishers from Subscribers.
</t>
</section>

<section anchor="peers-with-multiple-roles" title="Peers with multiple Roles">
<t>Note that Peers might implement more than one role: e.g. a Peer might act as Caller, Publisher and Subscriber at the same time. Another Peer might act as both a Broker and a Dealer.
</t>
</section>
</section>

<section anchor="building-blocks" title="Building Blocks">
<t>WAMP is defined with respect to the following building blocks
</t>
<t>
<list style="numbers">
<t>Identifiers</t>
<t>Serializations</t>
<t>Transports</t>
</list>
</t>
<t>For each building block, WAMP only assumes a defined set of requirements, which allows to run WAMP variants with different concrete bindings.
</t>

<section anchor="identifiers" title="Identifiers">

<section anchor="uris" title="URIs">
<t>WAMP needs to identify the following persistent resources:
</t>
<t>
<list style="numbers">
<t>Topics</t>
<t>Procedures</t>
<t>Errors</t>
</list>
</t>
<t>These are identified in WAMP using Uniform Resource Identifiers (URIs) <xref target="RFC3986"/> that MUST be Unicode strings.
</t>
<t><list style="empty">
<t>When using JSON as WAMP serialization format, URIs (as other strings) are transmitted in UTF-8 <xref target="RFC3629"/> encoding.
</t>
</list></t>
<t><spanx style="emph">Examples</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">com.myapp.mytopic1</spanx></t>
<t><spanx style="verb">com.myapp.myprocedure1</spanx></t>
<t><spanx style="verb">com.myapp.myerror1</spanx></t>
</list>
</t>
<t>The URIs are understood to form a single, global, hierarchical namespace for WAMP.
</t>
<t><list style="empty">
<t>The namespace is unified for topics, procedures and errors - these different resource types do NOT have separate namespaces.
</t>
</list></t>
<t>To avoid resource naming conflicts, the package naming convention from Java is used, where URIs SHOULD begin with (reversed) domain names owned by the organization defining the URI.
</t>

<section anchor="relaxedloose-uris" title="Relaxed/Loose URIs">
<t>URI components (the parts between two <spanx style="verb">.</spanx>s, the head part up to the first <spanx style="verb">.</spanx>, the tail part after the last <spanx style="verb">.</spanx>) MUST NOT contain a <spanx style="verb">.</spanx>, <spanx style="verb">#</spanx> or whitespace characters and MUST NOT be empty (zero-length strings).
</t>
<t><list style="empty">
<t>The restriction not to allow <spanx style="verb">.</spanx> in component strings is due to the fact that <spanx style="verb">.</spanx> is used to separate components, and WAMP associates semantics with resource hierarchies, such as in pattern-based subscriptions that are part of the Advanced Profile. The restriction not to allow empty (zero-length) strings as components is due to the fact that this may be used to denote wildcard components with pattern-based subscriptions and registrations in the Advanced Profile. The character <spanx style="verb">#</spanx> is not allowed since this is reserved for internal use by Dealers and Brokers.
</t>
</list></t>
<t>As an example, the following regular expression could be used in Python to check URIs according to the above rules:
</t>

<figure align="left"><artwork align="left">
    &lt;CODE BEGINS&gt;
        ## loose URI check disallowing empty URI components
        pattern = re.compile(r"^([^\s\.#]+\.)*([^\s\.#]+)$")
    &lt;CODE ENDS&gt;
</artwork></figure>
<t>When empty URI components are allowed (which is the case for specific messages that are part of the Advanced Profile), this following regular expression can be used (shown used in Python):
</t>

<figure align="left"><artwork align="left">
    &lt;CODE BEGINS&gt;
        ## loose URI check allowing empty URI components
        pattern = re.compile(r"^(([^\s\.#]+\.)|\.)*([^\s\.#]+)?$")
    &lt;CODE ENDS&gt;
</artwork></figure>
</section>

<section anchor="strict-uris" title="Strict URIs">
<t>While the above rules MUST be followed, following a stricter URI rule is recommended: URI components SHOULD only contain lower-case letters, digits and <spanx style="verb">_</spanx>.
</t>
<t>As an example, the following regular expression could be used in Python to check URIs according to the above rules:
</t>

<figure align="left"><artwork align="left">
    &lt;CODE BEGINS&gt;
        ## strict URI check disallowing empty URI components
        pattern = re.compile(r"^([0-9a-z_]+\.)*([0-9a-z_]+)$")
    &lt;CODE ENDS&gt;
</artwork></figure>
<t>When empty URI components are allowed (which is the case for specific messages that are part of the Advanced Profile), the following regular expression can be used (shown in Python):
</t>

<figure align="left"><artwork align="left">
    &lt;CODE BEGINS&gt;
        ## strict URI check allowing empty URI components
        pattern = re.compile(r"^(([0-9a-z_]+\.)|\.)*([0-9a-z_]+)?$")
    &lt;CODE ENDS&gt;
</artwork></figure>
<t><list style="empty">
<t>Following the suggested regular expression will make URI components valid identifiers in most languages (modulo URIs starting with a digit and language keywords) and the use of lower-case only will make those identifiers unique in languages that have case-insensitive identifiers. Following this suggestion can allow implementations to map topics, procedures and errors to the language environment in a completely transparent way.
</t>
</list></t>
</section>

<section anchor="reserved-uris" title="Reserved URIs">
<t>Further, application URIs MUST NOT use <spanx style="verb">wamp</spanx> as a first URI component, since this is reserved for URIs predefined with the WAMP protocol itself.
</t>
<t><spanx style="emph">Examples</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">wamp.error.not_authorized</spanx></t>
<t><spanx style="verb">wamp.error.procedure_already_exists</spanx></t>
</list>
</t>
</section>
</section>

<section anchor="ids" title="IDs">
<t>WAMP needs to identify the following ephemeral entities each in the scope noted:
</t>
<t>
<list style="numbers">
<t>Sessions (<spanx style="emph">global scope</spanx>)</t>
<t>Publications (<spanx style="emph">global scope</spanx>)</t>
<t>Subscriptions (<spanx style="emph">router scope</spanx>)</t>
<t>Registrations (<spanx style="emph">router scope</spanx>)</t>
<t>Requests (<spanx style="emph">session scope</spanx>)</t>
</list>
</t>
<t>These are identified in WAMP using IDs that are integers between (inclusive) <spanx style="strong">1</spanx> and <spanx style="strong">2^53</spanx> (9007199254740992):
</t>
<t>
<list style="symbols">
<t>IDs in the <spanx style="emph">global scope</spanx> MUST be drawn <spanx style="emph">randomly</spanx> from a <spanx style="emph">uniform distribution</spanx> over the complete range [1, 2^53]</t>
<t>IDs in the <spanx style="emph">router scope</spanx> CAN be chosen freely by the specific router implementation</t>
<t>IDs in the <spanx style="emph">session scope</spanx> MUST be incremented by 1 beginning with 1 (for each direction - <spanx style="emph">Client-to-Router</spanx> and <spanx style="emph">Router-to-Client</spanx>)</t>
</list>
</t>
<t><list style="empty">
<t>The reason to choose the specific lower bound as 1 rather than 0 is that 0 is the null-like (falsy) value for many programming languages.
The reason to choose the specific upper bound is that 2^53 is the largest integer such that this integer and <spanx style="emph">all</spanx> (positive) smaller integers can be represented exactly in IEEE-754 doubles. Some languages (e.g. JavaScript) use doubles as their sole number type. Most languages do have signed and unsigned 64-bit integer types that both can hold any value from the specified range.
</t>
</list></t>
<t>The following is a complete list of usage of IDs in the three categories for all WAMP messages. For a full definition of these see <xref target="messages"/>.
</t>

<section anchor="global-scope-ids" title="Global Scope IDs">
<t>
<list style="symbols">
<t><spanx style="verb">WELCOME.Session</spanx></t>
<t><spanx style="verb">PUBLISHED.Publication</spanx></t>
<t><spanx style="verb">EVENT.Publication</spanx></t>
</list>
</t>
</section>

<section anchor="router-scope-ids" title="Router Scope IDs">
<t>
<list style="symbols">
<t><spanx style="verb">EVENT.Subscription</spanx></t>
<t><spanx style="verb">SUBSCRIBED.Subscription</spanx></t>
<t><spanx style="verb">REGISTERED.Registration</spanx></t>
<t><spanx style="verb">UNSUBSCRIBE.Subscription</spanx></t>
<t><spanx style="verb">UNREGISTER.Registration</spanx></t>
<t><spanx style="verb">INVOCATION.Registration</spanx></t>
</list>
</t>
</section>

<section anchor="session-scope-ids" title="Session Scope IDs">
<t>
<list style="symbols">
<t><spanx style="verb">ERROR.Request</spanx></t>
<t><spanx style="verb">PUBLISH.Request</spanx></t>
<t><spanx style="verb">PUBLISHED.Request</spanx></t>
<t><spanx style="verb">SUBSCRIBE.Request</spanx></t>
<t><spanx style="verb">SUBSCRIBED.Request</spanx></t>
<t><spanx style="verb">UNSUBSCRIBE.Request</spanx></t>
<t><spanx style="verb">UNSUBSCRIBED.Request</spanx></t>
<t><spanx style="verb">CALL.Request</spanx></t>
<t><spanx style="verb">CANCEL.Request</spanx></t>
<t><spanx style="verb">RESULT.Request</spanx></t>
<t><spanx style="verb">REGISTER.Request</spanx></t>
<t><spanx style="verb">REGISTERED.Request</spanx></t>
<t><spanx style="verb">UNREGISTER.Request</spanx></t>
<t><spanx style="verb">UNREGISTERED.Request</spanx></t>
<t><spanx style="verb">INVOCATION.Request</spanx></t>
<t><spanx style="verb">INTERRUPT.Request</spanx></t>
<t><spanx style="verb">YIELD.Request</spanx></t>
</list>
</t>
</section>
</section>
</section>

<section anchor="serializations" title="Serializations">
<t>WAMP is a message based protocol that requires serialization of messages to octet sequences to be sent out on the wire.
</t>
<t>A message serialization format is assumed that (at least) provides the following types:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">integer</spanx> (non-negative)</t>
<t><spanx style="verb">string</spanx> (UTF-8 encoded Unicode)</t>
<t><spanx style="verb">bool</spanx></t>
<t><spanx style="verb">list</spanx></t>
<t><spanx style="verb">dict</spanx> (with string keys)</t>
</list>
</t>
<t><list style="empty">
<t>WAMP <spanx style="emph">itself</spanx> only uses the above types, e.g. it does not use the JSON data types <spanx style="verb">number</spanx> (non-integer) and <spanx style="verb">null</spanx>. The <spanx style="emph">application payloads</spanx> transmitted by WAMP (e.g. in call arguments or event payloads) may use other types a concrete serialization format supports.
</t>
</list></t>
<t>There is no required serialization or set of serializations for WAMP implementations (but each implementation MUST, of course, implement at least one serialization format). Routers SHOULD implement more than one serialization format, enabling components using different kinds of serializations to connect to each other.
</t>
<t>WAMP defines two bindings for message serialization:
</t>
<t>
<list style="numbers">
<t>JSON</t>
<t>MessagePack</t>
</list>
</t>
<t>Other bindings for serialization may be defined in future WAMP versions.
</t>

<section anchor="json" title="JSON">
<t>With JSON serialization, each WAMP message is serialized according to the JSON specification as described in RFC4627.
</t>
<t>Further, binary data follows a convention for conversion to JSON strings. For details see the Appendix.
</t>
</section>

<section anchor="messagepack" title="MessagePack">
<t>With MessagePack serialization, each WAMP message is serialized according to the MessagePack specification.
</t>
<t><list style="empty">
<t>Version 5 or later of MessagePack MUST BE used, since this version is able to differentiate between strings and binary values.
</t>
</list></t>
</section>
</section>

<section anchor="transports" title="Transports">
<t>WAMP assumes a transport with the following characteristics:
</t>
<t>
<list style="numbers">
<t>message-based</t>
<t>reliable</t>
<t>ordered</t>
<t>bidirectional (full-duplex)</t>
</list>
</t>
<t>There is no required transport or set of transports for WAMP implementations (but each implementation MUST, of course, implement at least one transport). Routers SHOULD implement more than one transport, enabling components using different kinds of transports to connect in an application.
</t>

<section anchor="websocket-transport" title="WebSocket Transport">
<t>The default transport binding for WAMP is WebSocket (<xref target="RFC6455"/>).
</t>
<t>In the Basic Profile, WAMP messages are transmitted as WebSocket messages: each WAMP message is transmitted as a separate WebSocket message (not WebSocket frame). The Advanced Profile may define other modes, e.g. a <spanx style="strong">batched mode</spanx> where multiple WAMP messages are transmitted via single WebSocket message.
</t>
<t>The WAMP protocol MUST BE negotiated during the WebSocket opening handshake between Peers using the WebSocket subprotocol negotiation mechanism (<xref target="RFC6455"/> section 4).
</t>
<t>WAMP uses the following WebSocket subprotocol identifiers for unbatched modes:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">wamp.2.json</spanx></t>
<t><spanx style="verb">wamp.2.msgpack</spanx></t>
</list>
</t>
<t>With <spanx style="verb">wamp.2.json</spanx>, <spanx style="emph">all</spanx> WebSocket messages MUST BE of type <spanx style="strong">text</spanx> (UTF8 encoded payload) and use the JSON message serialization.
</t>
<t>With <spanx style="verb">wamp.2.msgpack</spanx>, <spanx style="emph">all</spanx> WebSocket messages MUST BE of type <spanx style="strong">binary</spanx> and use the MessagePack message serialization.
</t>
<t><list style="empty">
<t>To avoid incompatibilities merely due to naming conflicts with WebSocket subprotocol identifiers, implementers SHOULD register identifiers for additional serialization formats with the official WebSocket subprotocol registry.
</t>
</list></t>
</section>

<section anchor="transport-and-session-lifetime" title="Transport and Session Lifetime">
<t>WAMP implementations MAY choose to tie the lifetime of the underlying transport connection for a WAMP connection to that of a WAMP session, i.e. establish a new transport-layer connection as part of each new session establishment. They MAY equally choose to allow re-use of a transport connection, allowing subsequent WAMP sessions to be established using the same transport connection.
</t>
<t>The diagram below illustrates the full transport connection and session lifecycle for an implementation which uses WebSocket over TCP as the transport and allows the re-use of a transport connection.
</t>

<figure align="left"><artwork align="left">
    ,------.                                    ,------.
    | Peer |                                    | Peer |
    `--+---'                                    `--+---'

                      TCP established
       |&lt;-----------------------------------------&gt;|
       |                                           |
       |               TLS established             |
       |+&lt;---------------------------------------&gt;+|
       |+                                         +|
       |+           WebSocket established         +|
       |+|&lt;-------------------------------------&gt;|+|
       |+|                                       |+|
       |+|            WAMP established           |+|
       |+|+&lt;-----------------------------------&gt;+|+|
       |+|+                                     +|+|
       |+|+                                     +|+|
       |+|+            WAMP closed              +|+|
       |+|+&lt;-----------------------------------&gt;+|+|
       |+|                                       |+|
       |+|                                       |+|
       |+|            WAMP established           |+|
       |+|+&lt;-----------------------------------&gt;+|+|
       |+|+                                     +|+|
       |+|+                                     +|+|
       |+|+            WAMP closed              +|+|
       |+|+&lt;-----------------------------------&gt;+|+|
       |+|                                       |+|
       |+|           WebSocket closed            |+|
       |+|&lt;-------------------------------------&gt;|+|
       |+                                         +|
       |+              TLS closed                 +|
       |+&lt;---------------------------------------&gt;+|
       |                                           |
       |               TCP closed                  |
       |&lt;-----------------------------------------&gt;|

    ,--+---.                                    ,--+---.
    | Peer |                                    | Peer |
    `------'                                    `------'
</artwork></figure>
</section>

<section anchor="protocol_errors" title="Protocol errors">
<t>WAMP implementations MUST close sessions (disposing all of their resources such as subscriptions and registrations) on protocol errors caused by offending peers.
</t>
<t>Following scenarios have to be considered protocol errors:
</t>
<t>
<list style="symbols">
<t>Receiving <spanx style="verb">WELCOME</spanx> message, after session was established.</t>
<t>Receiving <spanx style="verb">HELLO</spanx> message, after session was established.</t>
<t>Receiving <spanx style="verb">CHALLENGE</spanx> message, after session was established.</t>
<t>Receiving <spanx style="verb">GOODBYE</spanx> message, before session was established.</t>
<t>Receiving <spanx style="verb">ERROR</spanx> message, before session was established.</t>
<t>Receiving <spanx style="verb">ERROR</spanx> message with invalid REQUEST.Type.</t>
<t>Receiving <spanx style="verb">SUBSCRIBED</spanx> message, before session was established.</t>
<t>Receiving <spanx style="verb">UNSUBSCRIBED</spanx> message, before session was established.</t>
<t>Receiving <spanx style="verb">PUBLISHED</spanx> message, before session was established.</t>
<t>Receiving <spanx style="verb">RESULT</spanx> message, before session was established.</t>
<t>Receiving <spanx style="verb">REGISTERED</spanx> message, before session was established.</t>
<t>Receiving <spanx style="verb">UNREGISTERED</spanx> message, before session was established.</t>
<t>Receiving <spanx style="verb">INVOCATION</spanx> message, before session was established.</t>
<t>Receiving protocol incompatible message, such as empty array, invalid WAMP message type id, etc.</t>
<t>Catching error during message encoding/decoding.</t>
<t>Any other exceptional scenario explicitly defined in any relevant section of this specification below (such as receiving a second <spanx style="verb">HELLO</spanx> within the lifetime of a session).</t>
</list>
</t>
<t>In all such cases WAMP implementations:
</t>
<t>
<list style="numbers">
<t>MUST send an <spanx style="verb">ABORT</spanx> message to the offending peer, having reason <spanx style="verb">wamp.error.protocol_violation</spanx> and optional attributes in ABORT.Details such as a human readable error message.</t>
<t>MUST close the WAMP session by disposing any allocated subscriptions/registrations for that particular client and without waiting for or processing any messages subsequently received from the peer,</t>
<t>SHOULD also drop the WAMP connection at transport level (recommended to prevent denial of service attacks)</t>
</list>
</t>
</section>
</section>
</section>

<section anchor="messages" title="Messages">
<t>All WAMP messages are a <spanx style="verb">list</spanx> with a first element <spanx style="verb">MessageType</spanx> followed by one or more message type specific elements:
</t>

<figure align="left"><artwork align="left">
    [MessageType|integer, ... one or more message type specific
        elements ...]
</artwork></figure>
<t>The notation <spanx style="verb">Element|type</spanx> denotes a message element named <spanx style="verb">Element</spanx> of type <spanx style="verb">type</spanx>, where <spanx style="verb">type</spanx> is one of
</t>
<t>
<list style="symbols">
<t><spanx style="verb">uri</spanx>: a string URI as defined in <xref target="uris"/></t>
<t><spanx style="verb">id</spanx>: an integer ID as defined in <xref target="ids"/></t>
<t><spanx style="verb">integer</spanx>: a non-negative integer</t>
<t><spanx style="verb">string</spanx>: a Unicode string, including the empty string</t>
<t><spanx style="verb">bool</spanx>: a boolean value (<spanx style="verb">true</spanx> or <spanx style="verb">false</spanx>) - integers MUST NOT be used instead of boolean value</t>
<t><spanx style="verb">dict</spanx>: a dictionary (map) where keys MUST be strings, keys MUST be unique and serialization order is undefined (left to the serializer being used)</t>
<t><spanx style="verb">list</spanx>: a list (array) where items can be again any of this enumeration</t>
</list>
</t>
<t><spanx style="emph">Example</spanx>
</t>
<t>A <spanx style="verb">SUBSCRIBE</spanx> message has the following format
</t>

<figure align="left"><artwork align="left">
    [SUBSCRIBE, Request|id, Options|dict, Topic|uri]
</artwork></figure>
<t>Here is an example message conforming to the above format
</t>

<figure align="left"><artwork align="left">
    [32, 713845233, {}, "com.myapp.mytopic1"]
</artwork></figure>

<section anchor="extensibility" title="Extensibility">
<t>Some WAMP messages contain <spanx style="verb">Options|dict</spanx> or <spanx style="verb">Details|dict</spanx> elements. This allows for future extensibility and implementations that only provide subsets of functionality by ignoring unimplemented attributes. Keys in <spanx style="verb">Options</spanx> and <spanx style="verb">Details</spanx> MUST be of type <spanx style="verb">string</spanx> and MUST match the regular expression <spanx style="verb">[a-z][a-z0-9_]{2,}</spanx> for WAMP predefined keys. Implementations MAY use implementation-specific keys that MUST match the regular expression <spanx style="verb">_[a-z0-9_]{3,}</spanx>. Attributes unknown to an implementation MUST be ignored.
</t>
</section>

<section anchor="no-polymorphism" title="No Polymorphism">
<t>For a given <spanx style="verb">MessageType</spanx> and number of message elements the expected types are uniquely defined. Hence there are no polymorphic messages in WAMP. This leads to a message parsing and validation control flow that is efficient, simple to implement and simple to code for rigorous message format checking.
</t>
</section>

<section anchor="structure" title="Structure">
<t>The application payload (that is call arguments, call results, event payload etc) is always at the end of the message element list. The rationale is: Brokers and Dealers have no need to inspect (parse) the application payload. Their business is call/event routing. Having the application payload at the end of the list allows Brokers and Dealers to skip parsing it altogether. This can improve efficiency and performance.
</t>
</section>

<section anchor="message-definitions" title="Message Definitions">
<t>WAMP defines the following messages that are explained in detail in the following sections.
</t>
<t>The messages concerning the WAMP session itself are mandatory for all Peers, i.e. a Client MUST implement <spanx style="verb">HELLO</spanx>, <spanx style="verb">ABORT</spanx> and <spanx style="verb">GOODBYE</spanx>, while a Router MUST implement <spanx style="verb">WELCOME</spanx>, <spanx style="verb">ABORT</spanx> and <spanx style="verb">GOODBYE</spanx>.
</t>
<t>All other messages are mandatory per role, i.e. in an implementation that only provides a Client with the role of Publisher MUST additionally implement sending <spanx style="verb">PUBLISH</spanx> and receiving <spanx style="verb">PUBLISHED</spanx> and <spanx style="verb">ERROR</spanx> messages.
</t>

<section anchor="session-lifecycle" title="Session Lifecycle">

<section anchor="hello" title="HELLO">
<t>Sent by a Client to initiate opening of a WAMP session to a Router attaching to a Realm.
</t>

<figure align="left"><artwork align="left">
    [HELLO, Realm|uri, Details|dict]
</artwork></figure>
</section>

<section anchor="welcome" title="WELCOME">
<t>Sent by a Router to accept a Client. The WAMP session is now open.
</t>

<figure align="left"><artwork align="left">
    [WELCOME, Session|id, Details|dict]
</artwork></figure>
</section>

<section anchor="abort" title="ABORT">
<t>Sent by a Peer*to abort the opening of a WAMP session. No response is expected.
</t>

<figure align="left"><artwork align="left">
    [ABORT, Details|dict, Reason|uri]
</artwork></figure>
</section>

<section anchor="goodbye" title="GOODBYE">
<t>Sent by a Peer to close a previously opened WAMP session. Must be echo'ed by the receiving Peer.
</t>

<figure align="left"><artwork align="left">
    [GOODBYE, Details|dict, Reason|uri]
</artwork></figure>
</section>

<section anchor="error" title="ERROR">
<t>Error reply sent by a Peer as an error response to different kinds of requests.
</t>

<figure align="left"><artwork align="left">
    [ERROR, REQUEST.Type|int, REQUEST.Request|id, Details|dict,
        Error|uri]

    [ERROR, REQUEST.Type|int, REQUEST.Request|id, Details|dict,
        Error|uri, Arguments|list]

    [ERROR, REQUEST.Type|int, REQUEST.Request|id, Details|dict,
        Error|uri, Arguments|list, ArgumentsKw|dict]
</artwork></figure>
</section>
</section>

<section anchor="publish--subscribe" title="Publish &amp; Subscribe">

<section anchor="publish" title="PUBLISH">
<t>Sent by a Publisher to a Broker to publish an event.
</t>

<figure align="left"><artwork align="left">
    [PUBLISH, Request|id, Options|dict, Topic|uri]

    [PUBLISH, Request|id, Options|dict, Topic|uri,
        Arguments|list]

    [PUBLISH, Request|id, Options|dict, Topic|uri,
        Arguments|list, ArgumentsKw|dict]
</artwork></figure>
</section>

<section anchor="published" title="PUBLISHED">
<t>Acknowledge sent by a Broker to a Publisher for acknowledged publications.
</t>

<figure align="left"><artwork align="left">
    [PUBLISHED, PUBLISH.Request|id, Publication|id]
</artwork></figure>
</section>

<section anchor="subscribe" title="SUBSCRIBE">
<t>Subscribe request sent by a Subscriber to a Broker to subscribe to a topic.
</t>

<figure align="left"><artwork align="left">
    [SUBSCRIBE, Request|id, Options|dict, Topic|uri]
</artwork></figure>
</section>

<section anchor="subscribed" title="SUBSCRIBED">
<t>Acknowledge sent by a Broker to a Subscriber to acknowledge a subscription.
</t>

<figure align="left"><artwork align="left">
    [SUBSCRIBED, SUBSCRIBE.Request|id, Subscription|id]
</artwork></figure>
</section>

<section anchor="unsubscribe" title="UNSUBSCRIBE">
<t>Unsubscribe request sent by a Subscriber to a Broker to unsubscribe a subscription.
</t>

<figure align="left"><artwork align="left">
    [UNSUBSCRIBE, Request|id, SUBSCRIBED.Subscription|id]
</artwork></figure>
</section>

<section anchor="unsubscribed" title="UNSUBSCRIBED">
<t>Acknowledge sent by a Broker to a Subscriber to acknowledge unsubscription.
</t>

<figure align="left"><artwork align="left">
    [UNSUBSCRIBED, UNSUBSCRIBE.Request|id]
</artwork></figure>
</section>

<section anchor="event" title="EVENT">
<t>Event dispatched by Broker to Subscribers for subscriptions the event was matching.
</t>

<figure align="left"><artwork align="left">
    [EVENT, SUBSCRIBED.Subscription|id, PUBLISHED.Publication|id,
        Details|dict]

    [EVENT, SUBSCRIBED.Subscription|id, PUBLISHED.Publication|id,
        Details|dict, PUBLISH.Arguments|list]

    [EVENT, SUBSCRIBED.Subscription|id, PUBLISHED.Publication|id,
        Details|dict, PUBLISH.Arguments|list,
        PUBLISH.ArgumentsKw|dict]
</artwork></figure>
<t><list style="empty">
<t>An event is dispatched to a Subscriber for a given <spanx style="verb">Subscription|id</spanx> only once. On the other hand, a Subscriber that holds subscriptions with different <spanx style="verb">Subscription|id</spanx>s that all match a given event will receive the event on each matching subscription.
</t>
</list></t>
</section>
</section>

<section anchor="routed-remote-procedure-calls" title="Routed Remote Procedure Calls">

<section anchor="call" title="CALL">
<t>Call as originally issued by the Caller to the Dealer.
</t>

<figure align="left"><artwork align="left">
  [CALL, Request|id, Options|dict, Procedure|uri]

  [CALL, Request|id, Options|dict, Procedure|uri, Arguments|list]

  [CALL, Request|id, Options|dict, Procedure|uri, Arguments|list,
      ArgumentsKw|dict]
</artwork></figure>
</section>

<section anchor="result" title="RESULT">
<t>Result of a call as returned by Dealer to Caller.
</t>

<figure align="left"><artwork align="left">
    [RESULT, CALL.Request|id, Details|dict]

    [RESULT, CALL.Request|id, Details|dict, YIELD.Arguments|list]

    [RESULT, CALL.Request|id, Details|dict, YIELD.Arguments|list,
        YIELD.ArgumentsKw|dict]
</artwork></figure>
</section>

<section anchor="register" title="REGISTER">
<t>A Callees request to register an endpoint at a Dealer.
</t>

<figure align="left"><artwork align="left">
    [REGISTER, Request|id, Options|dict, Procedure|uri]
</artwork></figure>
</section>

<section anchor="registered" title="REGISTERED">
<t>Acknowledge sent by a Dealer to a Callee for successful registration.
</t>

<figure align="left"><artwork align="left">
    [REGISTERED, REGISTER.Request|id, Registration|id]
</artwork></figure>
</section>

<section anchor="unregister" title="UNREGISTER">
<t>A Callees request to unregister a previously established registration.
</t>

<figure align="left"><artwork align="left">
    [UNREGISTER, Request|id, REGISTERED.Registration|id]
</artwork></figure>
</section>

<section anchor="unregistered" title="UNREGISTERED">
<t>Acknowledge sent by a Dealer to a Callee for successful unregistration.
</t>

<figure align="left"><artwork align="left">
    [UNREGISTERED, UNREGISTER.Request|id]
</artwork></figure>
</section>

<section anchor="invocation" title="INVOCATION">
<t>Actual invocation of an endpoint sent by Dealer to a Callee.
</t>

<figure align="left"><artwork align="left">
    [INVOCATION, Request|id, REGISTERED.Registration|id,
        Details|dict]

    [INVOCATION, Request|id, REGISTERED.Registration|id,
        Details|dict, C* Arguments|list]

    [INVOCATION, Request|id, REGISTERED.Registration|id,
        Details|dict, CALL.Arguments|list, CALL.ArgumentsKw|dict]
</artwork></figure>
</section>

<section anchor="yield" title="YIELD">
<t>Actual yield from an endpoint sent by a Callee to Dealer.
</t>

<figure align="left"><artwork align="left">
    [YIELD, INVOCATION.Request|id, Options|dict]

    [YIELD, INVOCATION.Request|id, Options|dict, Arguments|list]

    [YIELD, INVOCATION.Request|id, Options|dict, Arguments|list,
        ArgumentsKw|dict]
</artwork></figure>
</section>
</section>
</section>

<section anchor="message-codes-and-direction" title="Message Codes and Direction">
<t>The following table lists the message type code for all 25 messages defined in the WAMP basic profile and their direction between peer roles.
</t>
<t>Reserved codes may be used to identify additional message types in future standards documents.
</t>
<t><list style="empty">
<t>&quot;Tx&quot; indicates the message is sent by the respective role, and &quot;Rx&quot; indicates the message is received by the respective role.
</t>
</list></t>
<texttable>
<ttcol align="center">Cod</ttcol>
<ttcol align="center">Message</ttcol>
<ttcol align="center">Pub</ttcol>
<ttcol align="center">Brk</ttcol>
<ttcol align="center">Subs</ttcol>
<ttcol align="center">Calr</ttcol>
<ttcol align="center">Dealr</ttcol>
<ttcol align="center">Callee</ttcol>

<c>1</c><c><spanx style="verb">HELLO</spanx></c><c>Tx</c><c>Rx</c><c>Tx</c><c>Tx</c><c>Rx</c><c>Tx</c>
<c>2</c><c><spanx style="verb">WELCOME</spanx></c><c>Rx</c><c>Tx</c><c>Rx</c><c>Rx</c><c>Tx</c><c>Rx</c>
<c>3</c><c><spanx style="verb">ABORT</spanx></c><c>Rx</c><c>TxRx</c><c>Rx</c><c>Rx</c><c>TxRx</c><c>Rx</c>
<c>6</c><c><spanx style="verb">GOODBYE</spanx></c><c>TxRx</c><c>TxRx</c><c>TxRx</c><c>TxRx</c><c>TxRx</c><c>TxRx</c>
<c></c><c></c><c></c><c></c><c></c><c></c><c></c><c></c>
<c>8</c><c><spanx style="verb">ERROR</spanx></c><c>Rx</c><c>Tx</c><c>Rx</c><c>Rx</c><c>TxRx</c><c>TxRx</c>
<c></c><c></c><c></c><c></c><c></c><c></c><c></c><c></c>
<c>16</c><c><spanx style="verb">PUBLISH</spanx></c><c>Tx</c><c>Rx</c><c></c><c></c><c></c><c></c>
<c>17</c><c><spanx style="verb">PUBLISHED</spanx></c><c>Rx</c><c>Tx</c><c></c><c></c><c></c><c></c>
<c></c><c></c><c></c><c></c><c></c><c></c><c></c><c></c>
<c>32</c><c><spanx style="verb">SUBSCRIBE</spanx></c><c></c><c>Rx</c><c>Tx</c><c></c><c></c><c></c>
<c>33</c><c><spanx style="verb">SUBSCRIBED</spanx></c><c></c><c>Tx</c><c>Rx</c><c></c><c></c><c></c>
<c>34</c><c><spanx style="verb">UNSUBSCRIBE</spanx></c><c></c><c>Rx</c><c>Tx</c><c></c><c></c><c></c>
<c>35</c><c><spanx style="verb">UNSUBSCRIBED</spanx></c><c></c><c>Tx</c><c>Rx</c><c></c><c></c><c></c>
<c>36</c><c><spanx style="verb">EVENT</spanx></c><c></c><c>Tx</c><c>Rx</c><c></c><c></c><c></c>
<c></c><c></c><c></c><c></c><c></c><c></c><c></c><c></c>
<c>48</c><c><spanx style="verb">CALL</spanx></c><c></c><c></c><c></c><c>Tx</c><c>Rx</c><c></c>
<c>50</c><c><spanx style="verb">RESULT</spanx></c><c></c><c></c><c></c><c>Rx</c><c>Tx</c><c></c>
<c></c><c></c><c></c><c></c><c></c><c></c><c></c><c></c>
<c>64</c><c><spanx style="verb">REGISTER</spanx></c><c></c><c></c><c></c><c></c><c>Rx</c><c>Tx</c>
<c>65</c><c><spanx style="verb">REGISTERED</spanx></c><c></c><c></c><c></c><c></c><c>Tx</c><c>Rx</c>
<c>66</c><c><spanx style="verb">UNREGISTER</spanx></c><c></c><c></c><c></c><c></c><c>Rx</c><c>Tx</c>
<c>67</c><c><spanx style="verb">UNREGISTERED</spanx></c><c></c><c></c><c></c><c></c><c>Tx</c><c>Rx</c>
<c>68</c><c><spanx style="verb">INVOCATION</spanx></c><c></c><c></c><c></c><c></c><c>Tx</c><c>Rx</c>
<c>70</c><c><spanx style="verb">YIELD</spanx></c><c></c><c></c><c></c><c></c><c>Rx</c><c>Tx</c>
</texttable>
</section>

<section anchor="extension-messages" title="Extension Messages">
<t>WAMP uses type codes from the core range [0, 255]. Implementations MAY define and use implementation specific messages with message type codes from the extension message range [256, 1023]. For example, a router MAY implement router-to-router communication by using extension messages.
</t>
</section>

<section anchor="empty-arguments-and-keyword-arguments" title="Empty Arguments and Keyword Arguments">
<t>Implementations SHOULD avoid sending empty <spanx style="verb">Arguments</spanx> lists.
</t>
<t>E.g. a <spanx style="verb">CALL</spanx> message
</t>

<figure align="left"><artwork align="left">
    [CALL, Request|id, Options|dict, Procedure|uri,
        Arguments|list]
</artwork></figure>
<t>where <spanx style="verb">Arguments == []</spanx> SHOULD be avoided, and instead
</t>

<figure align="left"><artwork align="left">
    [CALL, Request|id, Options|dict, Procedure|uri]
</artwork></figure>
<t>SHOULD be sent.
</t>
<t>Implementations SHOULD avoid sending empty <spanx style="verb">ArgumentsKw</spanx> dictionaries.
</t>
<t>E.g. a <spanx style="verb">CALL</spanx> message
</t>

<figure align="left"><artwork align="left">
    [CALL, Request|id, Options|dict, Procedure|uri,
        Arguments|list, ArgumentsKw|dict]
</artwork></figure>
<t>where <spanx style="verb">ArgumentsKw == {}</spanx> SHOULD be avoided, and instead
</t>

<figure align="left"><artwork align="left">
    [CALL, Request|id, Options|dict, Procedure|uri,
        Arguments|list]
</artwork></figure>
<t>SHOULD be sent when <spanx style="verb">Arguments</spanx> is non-empty.
</t>
</section>
</section>

<section anchor="sessions" title="Sessions">
<t>The message flow between Clients and Routers for opening and closing WAMP sessions involves the following messages:
</t>
<t>
<list style="numbers">
<t><spanx style="verb">HELLO</spanx></t>
<t><spanx style="verb">WELCOME</spanx></t>
<t><spanx style="verb">ABORT</spanx></t>
<t><spanx style="verb">GOODBYE</spanx></t>
</list>
</t>

<section anchor="session-establishment" title="Session Establishment">

<section anchor="hello-1" title="HELLO">
<t>After the underlying transport has been established, the opening of a WAMP session is initiated by the Client sending a <spanx style="verb">HELLO</spanx> message to the Router
</t>

<figure align="left"><artwork align="left">
    [HELLO, Realm|uri, Details|dict]
</artwork></figure>
<t>where
</t>
<t>
<list style="symbols">
<t><spanx style="verb">Realm</spanx> is a string identifying the realm this session should attach to</t>
<t><spanx style="verb">Details</spanx> is a dictionary that allows to provide additional opening information (see below).</t>
</list>
</t>
<t>The <spanx style="verb">HELLO</spanx> message MUST be the very first message sent by the Client after the transport has been established.
</t>
<t>In the WAMP Basic Profile without session authentication the Router will reply with a <spanx style="verb">WELCOME</spanx> or <spanx style="verb">ABORT</spanx> message.
</t>

<figure align="left"><artwork align="left">
    ,------.          ,------.
    |Client|          |Router|
    `--+---'          `--+---'
       |      HELLO      |
       | ----------------&gt;
       |                 |
       |     WELCOME     |
       | &lt;----------------
    ,--+---.          ,--+---.
    |Client|          |Router|
    `------'          `------'
</artwork></figure>
<t>A WAMP session starts its lifetime when the Router has sent a <spanx style="verb">WELCOME</spanx> message to the Client, and ends when the underlying transport closes or when the session is closed explicitly by either peer sending the <spanx style="verb">GOODBYE</spanx> message (see below).
</t>
<t>It is a <xref target="protocol_errors"/> to receive a second <spanx style="verb">HELLO</spanx> message during the lifetime of the session and the Peer MUST close the session if that happens.
</t>

<section anchor="client-role-and-feature-announcement" title="Client: Role and Feature Announcement">
<t>WAMP uses <spanx style="emph">Role &amp; Feature announcement</spanx> instead of <spanx style="emph">protocol versioning</spanx> to allow
</t>
<t>
<list style="symbols">
<t>implementations only supporting subsets of functionality</t>
<t>future extensibility</t>
</list>
</t>
<t>A Client must announce the roles it supports via <spanx style="verb">Hello.Details.roles|dict</spanx>, with a key mapping to a <spanx style="verb">Hello.Details.roles.&lt;role&gt;|dict</spanx> where <spanx style="verb">&lt;role&gt;</spanx> can be:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">publisher</spanx></t>
<t><spanx style="verb">subscriber</spanx></t>
<t><spanx style="verb">caller</spanx></t>
<t><spanx style="verb">callee</spanx></t>
</list>
</t>
<t>A Client can support any combination of the above roles but must support at least one role.
</t>
<t>The <spanx style="verb">&lt;role&gt;|dict</spanx> is a dictionary describing features supported by the peer for that role.
</t>
<t>This MUST be empty for WAMP Basic Profile implementations, and MUST be used by implementations implementing parts of the Advanced Profile to list the specific set of features they support.
</t>
<t><spanx style="emph">Example: A Client that implements the Publisher and Subscriber roles of the WAMP Basic Profile.</spanx>
</t>

<figure align="left"><artwork align="left">
    [1, "somerealm", {
      "roles": {
          "publisher": {},
          "subscriber": {}
      }
    }]
</artwork></figure>
</section>
</section>

<section anchor="welcome-1" title="WELCOME">
<t>A Router completes the opening of a WAMP session by sending a <spanx style="verb">WELCOME</spanx> reply message to the Client.
</t>

<figure align="left"><artwork align="left">
    [WELCOME, Session|id, Details|dict]
</artwork></figure>
<t>where
</t>
<t>
<list style="symbols">
<t><spanx style="verb">Session</spanx> MUST be a randomly generated ID specific to the WAMP session. This applies for the lifetime of the session.</t>
<t><spanx style="verb">Details</spanx> is a dictionary that allows to provide additional information regarding the open session (see below).</t>
</list>
</t>
<t>In the WAMP Basic Profile without session authentication, a <spanx style="verb">WELCOME</spanx> message MUST be the first message sent by the Router, directly in response to a <spanx style="verb">HELLO</spanx> message received from the Client. Extensions in the Advanced Profile MAY include intermediate steps and messages for authentication.
</t>
<t><list style="empty">
<t>Note. The behavior if a requested <spanx style="verb">Realm</spanx> does not presently exist is router-specific. A router may e.g. automatically create the realm, or deny the establishment of the session with a <spanx style="verb">ABORT</spanx> reply message.
</t>
</list></t>

<section anchor="router-role-and-feature-announcement" title="Router: Role and Feature Announcement">
<t>Similar to a Client announcing Roles and Features supported in the `<spanx style="verb">HELLO</spanx> message, a Router announces its supported Roles and Features in the <spanx style="verb">WELCOME</spanx> message.
</t>
<t>A Router MUST announce the roles it supports via <spanx style="verb">Welcome.Details.roles|dict</spanx>, with a key mapping to a <spanx style="verb">Welcome.Details.roles.&lt;role&gt;|dict</spanx> where <spanx style="verb">&lt;role&gt;</spanx> can be:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">broker</spanx></t>
<t><spanx style="verb">dealer</spanx></t>
</list>
</t>
<t>A Router must support at least one role, and MAY support both roles.
</t>
<t>The <spanx style="verb">&lt;role&gt;|dict</spanx> is a dictionary describing features supported by the peer for that role. With WAMP Basic Profile implementations, this MUST be empty, but MUST be used by implementations implementing parts of the Advanced Profile to list the specific set of features they support
</t>
<t><spanx style="emph">Example: A Router implementing the Broker role of the WAMP Basic Profile.</spanx>
</t>

<figure align="left"><artwork align="left">
    [2, 9129137332, {
       "roles": {
          "broker": {}
       }
    }]
</artwork></figure>
</section>
</section>

<section anchor="abort-1" title="ABORT">
<t>Both the Router and the Client may abort a WAMP session by sending an <spanx style="verb">ABORT</spanx> message.
</t>

<figure align="left"><artwork align="left">
    [ABORT, Details|dict, Reason|uri]
</artwork></figure>
<t>where
</t>
<t>
<list style="symbols">
<t><spanx style="verb">Reason</spanx> MUST be an URI.</t>
<t><spanx style="verb">Details</spanx> MUST be a dictionary that allows to provide additional, optional closing information (see below).</t>
</list>
</t>
<t>No response to an <spanx style="verb">ABORT</spanx> message is expected.
</t>
<t>There are few scenarios, when<spanx style="verb">ABORT</spanx> is used:
</t>
<t>
<list style="symbols">
<t>During session opening, if peer decided to abort connect.</t>
</list>
</t>

<figure align="left"><artwork align="left">
    ,------.          ,------.
    |Client|          |Router|
    `--+---'          `--+---'
       |      HELLO      |
       | ----------------&gt;
       |                 |
       |      ABORT      |
       | &lt;----------------
    ,--+---.          ,--+---.
    |Client|          |Router|
    `------'          `------'
</artwork></figure>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [3, {"message": "The realm does not exist."},
        "wamp.error.no_such_realm"]
</artwork></figure>
<t>
<list style="symbols">
<t>After session is opened, whenprotocol violation happens (see &quot;Protocol errors&quot; section).</t>
</list>
</t>
<t><spanx style="emph">Examples</spanx>
</t>
<t>
<list style="symbols">
<t>Router received second HELLO message.</t>
</list>
</t>

<figure align="left"><artwork align="left">
    [3, {"message": "Received HELLO message after session was established."},
        "wamp.error.protocol_violation"]
</artwork></figure>
<t>
<list style="symbols">
<t>Client peer received second WELCOME message</t>
</list>
</t>

<figure align="left"><artwork align="left">
    [3, {"message": "Received WELCOME message after session was established."},
        "wamp.error.protocol_violation"]
</artwork></figure>
</section>
</section>

<section anchor="session-closing" title="Session Closing">
<t>A WAMP session starts its lifetime with the Router sending a <spanx style="verb">WELCOME</spanx> message to the Client and ends when the underlying transport disappears or when the WAMP session is closed explicitly by a <spanx style="verb">GOODBYE</spanx> message sent by one Peer and a <spanx style="verb">GOODBYE</spanx> message sent from the other Peer in response.
</t>

<figure align="left"><artwork align="left">
    [GOODBYE, Details|dict, Reason|uri]
</artwork></figure>
<t>where
</t>
<t>
<list style="symbols">
<t><spanx style="verb">Reason</spanx> MUST be an URI.</t>
<t><spanx style="verb">Details</spanx> MUST be a dictionary that allows to provide additional, optional closing information (see below).</t>
</list>
</t>

<figure align="left"><artwork align="left">
    ,------.          ,------.
    |Client|          |Router|
    `--+---'          `--+---'
       |     GOODBYE     |
       | ----------------&gt;
       |                 |
       |     GOODBYE     |
       | &lt;----------------
    ,--+---.          ,--+---.
    |Client|          |Router|
    `------'          `------'
</artwork></figure>

<figure align="left"><artwork align="left">
    ,------.          ,------.
    |Client|          |Router|
    `--+---'          `--+---'
       |     GOODBYE     |
       | &lt;----------------
       |                 |
       |     GOODBYE     |
       | ----------------&gt;
    ,--+---.          ,--+---.
    |Client|          |Router|
    `------'          `------'
</artwork></figure>
<t><spanx style="emph">Example</spanx>. One Peer initiates closing
</t>

<figure align="left"><artwork align="left">
    [6, {"message": "The host is shutting down now."},
        "wamp.close.system_shutdown"]
</artwork></figure>
<t>and the other peer replies
</t>

<figure align="left"><artwork align="left">
    [6, {}, "wamp.close.goodbye_and_out"]
</artwork></figure>
<t><spanx style="emph">Example</spanx>. One Peer initiates closing
</t>

<figure align="left"><artwork align="left">
    [6, {}, "wamp.close.close_realm"]
</artwork></figure>
<t>and the other peer replies
</t>

<figure align="left"><artwork align="left">
    [6, {}, "wamp.close.goodbye_and_out"]
</artwork></figure>

<section anchor="difference-between-abort-and-goodbye" title="Difference between ABORT and GOODBYE">
<t>The differences between <spanx style="verb">ABORT</spanx> and <spanx style="verb">GOODBYE</spanx> messages is that<spanx style="verb">ABORT</spanx> is never replied to by a Peer, whereas <spanx style="verb">GOODBYE</spanx> must be replied to by the receiving Peer.
</t>
<t><list style="empty">
<t>Though <spanx style="verb">ABORT</spanx> and <spanx style="verb">GOODBYE</spanx> are structurally identical, using different message types serves to reduce overloaded meaning of messages and simplify message handling code.
</t>
</list></t>
</section>

<section anchor="session-statechart" title="Session Statechart">
<t>The following state chart gives the states that a WAMP peer can be in during the session lifetime cycle.
</t>

<figure align="left"><artwork align="left">
+--------------+
+--------(6)-------------&gt;|
||CLOSED&lt;--------------------------+
|+------(4)-------------&gt;&lt;---+|
||+--------------+||
|||||
||(1)(7)|
|||||
||+--------v-----+|(11)
|||+---+|
||+------------+ESTABLISHING+----------------+|
|||||||
|||+--------------+||
||||(10)|
|||(9)||
||||||
||(2)+--------v-----++--------v-------+|
||||||||
|||+------&gt;FAILED&lt;--(13)-+CHALLENGING /+-+
|||||||AUTHENTICATING|
||||+--------------++----------------+
|||(8)|
|||||
|||||
||+-------v-------+|
|||&lt;-------------------(12)-------------+
|||ESTABLISHED|
|||+--------------+
||+---------------+|
||||
||(3)(5)
||||
||+-------v-------++--------v-----+
|||+--+||
|+-+SHUTTINGDOWN|||CLOSING|
|||(14)||
|+-------^-------+|+--------------+
||----------+|
+----------------------------------+
</artwork></figure>
<texttable>
<ttcol align="center">#</ttcol>
<ttcol align="center">State</ttcol>

<c>1</c><c>Sent HELLO</c>
<c>2</c><c>Received WELCOME</c>
<c>3</c><c>Sent GOODBYE</c>
<c>4</c><c>Received GOODBYE</c>
<c>5</c><c>Received GOODBYE</c>
<c>6</c><c>Sent GOODBYE</c>
<c>7</c><c>Received invalid HELLO / Send ABORT</c>
<c>8</c><c>Received HELLO or AUTHENTICATE</c>
<c>9</c><c>Received other</c>
<c>10</c><c>Received valid HELLO [needs authentication] / Send CHALLENGE</c>
<c>11</c><c>Received invalid AUTHENTICATE / Send ABORT</c>
<c>12</c><c>Received valid AUTHENTICATE / Send WELCOME</c>
<c>13</c><c>Received other</c>
<c>14</c><c>Received other / ignore</c>
</texttable>
</section>
</section>
</section>

<section anchor="agent-identification" title="Agent Identification">
<t>When a software agent operates in a network protocol, it often identifies itself, its application type, operating system, software vendor, or software revision, by submitting a characteristic identification string to its operating peer.
</t>
<t>Similar to what browsers do with the <spanx style="verb">User-Agent</spanx> HTTP header, both the <spanx style="verb">HELLO</spanx> and the <spanx style="verb">WELCOME</spanx> message MAY disclose the WAMP implementation in use to its peer:
</t>

<figure align="left"><artwork align="left">
    HELLO.Details.agent|string
</artwork></figure>
<t>and
</t>

<figure align="left"><artwork align="left">
    WELCOME.Details.agent|string
</artwork></figure>
<t><spanx style="emph">Example: A Client &quot;HELLO&quot; message.</spanx>
</t>

<figure align="left"><artwork align="left">
    [1, "somerealm", {
         "agent": "AutobahnJS-0.9.14",
         "roles": {
            "subscriber": {},
            "publisher": {}
         }
    }]
</artwork></figure>
<t><spanx style="emph">Example: A Router &quot;WELCOME&quot; message.</spanx>
</t>

<figure align="left"><artwork align="left">
    [2, 9129137332, {
        "agent": "Crossbar.io-0.10.11",
        "roles": {
          "broker": {}
        }
    }]
</artwork></figure>
</section>

<section anchor="publish-and-subscribe" title="Publish and Subscribe">
<t>All of the following features for Publish &amp; Subscribe are mandatory for WAMP Basic Profile implementations supporting the respective roles, i.e. <spanx style="emph">Publisher</spanx>, <spanx style="emph">Subscriber</spanx> and <spanx style="emph">Dealer</spanx>.
</t>

<section anchor="subscribing-and-unsubscribing" title="Subscribing and Unsubscribing">
<t>The message flow between Clients implementing the role of Subscriber and Routers implementing the role of Broker for subscribing and unsubscribing involves the following messages:
</t>
<t>
<list style="numbers">
<t><spanx style="verb">SUBSCRIBE</spanx></t>
<t><spanx style="verb">SUBSCRIBED</spanx></t>
<t><spanx style="verb">UNSUBSCRIBE</spanx></t>
<t><spanx style="verb">UNSUBSCRIBED</spanx></t>
<t><spanx style="verb">ERROR</spanx></t>
</list>
</t>

<figure align="left"><artwork align="left">
    ,---------.          ,------.             ,----------.
    |Publisher|          |Broker|             |Subscriber|
    `----+----'          `--+---'             `----+-----'
         |                  |                      |
         |                  |                      |
         |                  |       SUBSCRIBE      |
         |                  | &lt;---------------------
         |                  |                      |
         |                  |  SUBSCRIBED or ERROR |
         |                  | ---------------------&gt;
         |                  |                      |
         |                  |                      |
         |                  |                      |
         |                  |                      |
         |                  |      UNSUBSCRIBE     |
         |                  | &lt;---------------------
         |                  |                      |
         |                  | UNSUBSCRIBED or ERROR|
         |                  | ---------------------&gt;
    ,----+----.          ,--+---.             ,----+-----.
    |Publisher|          |Broker|             |Subscriber|
    `---------'          `------'             `----------'
</artwork></figure>
<t>A Subscriber may subscribe to zero, one or more topics, and a Publisher publishes to topics without knowledge of subscribers.
</t>
<t>Upon subscribing to a topic via the <spanx style="verb">SUBSCRIBE</spanx> message, a Subscriber will receive any future events published to the respective topic by Publishers, and will receive those events asynchronously.
</t>
<t>A subscription lasts for the duration of a session, unless a Subscriber opts out from a previously established subscription via the <spanx style="verb">UNSUBSCRIBE</spanx> message.
</t>
<t><list style="empty">
<t>A Subscriber may have more than one event handler attached to the same subscription. This can be implemented in different ways: a) a Subscriber can recognize itself that it is already subscribed and just attach another handler to the subscription for incoming events, b) or it can send a new <spanx style="verb">SUBSCRIBE</spanx> message to broker (as it would be first) and upon receiving a <spanx style="verb">SUBSCRIBED.Subscription|id</spanx> it already knows about, attach the handler to the existing subscription
</t>
</list></t>

<section anchor="subscribe-1" title="SUBSCRIBE">
<t>A Subscriber communicates its interest in a topic to a Broker by sending a <spanx style="verb">SUBSCRIBE</spanx> message:
</t>

<figure align="left"><artwork align="left">
    [SUBSCRIBE, Request|id, Options|dict, Topic|uri]
</artwork></figure>
<t>where
</t>
<t>
<list style="symbols">
<t><spanx style="verb">Request</spanx> MUST be a random, ephemeral ID chosen by the Subscriber and used to correlate the Broker's response with the request.</t>
<t><spanx style="verb">Options</spanx> MUST be a dictionary that allows to provide additional subscription request details in a extensible way. This is described further below.</t>
<t><spanx style="verb">Topic</spanx> is the topic the Subscriber wants to subscribe to and MUST be an URI.</t>
</list>
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [32, 713845233, {}, "com.myapp.mytopic1"]
</artwork></figure>
<t>A Broker, receiving a <spanx style="verb">SUBSCRIBE</spanx> message, can fullfill or reject the subscription, so it answers with <spanx style="verb">SUBSCRIBED</spanx> or <spanx style="verb">ERROR</spanx> messages.
</t>
</section>

<section anchor="subscribed-1" title="SUBSCRIBED">
<t>If the Broker is able to fulfill and allow the subscription, it answers by sending a <spanx style="verb">SUBSCRIBED</spanx> message to the Subscriber
</t>

<figure align="left"><artwork align="left">
    [SUBSCRIBED, SUBSCRIBE.Request|id, Subscription|id]
</artwork></figure>
<t>where
</t>
<t>
<list style="symbols">
<t><spanx style="verb">SUBSCRIBE.Request</spanx> MUST be the ID from the original request.</t>
<t><spanx style="verb">Subscription</spanx> MUST be an ID chosen by the Broker for the subscription.</t>
</list>
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [33, 713845233, 5512315355]
</artwork></figure>
<t><list style="empty">
<t>Note. The <spanx style="verb">Subscription</spanx> ID chosen by the broker need not be unique to the subscription of a single Subscriber, but may be assigned to the <spanx style="verb">Topic</spanx>, or the combination of the <spanx style="verb">Topic</spanx> and some or all <spanx style="verb">Options</spanx>, such as the topic pattern matching method to be used. Then this ID may be sent to all Subscribers for the <spanx style="verb">Topic</spanx> or <spanx style="verb">Topic</spanx> /  <spanx style="verb">Options</spanx> combination. This allows the Broker to serialize an event to be delivered only once for all actual receivers of the event.
</t>
<t>In case of receiving a <spanx style="verb">SUBSCRIBE</spanx> message from the same Subscriber and to already subscribed topic, Broker should answer with <spanx style="verb">SUBSCRIBED</spanx> message, containing the existing <spanx style="verb">Subscription|id</spanx>.
</t>
</list></t>
</section>

<section anchor="subscribe-error" title="Subscribe ERROR">
<t>When the request for subscription cannot be fulfilled by the Broker, the Broker sends back an <spanx style="verb">ERROR</spanx> message to the Subscriber
</t>

<figure align="left"><artwork align="left">
    [ERROR, SUBSCRIBE, SUBSCRIBE.Request|id, Details|dict,
        Error|uri]
</artwork></figure>
<t>where
</t>
<t>
<list style="symbols">
<t><spanx style="verb">SUBSCRIBE.Request</spanx> MUST be the ID from the original request.</t>
<t><spanx style="verb">Error</spanx> MUST be an URI that gives the error of why the request could not be fulfilled.</t>
</list>
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [8, 32, 713845233, {}, "wamp.error.not_authorized"]
</artwork></figure>
</section>

<section anchor="unsubscribe-1" title="UNSUBSCRIBE">
<t>When a Subscriber is no longer interested in receiving events for a subscription it sends an <spanx style="verb">UNSUBSCRIBE</spanx> message
</t>

<figure align="left"><artwork align="left">
    [UNSUBSCRIBE, Request|id, SUBSCRIBED.Subscription|id]
</artwork></figure>
<t>where
</t>
<t>
<list style="symbols">
<t><spanx style="verb">Request</spanx> MUST be a random, ephemeral ID chosen by the Subscriber and used to correlate the Broker's response with the request.</t>
<t><spanx style="verb">SUBSCRIBED.Subscription</spanx> MUST be the ID for the subscription to unsubscribe from, originally handed out by the Broker to the Subscriber.</t>
</list>
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [34, 85346237, 5512315355]
</artwork></figure>
</section>

<section anchor="unsubscribed-1" title="UNSUBSCRIBED">
<t>Upon successful unsubscription, the Broker sends an <spanx style="verb">UNSUBSCRIBED</spanx> message to the Subscriber
</t>

<figure align="left"><artwork align="left">
    [UNSUBSCRIBED, UNSUBSCRIBE.Request|id]
</artwork></figure>
<t>where
</t>
<t>
<list style="symbols">
<t><spanx style="verb">UNSUBSCRIBE.Request</spanx> MUST be the ID from the original request.</t>
</list>
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [35, 85346237]
</artwork></figure>
</section>

<section anchor="unsubscribe-error" title="Unsubscribe ERROR">
<t>When the request fails, the Broker sends an <spanx style="verb">ERROR</spanx>
</t>

<figure align="left"><artwork align="left">
    [ERROR, UNSUBSCRIBE, UNSUBSCRIBE.Request|id, Details|dict,
        Error|uri]
</artwork></figure>
<t>where
</t>
<t>
<list style="symbols">
<t><spanx style="verb">UNSUBSCRIBE.Request</spanx> MUST be the ID from the original request.</t>
<t><spanx style="verb">Error</spanx> MUST be an URI that gives the error of why the request could not be fulfilled.</t>
</list>
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [8, 34, 85346237, {}, "wamp.error.no_such_subscription"]
</artwork></figure>
</section>
</section>

<section anchor="publishing-and-events" title="Publishing and Events">
<t>The message flow between Publishers, a Broker and Subscribers for publishing to topics and dispatching events involves the following messages:
</t>
<t>
<list style="numbers">
<t><spanx style="verb">PUBLISH</spanx></t>
<t><spanx style="verb">PUBLISHED</spanx></t>
<t><spanx style="verb">EVENT</spanx></t>
<t><spanx style="verb">ERROR</spanx></t>
</list>
</t>

<figure align="left"><artwork align="left">
    ,---------.          ,------.          ,----------.
    |Publisher|          |Broker|          |Subscriber|
    `----+----'          `--+---'          `----+-----'
         |     PUBLISH      |                   |
         |------------------&gt;                   |
         |                  |                   |
         |PUBLISHED or ERROR|                   |
         |&lt;------------------                   |
         |                  |                   |
         |                  |       EVENT       |
         |                  | ------------------&gt;
    ,----+----.          ,--+---.          ,----+-----.
    |Publisher|          |Broker|          |Subscriber|
    `---------'          `------'          `----------'
</artwork></figure>

<section anchor="publish-1" title="PUBLISH">
<t>When a Publisher requests to publish an event to some topic, it sends a <spanx style="verb">PUBLISH</spanx> message to a Broker:
</t>

<figure align="left"><artwork align="left">
    [PUBLISH, Request|id, Options|dict, Topic|uri]
</artwork></figure>
<t>or
</t>

<figure align="left"><artwork align="left">
    [PUBLISH, Request|id, Options|dict, Topic|uri, Arguments|list]
</artwork></figure>
<t>or
</t>

<figure align="left"><artwork align="left">
    [PUBLISH, Request|id, Options|dict, Topic|uri, Arguments|list,
        ArgumentsKw|dict]
</artwork></figure>
<t>where
</t>
<t>
<list style="symbols">
<t><spanx style="verb">Request</spanx> is a random, ephemeral ID chosen by the Publisher and used to correlate the Broker's response with the request.</t>
<t><spanx style="verb">Options</spanx> is a dictionary that allows to provide additional publication request details in an extensible way. This is described further below.</t>
<t><spanx style="verb">Topic</spanx> is the topic published to.</t>
<t><spanx style="verb">Arguments</spanx> is a list of application-level event payload elements. The list may be of zero length.</t>
<t><spanx style="verb">ArgumentsKw</spanx> is an optional dictionary containing application-level event payload, provided as keyword arguments. The dictionary may be empty.</t>
</list>
</t>
<t>If the Broker is able to fulfill and allowing the publication, the Broker will send the event to all current Subscribers of the topic of the published event.
</t>
<t>By default, publications are unacknowledged, and the Broker will not respond, whether the publication was successful indeed or not. This behavior can be changed with the option <spanx style="verb">PUBLISH.Options.acknowledge|bool</spanx> (see below).
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [16, 239714735, {}, "com.myapp.mytopic1"]
</artwork></figure>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [16, 239714735, {}, "com.myapp.mytopic1", ["Hello, world!"]]
</artwork></figure>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [16, 239714735, {}, "com.myapp.mytopic1", [], {"color": "orange",
        "sizes": [23, 42, 7]}]
</artwork></figure>
</section>

<section anchor="published-1" title="PUBLISHED">
<t>If the Broker is able to fulfill and allowing the publication, and <spanx style="verb">PUBLISH.Options.acknowledge == true</spanx>, the Broker replies by sending a <spanx style="verb">PUBLISHED</spanx> message to the Publisher:
</t>

<figure align="left"><artwork align="left">
    [PUBLISHED, PUBLISH.Request|id, Publication|id]
</artwork></figure>
<t>where
</t>
<t>
<list style="symbols">
<t><spanx style="verb">PUBLISH.Request</spanx> is the ID from the original publication request.</t>
<t><spanx style="verb">Publication</spanx> is a ID chosen by the Broker for the publication.</t>
</list>
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [17, 239714735, 4429313566]
</artwork></figure>
</section>

<section anchor="publish-error" title="Publish ERROR">
<t>When the request for publication cannot be fulfilled by the Broker, and <spanx style="verb">PUBLISH.Options.acknowledge == true</spanx>, the Broker sends back an <spanx style="verb">ERROR</spanx> message to the Publisher
</t>

<figure align="left"><artwork align="left">
    [ERROR, PUBLISH, PUBLISH.Request|id, Details|dict, Error|uri]
</artwork></figure>
<t>where
</t>
<t>
<list style="symbols">
<t><spanx style="verb">PUBLISH.Request</spanx> is the ID from the original publication request.</t>
<t><spanx style="verb">Error</spanx> is an URI that gives the error of why the request could not be fulfilled.</t>
</list>
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [8, 16, 239714735, {}, "wamp.error.not_authorized"]
</artwork></figure>
</section>

<section anchor="event-1" title="EVENT">
<t>When a publication is successful and a Broker dispatches the event, it determines a list of receivers for the event based on Subscribers for the topic published to and, possibly, other information in the event.
</t>
<t>Note that the Publisher of an event will never receive the published event even if the Publisher is also a Subscriber of the topic published to.
</t>
<t><list style="empty">
<t>The Advanced Profile provides options for more detailed control over publication.
</t>
</list></t>
<t>When a Subscriber is deemed to be a receiver, the Broker sends the Subscriber an <spanx style="verb">EVENT</spanx> message:
</t>

<figure align="left"><artwork align="left">
    [EVENT, SUBSCRIBED.Subscription|id, PUBLISHED.Publication|id,
        Details|dict]
</artwork></figure>
<t>or
</t>

<figure align="left"><artwork align="left">
    [EVENT, SUBSCRIBED.Subscription|id, PUBLISHED.Publication|id,
        Details|dict, PUBLISH.Arguments|list]
</artwork></figure>
<t>or
</t>

<figure align="left"><artwork align="left">
    [EVENT, SUBSCRIBED.Subscription|id, PUBLISHED.Publication|id,
    Details|dict, PUBLISH.Arguments|list, PUBLISH.ArgumentKw|dict]
</artwork></figure>
<t>where
</t>
<t>
<list style="symbols">
<t><spanx style="verb">SUBSCRIBED.Subscription</spanx> is the ID for the subscription under which the Subscriber receives the event - the ID for the subscription originally handed out by the Broker to the Subscribe*.</t>
<t><spanx style="verb">PUBLISHED.Publication</spanx> is the ID of the publication of the published event.</t>
<t><spanx style="verb">Details</spanx> is a dictionary that allows the Broker to provide additional event details in a extensible way. This is described further below.</t>
<t><spanx style="verb">PUBLISH.Arguments</spanx> is the application-level event payload that was provided with the original publication request.</t>
<t><spanx style="verb">PUBLISH.ArgumentKw</spanx> is the application-level event payload that was provided with the original publication request.</t>
</list>
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [36, 5512315355, 4429313566, {}]
</artwork></figure>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [36, 5512315355, 4429313566, {}, ["Hello, world!"]]
</artwork></figure>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [36, 5512315355, 4429313566, {}, [], {"color": "orange",
        "sizes": [23, 42, 7]}]
</artwork></figure>
</section>
</section>
</section>

<section anchor="remote-procedure-calls" title="Remote Procedure Calls">
<t>All of the following features for Remote Procedure Calls are mandatory for WAMP Basic Profile implementations supporting the respective roles.
</t>

<section anchor="registering-and-unregistering" title="Registering and Unregistering">
<t>The message flow between Callees and a Dealer for registering and unregistering endpoints to be called over RPC involves the following messages:
</t>
<t>
<list style="numbers">
<t><spanx style="verb">REGISTER</spanx></t>
<t><spanx style="verb">REGISTERED</spanx></t>
<t><spanx style="verb">UNREGISTER</spanx></t>
<t><spanx style="verb">UNREGISTERED</spanx></t>
<t><spanx style="verb">ERROR</spanx></t>
</list>
</t>

<figure align="left"><artwork align="left">
    ,------.          ,------.               ,------.
    |Caller|          |Dealer|               |Callee|
    `--+---'          `--+---'               `--+---'
       |                 |                      |
       |                 |                      |
       |                 |       REGISTER       |
       |                 | &lt;---------------------
       |                 |                      |
       |                 |  REGISTERED or ERROR |
       |                 | ---------------------&gt;
       |                 |                      |
       |                 |                      |
       |                 |                      |
       |                 |                      |
       |                 |                      |
       |                 |      UNREGISTER      |
       |                 | &lt;---------------------
       |                 |                      |
       |                 | UNREGISTERED or ERROR|
       |                 | ---------------------&gt;
    ,--+---.          ,--+---.               ,--+---.
    |Caller|          |Dealer|               |Callee|
    `------'          `------'               `------'
</artwork></figure>

<section anchor="register-1" title="REGISTER">
<t>A Callee announces the availability of an endpoint implementing a procedure with a Dealer by sending a <spanx style="verb">REGISTER</spanx> message:
</t>

<figure align="left"><artwork align="left">
    [REGISTER, Request|id, Options|dict, Procedure|uri]
</artwork></figure>
<t>where
</t>
<t>
<list style="symbols">
<t><spanx style="verb">Request</spanx> is a random, ephemeral ID chosen by the Callee and used to correlate the Dealer's response with the request.</t>
<t><spanx style="verb">Options</spanx> is a dictionary that allows to provide additional registration request details in a extensible way. This is described further below.</t>
<t><spanx style="verb">Procedure</spanx>is the procedure the Callee wants to register</t>
</list>
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [64, 25349185, {}, "com.myapp.myprocedure1"]
</artwork></figure>
</section>

<section anchor="registered-1" title="REGISTERED">
<t>If the Dealer is able to fulfill and allowing the registration, it answers by sending a <spanx style="verb">REGISTERED</spanx> message to the <spanx style="verb">Callee</spanx>:
</t>

<figure align="left"><artwork align="left">
    [REGISTERED, REGISTER.Request|id, Registration|id]
</artwork></figure>
<t>where
</t>
<t>
<list style="symbols">
<t><spanx style="verb">REGISTER.Request</spanx> is the ID from the original request.</t>
<t><spanx style="verb">Registration</spanx> is an ID chosen by the Dealer for the registration.</t>
</list>
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [65, 25349185, 2103333224]
</artwork></figure>
</section>

<section anchor="register-error" title="Register ERROR">
<t>When the request for registration cannot be fulfilled by the Dealer, the Dealer sends back an <spanx style="verb">ERROR</spanx> message to the Callee:
</t>

<figure align="left"><artwork align="left">
    [ERROR, REGISTER, REGISTER.Request|id, Details|dict, Error|uri]
</artwork></figure>
<t>where
</t>
<t>
<list style="symbols">
<t><spanx style="verb">REGISTER.Request</spanx> is the ID from the original request.</t>
<t><spanx style="verb">Error</spanx> is an URI that gives the error of why the request could not be fulfilled.</t>
</list>
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [8, 64, 25349185, {}, "wamp.error.procedure_already_exists"]
</artwork></figure>
</section>

<section anchor="unregister-1" title="UNREGISTER">
<t>When a Callee is no longer willing to provide an implementation of the registered procedure, it sends an <spanx style="verb">UNREGISTER</spanx> message to the Dealer:
</t>

<figure align="left"><artwork align="left">
    [UNREGISTER, Request|id, REGISTERED.Registration|id]
</artwork></figure>
<t>where
</t>
<t>
<list style="symbols">
<t><spanx style="verb">Request</spanx> is a random, ephemeral ID chosen by the Callee and used to correlate the Dealer's response with the request.</t>
<t><spanx style="verb">REGISTERED.Registration</spanx> is the ID for the registration to revoke, originally handed out by the Dealer to the Callee.</t>
</list>
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [66, 788923562, 2103333224]
</artwork></figure>
</section>

<section anchor="unregistered-1" title="UNREGISTERED">
<t>Upon successful unregistration, the Dealer sends an <spanx style="verb">UNREGISTERED</spanx> message to the Callee:
</t>

<figure align="left"><artwork align="left">
    [UNREGISTERED, UNREGISTER.Request|id]
</artwork></figure>
<t>where
</t>
<t>
<list style="symbols">
<t><spanx style="verb">UNREGISTER.Request</spanx> is the ID from the original request.</t>
</list>
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [67, 788923562]
</artwork></figure>
</section>

<section anchor="unregister-error" title="Unregister ERROR">
<t>When the unregistration request fails, the Dealer sends an <spanx style="verb">ERROR</spanx> message:
</t>

<figure align="left"><artwork align="left">
    [ERROR, UNREGISTER, UNREGISTER.Request|id, Details|dict,
        Error|uri]
</artwork></figure>
<t>where
</t>
<t>
<list style="symbols">
<t><spanx style="verb">UNREGISTER.Request</spanx> is the ID from the original request.</t>
<t><spanx style="verb">Error</spanx> is an URI that gives the error of why the request could not be fulfilled.</t>
</list>
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [8, 66, 788923562, {}, "wamp.error.no_such_registration"]
</artwork></figure>
</section>
</section>

<section anchor="calling-and-invocations" title="Calling and Invocations">
<t>The message flow between Callers, a Dealer and Callees for calling procedures and invoking endpoints involves the following messages:
</t>
<t>
<list style="numbers">
<t><spanx style="verb">CALL</spanx></t>
<t><spanx style="verb">RESULT</spanx></t>
<t><spanx style="verb">INVOCATION</spanx></t>
<t><spanx style="verb">YIELD</spanx></t>
<t><spanx style="verb">ERROR</spanx></t>
</list>
</t>

<figure align="left"><artwork align="left">
    ,------.          ,------.          ,------.
    |Caller|          |Dealer|          |Callee|
    `--+---'          `--+---'          `--+---'
       |       CALL      |                 |
       | ----------------&gt;                 |
       |                 |                 |
       |                 |    INVOCATION   |
       |                 | ----------------&gt;
       |                 |                 |
       |                 |  YIELD or ERROR |
       |                 | &lt;----------------
       |                 |                 |
       | RESULT or ERROR |                 |
       | &lt;----------------                 |
    ,--+---.          ,--+---.          ,--+---.
    |Caller|          |Dealer|          |Callee|
    `------'          `------'          `------'
</artwork></figure>
<t>The execution of remote procedure calls is asynchronous, and there may be more than one call outstanding. A call is called outstanding (from the point of view of the Caller), when a (final) result or error has not yet been received by the Caller.
</t>

<section anchor="call-1" title="CALL">
<t>When a Caller wishes to call a remote procedure, it sends a <spanx style="verb">CALL</spanx> message to a Dealer:
</t>

<figure align="left"><artwork align="left">
    [CALL, Request|id, Options|dict, Procedure|uri]
</artwork></figure>
<t>or
</t>

<figure align="left"><artwork align="left">
    [CALL, Request|id, Options|dict, Procedure|uri, Arguments|list]
</artwork></figure>
<t>or
</t>

<figure align="left"><artwork align="left">
    [CALL, Request|id, Options|dict, Procedure|uri, Arguments|list,
        ArgumentsKw|dict]
</artwork></figure>
<t>where
</t>
<t>
<list style="symbols">
<t><spanx style="verb">Request</spanx> is a random, ephemeral ID chosen by the Caller and used to correlate the Dealer's response with the request.</t>
<t><spanx style="verb">Options</spanx> is a dictionary that allows to provide additional call request details in an extensible way. This is described further below.</t>
<t><spanx style="verb">Procedure</spanx> is the URI of the procedure to be called.</t>
<t><spanx style="verb">Arguments</spanx> is a list of positional call arguments (each of arbitrary type). The list may be of zero length.</t>
<t><spanx style="verb">ArgumentsKw</spanx> is a dictionary of keyword call arguments (each of arbitrary type). The dictionary may be empty.</t>
</list>
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [48, 7814135, {}, "com.myapp.ping"]
</artwork></figure>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [48, 7814135, {}, "com.myapp.echo", ["Hello, world!"]]
</artwork></figure>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [48, 7814135, {}, "com.myapp.add2", [23, 7]]
</artwork></figure>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [48, 7814135, {}, "com.myapp.user.new", ["johnny"],
        {"firstname": "John", "surname": "Doe"}]
</artwork></figure>
</section>

<section anchor="invocation-1" title="INVOCATION">
<t>If the Dealer is able to fulfill (mediate) the call and it allows the call, it sends a <spanx style="verb">INVOCATION</spanx> message to the respective Callee implementing the procedure:
</t>

<figure align="left"><artwork align="left">
    [INVOCATION, Request|id, REGISTERED.Registration|id,
        Details|dict]
</artwork></figure>
<t>or
</t>

<figure align="left"><artwork align="left">
    [INVOCATION, Request|id, REGISTERED.Registration|id,
        Details|dict, CALL.Arguments|list]
</artwork></figure>
<t>or
</t>

<figure align="left"><artwork align="left">
    [INVOCATION, Request|id, REGISTERED.Registration|id,
        Details|dict, CALL.Arguments|list, CALL.ArgumentsKw|dict]
</artwork></figure>
<t>where
</t>
<t>
<list style="symbols">
<t><spanx style="verb">Request</spanx> is a random, ephemeral ID chosen by the Dealer and used to correlate the <spanx style="emph">Callee's</spanx> response with the request.</t>
<t><spanx style="verb">REGISTERED.Registration</spanx> is the registration ID under which the procedure was registered at the Dealer.</t>
<t><spanx style="verb">Details</spanx> is a dictionary that allows to provide additional invocation request details in an extensible way. This is described further below.</t>
<t><spanx style="verb">CALL.Arguments</spanx> is the original list of positional call arguments as provided by the Caller.</t>
<t><spanx style="verb">CALL.ArgumentsKw</spanx> is the original dictionary of keyword call arguments as provided by the Caller.</t>
</list>
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [68, 6131533, 9823526, {}]
</artwork></figure>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [68, 6131533, 9823527, {}, ["Hello, world!"]]
</artwork></figure>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [68, 6131533, 9823528, {}, [23, 7]]
</artwork></figure>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [68, 6131533, 9823529, {}, ["johnny"], {"firstname": "John",
        "surname": "Doe"}]
</artwork></figure>
</section>

<section anchor="yield-1" title="YIELD">
<t>If the Callee is able to successfully process and finish the execution of the call, it answers by sending a <spanx style="verb">YIELD</spanx> message to the Dealer:
</t>

<figure align="left"><artwork align="left">
    [YIELD, INVOCATION.Request|id, Options|dict]
</artwork></figure>
<t>or
</t>

<figure align="left"><artwork align="left">
    [YIELD, INVOCATION.Request|id, Options|dict, Arguments|list]
</artwork></figure>
<t>or
</t>

<figure align="left"><artwork align="left">
    [YIELD, INVOCATION.Request|id, Options|dict, Arguments|list,
        ArgumentsKw|dict]
</artwork></figure>
<t>where
</t>
<t>
<list style="symbols">
<t><spanx style="verb">INVOCATION.Request</spanx> is the ID from the original invocation request.</t>
<t><spanx style="verb">Options</spanx>is a dictionary that allows to provide additional options.</t>
<t><spanx style="verb">Arguments</spanx> is a list of positional result elements (each of arbitrary type). The list may be of zero length.</t>
<t><spanx style="verb">ArgumentsKw</spanx> is a dictionary of keyword result elements (each of arbitrary type). The dictionary may be empty.</t>
</list>
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [70, 6131533, {}]
</artwork></figure>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [70, 6131533, {}, ["Hello, world!"]]
</artwork></figure>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [70, 6131533, {}, [30]]
</artwork></figure>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [70, 6131533, {}, [], {"userid": 123, "karma": 10}]
</artwork></figure>
</section>

<section anchor="result-1" title="RESULT">
<t>The Dealer will then send a <spanx style="verb">RESULT</spanx> message to the original Caller:
</t>

<figure align="left"><artwork align="left">
    [RESULT, CALL.Request|id, Details|dict]
</artwork></figure>
<t>or
</t>

<figure align="left"><artwork align="left">
    [RESULT, CALL.Request|id, Details|dict, YIELD.Arguments|list]
</artwork></figure>
<t>or
</t>

<figure align="left"><artwork align="left">
    [RESULT, CALL.Request|id, Details|dict, YIELD.Arguments|list,
        YIELD.ArgumentsKw|dict]
</artwork></figure>
<t>where
</t>
<t>
<list style="symbols">
<t><spanx style="verb">CALL.Request</spanx> is the ID from the original call request.</t>
<t><spanx style="verb">Details</spanx> is a dictionary of additional details.</t>
<t><spanx style="verb">YIELD.Arguments</spanx> is the original list of positional result elements as returned by the Callee.</t>
<t><spanx style="verb">YIELD.ArgumentsKw</spanx> is the original dictionary of keyword result elements as returned by the Callee.</t>
</list>
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [50, 7814135, {}]
</artwork></figure>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [50, 7814135, {}, ["Hello, world!"]]
</artwork></figure>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [50, 7814135, {}, [30]]
</artwork></figure>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [50, 7814135, {}, [], {"userid": 123, "karma": 10}]
</artwork></figure>
</section>

<section anchor="invocation-error" title="Invocation ERROR">
<t>If the Callee is unable to process or finish the execution of the call, or the application code implementing the procedure raises an exception or otherwise runs into an error, the Callee sends an <spanx style="verb">ERROR</spanx> message to the Dealer:
</t>

<figure align="left"><artwork align="left">
    [ERROR, INVOCATION, INVOCATION.Request|id, Details|dict,
        Error|uri]
</artwork></figure>
<t>or
</t>

<figure align="left"><artwork align="left">
    [ERROR, INVOCATION, INVOCATION.Request|id, Details|dict,
    Error|uri, Arguments|list]
</artwork></figure>
<t>or
</t>

<figure align="left"><artwork align="left">
    [ERROR, INVOCATION, INVOCATION.Request|id, Details|dict,
        Error|uri, Arguments|list, ArgumentsKw|dict]
</artwork></figure>
<t>where
</t>
<t>
<list style="symbols">
<t><spanx style="verb">INVOCATION.Request</spanx> is the ID from the original <spanx style="verb">INVOCATION</spanx> request previously sent by the Dealer to the Callee.</t>
<t><spanx style="verb">Details</spanx> is a dictionary with additional error details.</t>
<t><spanx style="verb">Error</spanx> is an URI that identifies the error of why the request could not be fulfilled.</t>
<t><spanx style="verb">Arguments</spanx> is a list containing arbitrary, application defined, positional error information. This will be forwarded by the Dealer to the Caller that initiated the call.</t>
<t><spanx style="verb">ArgumentsKw</spanx> is a dictionary containing arbitrary, application defined, keyword-based error information. This will be forwarded by the Dealer to the Caller that initiated the call.</t>
</list>
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [8, 68, 6131533, {}, "com.myapp.error.object_write_protected",
        ["Object is write protected."], {"severity": 3}]
</artwork></figure>
</section>

<section anchor="call-error" title="Call ERROR">
<t>The Dealer will then send a <spanx style="verb">ERROR</spanx> message to the original Caller:
</t>

<figure align="left"><artwork align="left">
    [ERROR, CALL, CALL.Request|id, Details|dict, Error|uri]
</artwork></figure>
<t>or
</t>

<figure align="left"><artwork align="left">
    [ERROR, CALL, CALL.Request|id, Details|dict, Error|uri,
        Arguments|list]
</artwork></figure>
<t>or
</t>

<figure align="left"><artwork align="left">
    [ERROR, CALL, CALL.Request|id, Details|dict, Error|uri,
        Arguments|list, ArgumentsKw|dict]
</artwork></figure>
<t>where
</t>
<t>
<list style="symbols">
<t><spanx style="verb">CALL.Request</spanx> is the ID from the original <spanx style="verb">CALL</spanx> request sent by the Caller to the Dealer.</t>
<t><spanx style="verb">Details</spanx> is a dictionary with additional error details.</t>
<t><spanx style="verb">Error</spanx> is an URI identifying the type of error as returned by the Callee to the Dealer.</t>
<t><spanx style="verb">Arguments</spanx> is a list containing the original error payload list as returned by the Callee to the Dealer.</t>
<t><spanx style="verb">ArgumentsKw</spanx> is a dictionary containing the original error payload dictionary as returned by the Callee to the Dealer</t>
</list>
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [8, 48, 7814135, {}, "com.myapp.error.object_write_protected",
        ["Object is write protected."], {"severity": 3}]
</artwork></figure>
<t>If the original call already failed at the Dealer <spanx style="strong">before</spanx> the call would have been forwarded to any Callee, the Dealer will send an <spanx style="verb">ERROR</spanx> message to the Caller:
</t>

<figure align="left"><artwork align="left">
    [ERROR, CALL, CALL.Request|id, Details|dict, Error|uri]
</artwork></figure>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [8, 48, 7814135, {}, "wamp.error.no_such_procedure"]
</artwork></figure>
</section>
</section>
</section>

<section anchor="predefined-uris" title="Predefined URIs">
<t>WAMP pre-defines the following error URIs for the basic and for the advanced profile. WAMP peers MUST use only the defined error messages.
</t>

<section anchor="basic-profile" title="Basic Profile">

<section anchor="incorrect-uris" title="Incorrect URIs">
<t>When a Peer provides an incorrect URI for any URI-based attribute of a WAMP message (e.g. realm, topic), then the other Peer MUST respond with an <spanx style="verb">ERROR</spanx> message and give the following <spanx style="emph">Error URI</spanx>:
</t>

<figure align="left"><artwork align="left">
    wamp.error.invalid_uri
</artwork></figure>
</section>

<section anchor="interaction" title="Interaction">
<t>Peer provided an incorrect URI for any URI-based attribute of WAMP message, such as realm, topic or procedure
</t>

<figure align="left"><artwork align="left">
    wamp.error.invalid_uri
</artwork></figure>
<t>A Dealer could not perform a call, since no procedure is currently registered under the given URI.
</t>

<figure align="left"><artwork align="left">
    wamp.error.no_such_procedure
</artwork></figure>
<t>A procedure could not be registered, since a procedure with the given URI is already registered.
</t>

<figure align="left"><artwork align="left">
    wamp.error.procedure_already_exists
</artwork></figure>
<t>A Dealer could not perform an unregister, since the given registration is not active.
</t>

<figure align="left"><artwork align="left">
    wamp.error.no_such_registration
</artwork></figure>
<t>A Broker could not perform an unsubscribe, since the given subscription is not active.
</t>

<figure align="left"><artwork align="left">
    wamp.error.no_such_subscription
</artwork></figure>
<t>A call failed since the given argument types or values are not acceptable to the called procedure. In this case the Callee may throw this error. Alternatively a Router may throw this error if it performed <spanx style="emph">payload validation</spanx> of a call, call result, call error or publish, and the payload did not conform to the requirements.
</t>

<figure align="left"><artwork align="left">
    wamp.error.invalid_argument
</artwork></figure>
</section>

<section anchor="session-close" title="Session Close">
<t>The Peer is shutting down completely - used as a <spanx style="verb">GOODBYE</spanx> (or <spanx style="verb">ABORT</spanx>) reason.
</t>

<figure align="left"><artwork align="left">
    wamp.close.system_shutdown
</artwork></figure>
<t>The Peer want to leave the realm - used as a <spanx style="verb">GOODBYE</spanx> reason.
</t>

<figure align="left"><artwork align="left">
    wamp.close.close_realm
</artwork></figure>
<t>A Peer acknowledges ending of a session - used as a <spanx style="verb">GOODBYE</spanx> reply reason.
</t>

<figure align="left"><artwork align="left">
    wamp.close.goodbye_and_out
</artwork></figure>
<t>A Peer received invalid WAMP protocol message (e.g. <spanx style="verb">HELLO</spanx> message after session was already established) - used as a <spanx style="verb">ABORT</spanx> reply reason.
</t>

<figure align="left"><artwork align="left">
    wamp.error.protocol_violation
</artwork></figure>
</section>

<section anchor="authorization" title="Authorization">
<t>A join, call, register, publish or subscribe failed, since the Peer is not authorized to perform the operation.
</t>

<figure align="left"><artwork align="left">
    wamp.error.not_authorized
</artwork></figure>
<t>A Dealer or Broker could not determine if the Peer is authorized to perform a join, call, register, publish or subscribe, since the authorization operation <spanx style="emph">itself</spanx> failed. E.g. a custom authorizer did run into an error.
</t>

<figure align="left"><artwork align="left">
    wamp.error.authorization_failed
</artwork></figure>
<t>Peer wanted to join a non-existing realm (and the Router did not allow to auto-create the realm).
</t>

<figure align="left"><artwork align="left">
    wamp.error.no_such_realm
</artwork></figure>
<t>A Peer was to be authenticated under a Role that does not (or no longer) exists on the Router. For example, the Peer was successfully authenticated, but the Role configured does not exists - hence there is some misconfiguration in the Router.
</t>

<figure align="left"><artwork align="left">
    wamp.error.no_such_role
</artwork></figure>
</section>
</section>

<section anchor="advanced-profile" title="Advanced Profile">
<t>A <spanx style="emph">Dealer</spanx> or<spanx style="emph">Callee</spanx> canceled a call previously issued
</t>

<figure align="left"><artwork align="left">
    wamp.error.canceled
</artwork></figure>
<t>A <spanx style="emph">Peer</spanx> requested an interaction with an option that was disallowed by the <spanx style="emph">Router</spanx>
</t>

<figure align="left"><artwork align="left">
    wamp.error.option_not_allowed
</artwork></figure>
<t>A <spanx style="emph">Dealer</spanx> could not perform a call, since a procedure with the given URI is registered, but <spanx style="emph">Callee Black- and Whitelisting</spanx> and/or <spanx style="emph">Caller Exclusion</spanx> lead to the exclusion of (any) <spanx style="emph">Callee</spanx> providing the procedure.
</t>

<figure align="left"><artwork align="left">
    wamp.error.no_eligible_callee
</artwork></figure>
<t>A <spanx style="emph">Router</spanx> rejected client request to disclose its identity
</t>

<figure align="left"><artwork align="left">
    wamp.error.option_disallowed.disclose_me
</artwork></figure>
<t>A <spanx style="emph">Router</spanx> encountered a network failure
</t>

<figure align="left"><artwork align="left">
    wamp.error.network_failure
</artwork></figure>
</section>
</section>

<section anchor="ordering-guarantees" title="Ordering Guarantees">
<t>All WAMP implementations, in particular Routers MUST support the following ordering guarantees.
</t>
<t><list style="empty">
<t>A WAMP Advanced Profile may provide applications options to relax ordering guarantees, in particular with distributed calls.
</t>
</list></t>

<section anchor="publish--subscribe-ordering" title="Publish &amp; Subscribe Ordering">
<t>Regarding <spanx style="strong">Publish &amp; Subscribe</spanx>, the ordering guarantees are as follows:
</t>
<t>If <spanx style="emph">Subscriber A</spanx> is subscribed to both <spanx style="strong">Topic 1</spanx> and <spanx style="strong">Topic 2</spanx>, and <spanx style="emph">Publisher B</spanx> first publishes an <spanx style="strong">Event 1</spanx> to <spanx style="strong">Topic 1</spanx> and then an <spanx style="strong">Event 2</spanx> to <spanx style="strong">Topic 2</spanx>, then <spanx style="emph">Subscriber A</spanx> will first receive <spanx style="strong">Event 1</spanx> and then <spanx style="strong">Event 2</spanx>. This also holds if <spanx style="strong">Topic 1</spanx> and <spanx style="strong">Topic 2</spanx> are identical.
</t>
<t>In other words, WAMP guarantees ordering of events between any given <spanx style="emph">pair</spanx> of Publisher and Subscriber.
</t>
<t>Further, if <spanx style="emph">Subscriber A</spanx> subscribes to <spanx style="strong">Topic 1</spanx>, the <spanx style="verb">SUBSCRIBED</spanx> message will be sent by the <spanx style="emph">Broker</spanx> to <spanx style="emph">Subscriber A</spanx> before any <spanx style="verb">EVENT</spanx> message for <spanx style="strong">Topic 1</spanx>.
</t>
<t>There is no guarantee regarding the order of return for multiple subsequent subscribe requests. A subscribe request might require the <spanx style="emph">Broker</spanx> to do a time-consuming lookup in some database, whereas another subscribe request second might be permissible immediately.
</t>
</section>

<section anchor="remote-procedure-call-ordering" title="Remote Procedure Call Ordering">
<t>Regarding <spanx style="strong">Remote Procedure Calls</spanx>, the ordering guarantees are as follows:
</t>
<t>If <spanx style="emph">Callee A</spanx> has registered endpoints for both <spanx style="strong">Procedure 1</spanx> and <spanx style="strong">Procedure 2</spanx>, and <spanx style="emph">Caller B</spanx> first issues a <spanx style="strong">Call 1</spanx> to <spanx style="strong">Procedure 1</spanx> and then a <spanx style="strong">Call 2</spanx> to <spanx style="strong">Procedure 2</spanx>, and both calls are routed to <spanx style="emph">Callee A</spanx>, then <spanx style="emph">Callee A</spanx> will first receive an invocation corresponding to <spanx style="strong">Call 1</spanx> and then <spanx style="strong">Call 2</spanx>. This also holds if <spanx style="strong">Procedure 1</spanx> and <spanx style="strong">Procedure 2</spanx> are identical.
</t>
<t>In other words, WAMP guarantees ordering of invocations between any given <spanx style="emph">pair</spanx> of Caller and Callee.
</t>
<t>There are no guarantees on the order of call results and errors in relation to <spanx style="emph">different</spanx> calls, since the execution of calls upon different invocations of endpoints in Callees are running independently. A first call might require an expensive, long-running computation, whereas a second, subsequent call might finish immediately.
</t>
<t>Further, if <spanx style="emph">Callee A</spanx> registers for <spanx style="strong">Procedure 1</spanx>, the <spanx style="verb">REGISTERED</spanx> message will be sent by <spanx style="emph">Dealer</spanx> to <spanx style="emph">Callee A</spanx> before any <spanx style="verb">INVOCATION</spanx> message for <spanx style="strong">Procedure 1</spanx>.
</t>
<t>There is no guarantee regarding the order of return for multiple subsequent register requests. A register request might require the <spanx style="emph">Broker</spanx> to do a time-consuming lookup in some database, whereas another register request second might be permissible immediately.
</t>
</section>
</section>

<section anchor="security-model" title="Security Model">
<t>The following discusses the security model for the Basic Profile. Any changes or extensions to this for the Advanced Profile are discussed further on as part of the Advanced Profile definition.
</t>

<section anchor="transport-encryption-and-integrity" title="Transport Encryption and Integrity">
<t>WAMP transports may provide (optional) transport-level encryption and integrity verification. If so, encryption and integrity is point-to-point: between a Client and the Router it is connected to.
</t>
<t>Transport-level encryption and integrity is solely at the transport-level and transparent to WAMP. WAMP itself deliberately does not specify any kind of transport-level encryption.
</t>
<t>Implementations that offer TCP based transport such as WAMP-over-WebSocket or WAMP-over-RawSocket SHOULD implement Transport Layer Security (TLS).
</t>
<t>WAMP deployments are encouraged to stick to a TLS-only policy with the TLS code and setup being hardened.
</t>
<t>Further, when a Client connects to a Router over a local-only transport such as Unix domain sockets, the integrity of the data transmitted is implicit (the OS kernel is trusted), and the privacy of the data transmitted can be assured using file system permissions (no one can tap a Unix domain socket without appropriate permissions or being root).
</t>
</section>

<section anchor="router-authentication" title="Router Authentication">
<t>To authenticate Routers to Clients, deployments MUST run TLS and Clients MUST verify the Router server certificate presented. WAMP itself does not provide mechanisms to authenticate a Router (only a Client).
</t>
<t>The verification of the Router server certificate can happen
</t>
<t>
<list style="numbers">
<t>against a certificate trust database that comes with the Clients operating system</t>
<t>against an issuing certificate/key hard-wired into the Client</t>
<t>by using new mechanisms like DNS-based Authentication of Named Enitities (DNSSEC)/TLSA</t>
</list>
</t>
<t>Further, when a Client connects to a Router over a local-only transport such as Unix domain sockets, the file system permissions can be used to create implicit trust. E.g. if only the OS user under which the Router runs has the permission to create a Unix domain socket under a specific path, Clients connecting to that path can trust in the router authenticity.
</t>
</section>

<section anchor="client-authentication" title="Client Authentication">
<t>Authentication of a Client to a Router at the WAMP level is not part of the basic profile.
</t>
<t>When running over TLS, a Router MAY authenticate a Client at the transport level by doing a <spanx style="emph">client certificate based authentication</spanx>.
</t>

<section anchor="routers-are-trusted" title="Routers are trusted">
<t>Routers are <spanx style="emph">trusted</spanx> by Clients.
</t>
<t>In particular, Routers can read (and modify) any application payload transmitted in events, calls, call results and call errors (the <spanx style="verb">Arguments</spanx> or <spanx style="verb">ArgumentsKw</spanx> message fields).
</t>
<t>Hence, Routers do not provide confidentiality with respect to application payload, and also do not provide authenticity or integrity of application payloads that could be verified by a receiving Client.
</t>
<t>Routers need to read the application payloads in cases of automatic conversion between different serialization formats.
</t>
<t>Further, Routers are trusted to <spanx style="strong">actually perform</spanx> routing as specified. E.g. a Client that publishes an event has to trust a Router that the event is actually dispatched to all (eligible) Subscribers by the Router.
</t>
<t>A rogue Router might deny normal routing operation without a Client taking notice.
</t>
</section>
</section>
</section>

<section anchor="advanced-profile-1" title="Advanced Profile">
<t>While implementations MUST implement the subset of the Basic Profile necessary for the particular set of WAMP roles they provide, they MAY implement any subset of features from the Advanced Profile. Implementers SHOULD implement the maximum of features possible considering the aims of an implementation.
</t>
<t><list style="empty">
<t>Note: Features listed here may be experimental or underspecced and yet unimplemented in any implementation. This part of the specification is very much a work in progress. An approximate status of each feature is given at the beginning of the feature section.
</t>
</list></t>

<section anchor="messages-1" title="Messages">
<t>The Advanced Profile defines the following additional messages which are explained in detail in separate sections.
</t>

<section anchor="message-definitions-1" title="Message Definitions">
<t>The following 4 additional message types MAY be used in the Advanced Profile.
</t>

<section anchor="challenge" title="CHALLENGE">
<t>The <spanx style="verb">CHALLENGE</spanx> message is used with certain Authentication Methods. During authenticated session establishment, a <spanx style="strong">Router</spanx> sends a challenge message.
</t>

<figure align="left"><artwork align="left">
    [CHALLENGE, AuthMethod|string, Extra|dict]
</artwork></figure>
</section>

<section anchor="authenticate" title="AUTHENTICATE">
<t>The <spanx style="verb">AUTHENTICATE</spanx> message is used with certain Authentication Methods. A <spanx style="strong">Client</spanx> having received a challenge is expected to respond by sending a signature or token.
</t>

<figure align="left"><artwork align="left">
    [AUTHENTICATE, Signature|string, Extra|dict]
</artwork></figure>
</section>

<section anchor="cancel" title="CANCEL">
<t>The <spanx style="verb">CANCEL</spanx> message is used with the Call Canceling advanced feature. A <spanx style="emph">Caller</spanx> can cancel and issued call actively by sending a cancel message to the <spanx style="emph">Dealer</spanx>.
</t>

<figure align="left"><artwork align="left">
    [CANCEL, CALL.Request|id, Options|dict]
</artwork></figure>
</section>

<section anchor="interrupt" title="INTERRUPT">
<t>The <spanx style="verb">INTERRUPT</spanx> message is used with the Call Canceling advanced feature. Upon receiving a cancel for a pending call, a <spanx style="emph">Dealer</spanx> will issue an interrupt to the <spanx style="emph">Callee</spanx>.
</t>

<figure align="left"><artwork align="left">
    [INTERRUPT, INVOCATION.Request|id, Options|dict]
</artwork></figure>
</section>
</section>

<section anchor="message-codes-and-direction-1" title="Message Codes and Direction">
<t>The following table list the message type code for <spanx style="strong">the OPTIONAL messages</spanx> defined in this part of the document and their direction between peer roles.
</t>
<texttable>
<ttcol align="center">Cod</ttcol>
<ttcol align="center">Message</ttcol>
<ttcol align="center">Pub</ttcol>
<ttcol align="center">Brk</ttcol>
<ttcol align="center">Subs</ttcol>
<ttcol align="center">Calr</ttcol>
<ttcol align="center">Dealr</ttcol>
<ttcol align="center">Callee</ttcol>

<c>4</c><c><spanx style="verb">CHALLENGE</spanx></c><c>Rx</c><c>Tx</c><c>Rx</c><c>Rx</c><c>Tx</c><c>Rx</c>
<c>5</c><c><spanx style="verb">AUTHENTICATE</spanx></c><c>Tx</c><c>Rx</c><c>Tx</c><c>Tx</c><c>Rx</c><c>Tx</c>
<c>49</c><c><spanx style="verb">CANCEL</spanx></c><c></c><c></c><c></c><c>Tx</c><c>Rx</c><c></c>
<c>69</c><c><spanx style="verb">INTERRUPT</spanx></c><c></c><c></c><c></c><c></c><c>Tx</c><c>Rx</c>
</texttable>
<t><list style="empty">
<t>&quot;Tx&quot; (&quot;Rx&quot;) means the message is sent (received) by a peer of the respective role.
</t>
</list></t>
</section>
</section>

<section anchor="features" title="Features">
<t>Support for advanced features must be announced by the peers which implement them. The following is a complete list of advanced features currently defined or proposed.
</t>
<texttable>
<ttcol align="center">Status</ttcol>
<ttcol align="center">Description</ttcol>

<c>sketch</c><c>There is a rough description of an itch to scratch, but the feature use case isn't clear, and there is no protocol proposal at all.</c>
<c>alpha</c><c>The feature use case is still fuzzy and/or the feature definition is unclear, but there is at least a protocol level proposal.</c>
<c>beta</c><c>The feature use case is clearly defined and the feature definition in the spec is sufficient to write a prototype implementation. The feature definition and details may still be incomplete and change.</c>
<c>stable</c><c>The feature definition in the spec is complete and stable and the feature use case is field proven in real applications. There are multiple, interoperatble implementations.</c>
</texttable>

<section anchor="rpc-features" title="RPC Features">
<texttable align="left">
<ttcol align="center">Feature</ttcol>
<ttcol align="center">Status</ttcol>
<ttcol align="center">P</ttcol>
<ttcol align="center">B</ttcol>
<ttcol align="center">S</ttcol>
<ttcol align="center">Cr</ttcol>
<ttcol align="center">D</ttcol>
<ttcol align="center">Ce</ttcol>

<c>progressive_call_results</c><c>beta</c><c></c><c></c><c></c><c>X</c><c>X</c><c>X</c>
<c>progressive_calls</c><c>sketch</c><c></c><c></c><c></c><c>X</c><c>X</c><c>X</c>
<c>call_timeout</c><c>alpha</c><c></c><c></c><c></c><c>X</c><c>X</c><c>X</c>
<c>call_canceling</c><c>alpha</c><c></c><c></c><c></c><c>X</c><c>X</c><c>X</c>
<c>caller_identification</c><c>alpha</c><c></c><c></c><c></c><c>X</c><c>X</c><c>X</c>
<c>call_trustlevels</c><c>alpha</c><c></c><c></c><c></c><c></c><c>X</c><c>X</c>
<c>registration_meta_api</c><c>beta</c><c></c><c></c><c></c><c></c><c>X</c><c></c>
<c>pattern_based_registration</c><c>beta</c><c></c><c></c><c></c><c></c><c>X</c><c>X</c>
<c>shared_registration</c><c>beta</c><c></c><c></c><c></c><c></c><c>X</c><c>X</c>
<c>sharded_registration</c><c>alpha</c><c></c><c></c><c></c><c></c><c>X</c><c>X</c>
<c>registration_revocation</c><c>alpha</c><c></c><c></c><c></c><c></c><c>X</c><c>X</c>
<c>procedure_reflection</c><c>sketch</c><c></c><c></c><c></c><c></c><c>X</c><c></c>
</texttable>
</section>

<section anchor="pubsub-features" title="PubSub Features">
<texttable align="left">
<ttcol align="center">Feature</ttcol>
<ttcol align="center">Status</ttcol>
<ttcol align="center">P</ttcol>
<ttcol align="center">B</ttcol>
<ttcol align="center">S</ttcol>
<ttcol align="center">Cr</ttcol>
<ttcol align="center">D</ttcol>
<ttcol align="center">Ce</ttcol>

<c>subscriber_blackwhite_listing</c><c>stable</c><c>X</c><c>X</c><c></c><c></c><c></c><c></c>
<c>publisher_exclusion</c><c>stable</c><c>X</c><c>X</c><c></c><c></c><c></c><c></c>
<c>publisher_identification</c><c>alpha</c><c>X</c><c>X</c><c>X</c><c></c><c></c><c></c>
<c>publication_trustlevels</c><c>alpha</c><c></c><c>X</c><c>X</c><c></c><c></c><c></c>
<c>subscription_meta_api</c><c>beta</c><c></c><c>X</c><c></c><c></c><c></c><c></c>
<c>pattern_based_subscription</c><c>beta</c><c></c><c>X</c><c>X</c><c></c><c></c><c></c>
<c>sharded_subscription</c><c>alpha</c><c></c><c>X</c><c>X</c><c></c><c></c><c></c>
<c>event_history</c><c>alpha</c><c></c><c>X</c><c>X</c><c></c><c></c><c></c>
<c>topic_reflection</c><c>sketch</c><c></c><c>X</c><c></c><c></c><c></c><c></c>
</texttable>
</section>

<section anchor="other-advanced-features" title="Other Advanced Features">
<texttable align="left">
<ttcol align="center">Feature</ttcol>
<ttcol align="center">Status</ttcol>

<c>challenge-response authentication</c><c>beta</c>
<c>cookie authentication</c><c>beta</c>
<c>ticket authentication</c><c>beta</c>
<c>rawsocket transport</c><c>stable</c>
<c>batched WS transport</c><c>sketch</c>
<c>longpoll transport</c><c>beta</c>
<c>session meta api</c><c>beta</c>
</texttable>
</section>
</section>

<section anchor="advanced-rpc-features" title="Advanced RPC Features">

<section anchor="progressive-call-results" title="Progressive Call Results">

<section anchor="feature-definition" title="Feature Definition">
<t>A procedure implemented by a <spanx style="emph">Callee</spanx> and registered at a <spanx style="emph">Dealer</spanx> may produce progressive results. Progressive results can e.g. be used to return partial results for long-running operations, or to chunk the transmission of larger results sets.
</t>
<t>The message flow for progressive results involves:
</t>

<figure align="center"><artwork align="center">
 ,------.           ,------.          ,------.
 |Caller|           |Dealer|          |Callee|
 `--+---'           `--+---'          `--+---'
    |       CALL       |                 |
    | -----------------&gt;                 |
    |                  |                 |
    |                  |    INVOCATION   |
    |                  | ----------------&gt;
    |                  |                 |
    |                  | YIELD (progress)|
    |                  | &lt;----------------
    |                  |                 |
    | RESULT (progress)|                 |
    | &lt;-----------------                 |
    |                  |                 |
    |                  | YIELD (progress)|
    |                  | &lt;----------------
    |                  |                 |
    | RESULT (progress)|                 |
    | &lt;-----------------                 |
    |                  |                 |
    |                  |                 |
    |       ...        |       ...       |
    |                  |                 |
    |                  |  YIELD or ERROR |
    |                  | &lt;----------------
    |                  |                 |
    |  RESULT or ERROR |                 |
    | &lt;-----------------                 |
 ,--+---.           ,--+---.          ,--+---.
 |Caller|           |Dealer|          |Callee|
 `------'           `------'          `------'
</artwork></figure>
<t>A <spanx style="emph">Caller</spanx> indicates its willingness to receive progressive results by setting
</t>

<figure align="left"><artwork align="left">
    CALL.Options.receive_progress|bool := true
</artwork></figure>
<t><spanx style="emph">Example.</spanx> Caller-to-Dealer <spanx style="verb">CALL</spanx>
</t>

<figure align="left"><artwork align="left">
    [
        48,
        77133,
        {
            "receive_progress": true
        },
        "com.myapp.compute_revenue",
        [2010, 2011, 2012]
    ]
</artwork></figure>
<t>If the <spanx style="emph">Callee</spanx> supports progressive calls, the <spanx style="emph">Dealer</spanx> will forward the <spanx style="emph">Caller's</spanx> willingness to receive progressive results by setting
</t>

<figure align="left"><artwork align="left">
    INVOCATION.Details.receive_progress|bool := true
</artwork></figure>
<t><spanx style="emph">Example.</spanx> Dealer-to-Callee <spanx style="verb">INVOCATION</spanx>
</t>

<figure align="left"><artwork align="left">
    [
        68,
        87683,
        324,
        {
            "receive_progress": true
        },
        [2010, 2011, 2012]
    ]
</artwork></figure>
<t>An endpoint implementing the procedure produces progressive results by sending <spanx style="verb">YIELD</spanx> messages to the <spanx style="emph">Dealer</spanx> with
</t>

<figure align="left"><artwork align="left">
    YIELD.Options.progress|bool := true
</artwork></figure>
<t><spanx style="emph">Example.</spanx> Callee-to-Dealer progressive <spanx style="verb">YIELDs</spanx>
</t>

<figure align="left"><artwork align="left">
    [
        70,
        87683,
        {
            "progress": true
        },
        ["Y2010", 120]
    ]
</artwork></figure>

<figure align="left"><artwork align="left">
    [
        70,
        87683,
        {
            "progress": true
        },
        ["Y2011", 205]
    ]
</artwork></figure>
<t>Upon receiving an <spanx style="verb">YIELD</spanx> message from a <spanx style="emph">Callee</spanx> with <spanx style="verb">YIELD.Options.progress == true</spanx> (for a call that is still ongoing), the <spanx style="emph">Dealer</spanx> will <spanx style="strong">immediately</spanx> send a <spanx style="verb">RESULT</spanx> message to the original <spanx style="emph">Caller</spanx> with
</t>

<figure align="left"><artwork align="left">
    RESULT.Details.progress|bool := true
</artwork></figure>
<t><spanx style="emph">Example.</spanx> Dealer-to-Caller progressive <spanx style="verb">RESULTs</spanx>
</t>

<figure align="left"><artwork align="left">
    [
        50,
        77133,
        {
            "progress": true
        },
        ["Y2010", 120]
    ]
</artwork></figure>

<figure align="left"><artwork align="left">
    [
        50,
        77133,
        {
            "progress": true
        },
        ["Y2011", 205]
    ]
</artwork></figure>
<t>...
</t>
<t>An invocation MUST <spanx style="emph">always</spanx> end in either a <spanx style="emph">normal</spanx> <spanx style="verb">RESULT</spanx> or <spanx style="verb">ERROR</spanx> message being sent by the <spanx style="emph">Callee</spanx> and received by the <spanx style="emph">Dealer</spanx>.
</t>
<t><spanx style="emph">Example.</spanx> Callee-to-Dealer final <spanx style="verb">YIELD</spanx>
</t>

<figure align="left"><artwork align="left">
    [
        70,
        87683,
        {},
        ["Total", 490]
    ]
</artwork></figure>
<t><spanx style="emph">Example.</spanx> Callee-to-Dealer final <spanx style="verb">ERROR</spanx>
</t>

<figure align="left"><artwork align="left">
    [
        4,
        87683,
        {},
        "com.myapp.invalid_revenue_year",
        [1830]
    ]
</artwork></figure>
<t>A call MUST <spanx style="emph">always</spanx> end in either a <spanx style="emph">normal</spanx> <spanx style="verb">RESULT</spanx> or <spanx style="verb">ERROR</spanx> message being sent by the <spanx style="emph">Dealer</spanx> and received by the <spanx style="emph">Caller</spanx>.
</t>
<t><spanx style="emph">Example.</spanx> Dealer-to-Caller final <spanx style="verb">RESULT</spanx>
</t>

<figure align="left"><artwork align="left">
    [
        50,
        77133,
        {},
        ["Total", 490]
    ]
</artwork></figure>
<t><spanx style="emph">Example.</spanx> Dealer-to-Caller final <spanx style="verb">ERROR</spanx>
</t>

<figure align="left"><artwork align="left">
    [
        4,
        77133,
        {},
        "com.myapp.invalid_revenue_year",
        [1830]
    ]
</artwork></figure>
<t>In other words: <spanx style="verb">YIELD</spanx> with <spanx style="verb">YIELD.Options.progress == true</spanx> and <spanx style="verb">RESULT</spanx> with <spanx style="verb">RESULT.Details.progress == true</spanx> messages may only be sent <spanx style="emph">during</spanx> a call or invocation is still ongoing.
</t>
<t>The final <spanx style="verb">YIELD</spanx> and final <spanx style="verb">RESULT</spanx> may also be empty, e.g. when all actual results have already been transmitted in progressive result messages.
</t>
<t><spanx style="emph">Example.</spanx> Callee-to-Dealer <spanx style="verb">YIELDs</spanx>
</t>

<figure align="left"><artwork align="left">
    [70, 87683, {"progress": true}, ["Y2010", 120]]
    [70, 87683, {"progress": true}, ["Y2011", 205]]
     ...
    [70, 87683, {"progress": true}, ["Total", 490]]
    [70, 87683, {}]
</artwork></figure>
<t><spanx style="emph">Example.</spanx> Dealer-to-Caller <spanx style="verb">RESULTs</spanx>
</t>

<figure align="left"><artwork align="left">
    [50, 77133, {"progress": true}, ["Y2010", 120]]
    [50, 77133, {"progress": true}, ["Y2011", 205]]
     ...
    [50, 77133, {"progress": true}, ["Total", 490]]
    [50, 77133, {}]
</artwork></figure>
<t>The progressive <spanx style="verb">YIELD</spanx> and progressive <spanx style="verb">RESULT</spanx> may also be empty, e.g. when those messages are only used to signal that the procedure is still running and working, and the actual result is completely delivered in the final <spanx style="verb">YIELD</spanx> and <spanx style="verb">RESULT</spanx>:
</t>
<t><spanx style="emph">Example.</spanx> Callee-to-Dealer <spanx style="verb">YIELDs</spanx>
</t>

<figure align="left"><artwork align="left">
    [70, 87683, {"progress": true}]
    [70, 87683, {"progress": true}]
    ...
    [70, 87683, {}, [["Y2010", 120], ["Y2011", 205], ...,
        ["Total", 490]]]
</artwork></figure>
<t><spanx style="emph">Example.</spanx> Dealer-to-Caller <spanx style="verb">RESULTs</spanx>
</t>

<figure align="left"><artwork align="left">
    [50, 77133, {"progress": true}]
    [50, 77133, {"progress": true}]
    ...
    [50, 77133, {}, [["Y2010", 120], ["Y2011", 205], ...,
        ["Total", 490]]]
</artwork></figure>
<t><list style="empty">
<t>Note that intermediate, progressive results and/or the final result MAY have different structure. The WAMP peer implementation is responsible for mapping everything into a form suitable for consumption in the host language.
</t>
</list></t>
<t><spanx style="emph">Example.</spanx> Callee-to-Dealer <spanx style="verb">YIELDs</spanx>
</t>

<figure align="left"><artwork align="left">
    [70, 87683, {"progress": true}, ["partial 1", 10]]
    [70, 87683, {"progress": true}, [], {"foo": 10,
        "bar": "partial 1"}]
     ...
    [70, 87683, {}, [1, 2, 3], {"moo": "hello"}]
</artwork></figure>
<t><spanx style="emph">Example.</spanx> Dealer-to-Caller <spanx style="verb">RESULTs</spanx>
</t>

<figure align="left"><artwork align="left">
    [50, 77133, {"progress": true}, ["partial 1", 10]]
    [50, 77133, {"progress": true}, [], {"foo": 10,
        "bar": "partial 1"}]
     ...
    [50, 77133, {}, [1, 2, 3], {"moo": "hello"}]
</artwork></figure>
<t>Even if a <spanx style="emph">Caller</spanx> has indicated its expectation to receive progressive results by setting <spanx style="verb">CALL.Options.receive_progress|bool := true</spanx>, a <spanx style="emph">Callee</spanx> is <spanx style="strong">not required</spanx> to produce progressive results. <spanx style="verb">CALL.Options.receive_progress</spanx> and <spanx style="verb">INVOCATION.Details.receive_progress</spanx> are simply indications that the <spanx style="emph">Caller</spanx> is prepared to process progressive results, should there be any produced. In other words, <spanx style="emph">Callees</spanx> are free to ignore such <spanx style="verb">receive_progress</spanx> hints at any time.
</t>
</section>

<section anchor="callee" title="Callee">
<t>A Callee that does not support progressive results SHOULD ignore any <spanx style="verb">INVOCATION.Details.receive_progress</spanx> flag.
</t>
</section>

<section anchor="feature-announcement" title="Feature Announcement">
<t>Support for this advanced feature MUST be announced by <spanx style="emph">Callers</spanx> (<spanx style="verb">role := "caller"</spanx>), <spanx style="emph">Callees</spanx> (<spanx style="verb">role := "callee"</spanx>) and <spanx style="emph">Dealers</spanx> (<spanx style="verb">role := "dealer"</spanx>) via
</t>

<figure align="left"><artwork align="left">
    HELLO.Details.roles.&lt;role&gt;.features.
         progressive_call_results|bool := true
</artwork></figure>
</section>
</section>

<section anchor="progressive-calls" title="Progressive Calls">

<section anchor="feature-definition-1" title="Feature Definition">
<t>A procedure implemented by a <spanx style="emph">Callee</spanx> and registered at a <spanx style="emph">Dealer</spanx> may receive a progressive call. Progressive results can e.g. be used to start processing initial data where a larger data set may not yet have been generated or received by the <spanx style="emph">Caller</spanx>.
</t>
<t>See this GitHub issue for more discussion: <eref target="https://github.com/wamp-proto/wamp-proto/issues/167"/>
</t>
</section>
</section>

<section anchor="call-timeouts" title="Call Timeouts">

<section anchor="feature-definition-2" title="Feature Definition">
<t>A <spanx style="emph">Caller</spanx> might want to issue a call providing a <spanx style="emph">timeout</spanx> for the call to finish.
</t>
<t>A <spanx style="emph">timeout</spanx> allows to <spanx style="strong">automatically</spanx> cancel a call after a specified time either at the <spanx style="emph">Callee</spanx> or at the <spanx style="emph">Dealer</spanx>.
</t>
<t>A <spanx style="emph">Caller</spanx> specifies a timeout by providing
</t>

<figure align="left"><artwork align="left">
    CALL.Options.timeout|integer
</artwork></figure>
<t>in ms. A timeout value of <spanx style="verb">0</spanx> deactivates automatic call timeout. This is also the default value.
</t>
<t>The timeout option is a companion to, but slightly different from the <spanx style="verb">CANCEL</spanx> and <spanx style="verb">INTERRUPT</spanx> messages that allow a <spanx style="emph">Caller</spanx> and <spanx style="emph">Dealer</spanx> to <spanx style="strong">actively</spanx> cancel a call or invocation.
</t>
<t>In fact, a timeout timer might run at three places:
</t>
<t>
<list style="symbols">
<t><spanx style="emph">Caller</spanx></t>
<t><spanx style="emph">Dealer</spanx></t>
<t><spanx style="emph">Callee</spanx></t>
</list>
</t>
</section>

<section anchor="feature-announcement-1" title="Feature Announcement">
<t>Support for this feature MUST be announced by <spanx style="emph">Callers</spanx> (<spanx style="verb">role := "caller"</spanx>), <spanx style="emph">Callees</spanx> (<spanx style="verb">role := "callee"</spanx>) and <spanx style="emph">Dealers</spanx> (<spanx style="verb">role := "dealer"</spanx>) via
</t>

<figure align="left"><artwork align="left">
    HELLO.Details.roles.&lt;role&gt;.features.call_timeout|bool := true
</artwork></figure>
</section>
</section>

<section anchor="call-canceling" title="Call Canceling">

<section anchor="feature-definition-3" title="Feature Definition">
<t>A <spanx style="emph">Caller</spanx> might want to actively cancel a call that was issued, but not has yet returned. An example where this is useful could be a user triggering a long running operation and later changing his mind or no longer willing to wait.
</t>
<t>The message flow between <spanx style="emph">Callers</spanx>, a <spanx style="emph">Dealer</spanx> and <spanx style="emph">Callees</spanx> for canceling remote procedure calls involves the following messages:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">CANCEL</spanx></t>
<t><spanx style="verb">INTERRUPT</spanx></t>
<t><spanx style="verb">ERROR</spanx></t>
</list>
</t>
<t>A call may be canceled at the <spanx style="emph">Callee</spanx> oratthe<spanx style="emph">Dealer</spanx> side. Cancelation behaves differently depending on the mode:
</t>
<t>
<list style="symbols">
<t><spanx style="strong">skip</spanx>: The pending call is canceled and <spanx style="verb">ERROR</spanx> is sent immediately back to the caller. No <spanx style="verb">INTERRUPT</spanx> is sent to the callee and the result is discarded when received.</t>
<t><spanx style="strong">kill</spanx>: <spanx style="verb">INTERRUPT</spanx> is sent to the callee, but <spanx style="verb">ERROR</spanx> is not returned to the caller until after the callee has responded to the canceled call. In this case the caller may receive <spanx style="verb">RESULT</spanx> or <spanx style="verb">ERROR</spanx> depending whether the callee finishes processing the invocation or the interrupt first.</t>
<t><spanx style="strong">killnowait</spanx>: The pending call is canceled and <spanx style="verb">ERROR</spanx> is send immediately back to the caller. <spanx style="verb">INTERRUPT</spanx> is sent to the callee and any response to the invocation or interrupt from the callee is discarded when received.</t>
</list>
</t>
<t>If the callee does not support call canceling, then behavior is <spanx style="strong">skip</spanx>.
</t>
<t>Message flow during call canceling when<spanx style="emph">Callee</spanx> supports this feature andmode is <spanx style="verb">kill</spanx>
</t>

<figure align="left"><artwork align="left">
    ,------.          ,------.          ,------.
    |Caller|          |Dealer|          |Callee|
    `--+---'          `--+---'          `--+---'
       |       CALL      |                 |    
       | ----------------&gt;                 |    
       |                 |                 |    
       |                 |    INVOCATION   |    
       |                 | ----------------&gt;    
       |                 |                 |    
       |      CANCEL     |                 |    
       | ----------------&gt;                 |    
       |                 |                 |    
       |                 |    INTERRUPT    |    
       |                 | ----------------&gt;    
       |                 |                 |    
       |                 |      ERROR      |    
       |                 | &lt;----------------    
       |                 |                 |    
       |      ERROR      |                 |    
       | &lt;----------------                 |    
    ,--+---.          ,--+---.          ,--+---.
    |Caller|          |Dealer|          |Callee|
    `------'          `------'          `------'
</artwork></figure>
<t>Message flow during call canceling when<spanx style="emph">Callee</spanx> does not support this feature ormode is <spanx style="verb">skip</spanx>
</t>

<figure align="left"><artwork align="left">
    ,------.          ,------.            ,------.
    |Caller|          |Dealer|            |Callee|
    `--+---'          `--+---'            `--+---'
       |       CALL      |                   |    
       | ----------------&gt;                   |    
       |                 |                   |    
       |                 |    INVOCATION     |    
       |                 | ----------------&gt; |   
       |                 |                   |    
       |      CANCEL     |                   |    
       | ----------------&gt;                   |    
       |                 |                   |    
       |      ERROR      |                   |    
       | &lt;----------------                   |    
       |                 |                   |    
       |                 | RESULT (skipped)  |    
       |                 | &lt;---------------- |    
       |                 |                   |    
       |                 | or ERROR (skipped)|    
       |                 | &lt;-----------------    
    ,--+---.          ,--+---.            ,--+---.
    |Caller|          |Dealer|            |Callee|
    `------'          `------'            `------'
</artwork></figure>
<t>Message flow during call canceling when<spanx style="emph">Callee</spanx> supports this feature andmode is <spanx style="verb">killnowait</spanx>
</t>

<figure align="left"><artwork align="left">
    ,------.          ,------.          ,------.
    |Caller|          |Dealer|          |Callee|
    `--+---'          `--+---'          `--+---'
       |       CALL      |                 |    
       | ----------------&gt;                 |    
       |                 |                 |    
       |                 |    INVOCATION   |    
       |                 | ----------------&gt;    
       |                 |                 |    
       |      CANCEL     |                 |    
       | ----------------&gt;                 |    
       |                 |                 |    
       |      ERROR      |                 |    
       | &lt;----------------                 |    
       |                 |    INTERRUPT    |    
       |                 | ----------------&gt;    
       |                 |                 |    
       |                 |      ERROR      |    
       |                 | &lt;----------------    
       |                 |                 |    
    ,--+---.          ,--+---.          ,--+---.
    |Caller|          |Dealer|          |Callee|
    `------'          `------'          `------'
</artwork></figure>
<t>A <spanx style="emph">Caller</spanx> cancels a remote procedure call initiated (but not yet finished) by sending a <spanx style="verb">CANCEL</spanx> message to the <spanx style="emph">Dealer</spanx>:
</t>

<figure align="left"><artwork align="left">
    [CANCEL, CALL.Request|id, Options|dict]
</artwork></figure>
<t>A <spanx style="emph">Dealer</spanx> cancels an invocation of an endpoint initiated (but not yet finished) by sending a <spanx style="verb">INTERRUPT</spanx> message to the <spanx style="emph">Callee</spanx>:
</t>

<figure align="left"><artwork align="left">
    [INTERRUPT, INVOCATION.Request|id, Options|dict]
</artwork></figure>
<t>Options:
</t>

<figure align="left"><artwork align="left">
    CANCEL.Options.mode|string == "skip" | "kill" | "killnowait"
</artwork></figure>
</section>

<section anchor="feature-announcement-2" title="Feature Announcement">
<t>Support for this feature MUST be announced by <spanx style="emph">Callers</spanx> (<spanx style="verb">role := "caller"</spanx>), <spanx style="emph">Callees</spanx> (<spanx style="verb">role := "callee"</spanx>) and <spanx style="emph">Dealers</spanx> (<spanx style="verb">role := "dealer"</spanx>) via
</t>

<figure align="left"><artwork align="left">
    HELLO.Details.roles.&lt;role&gt;.features.call_canceling|bool := true
</artwork></figure>
</section>
</section>

<section anchor="caller-identification" title="Caller Identification">

<section anchor="feature-definition-4" title="Feature Definition">
<t>A <spanx style="emph">Caller</spanx> MAY <spanx style="strong">request</spanx> the disclosure of its identity (its WAMP session ID) to endpoints of a routed call via
</t>

<figure align="left"><artwork align="left">
    CALL.Options.disclose_me|bool := true
</artwork></figure>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [48, 7814135, {"disclose_me": true}, "com.myapp.echo",
        ["Hello, world!"]]
</artwork></figure>
<t>If above call is issued by a <spanx style="emph">Caller</spanx> with WAMP session ID <spanx style="verb">3335656</spanx>, the <spanx style="emph">Dealer</spanx> sends an <spanx style="verb">INVOCATION</spanx> message to <spanx style="emph">Callee</spanx> with the <spanx style="emph">Caller's</spanx> WAMP session ID in <spanx style="verb">INVOCATION.Details.caller</spanx>:
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [68, 6131533, 9823526, {"caller": 3335656}, ["Hello, world!"]]
</artwork></figure>
<t>Note that a <spanx style="emph">Dealer</spanx> MAY disclose the identity of a <spanx style="emph">Caller</spanx> even without the <spanx style="emph">Caller</spanx> having explicitly requested to do so when the <spanx style="emph">Dealer</spanx> configuration (for the called procedure) is setup to do so.
</t>
<t>A <spanx style="emph">Dealer</spanx> MAY deny a <spanx style="emph">Caller's</spanx> request to disclose its identity:
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [8, 7814135, "wamp.error.disclose_me.not_allowed"]
</artwork></figure>
<t>A <spanx style="emph">Callee</spanx> MAY <spanx style="strong">request</spanx> the disclosure of caller identity via
</t>

<figure align="left"><artwork align="left">
    REGISTER.Options.disclose_caller|bool := true
</artwork></figure>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [64, 927639114088448, {"disclose_caller":true},
        "com.maypp.add2"]
</artwork></figure>
<t>With the above registration, the registered procedure is called with the caller's sessionID as part of the call details object.
</t>
</section>

<section anchor="feature-announcement-3" title="Feature Announcement">
<t>Support for this feature MUST be announced by <spanx style="emph">Callers</spanx> (<spanx style="verb">role := "caller"</spanx>), <spanx style="emph">Callees</spanx> (<spanx style="verb">role := "callee"</spanx>) and <spanx style="emph">Dealers</spanx> (<spanx style="verb">role := "dealer"</spanx>) via
</t>

<figure align="left"><artwork align="left">
    HELLO.Details.roles.&lt;role&gt;.features.
         caller_identification|bool := true
</artwork></figure>
</section>
</section>

<section anchor="call-trust-levels" title="Call Trust Levels">

<section anchor="feature-defintion" title="Feature Defintion">
<t>A <spanx style="emph">Dealer</spanx> may be configured to automatically assign <spanx style="emph">trust levels</spanx> to calls issued by <spanx style="emph">Callers</spanx> according to the <spanx style="emph">Dealer</spanx> configuration on a per-procedure basis and/or depending on the application defined role of the (authenticated) <spanx style="emph">Caller</spanx>.
</t>
<t>A <spanx style="emph">Dealer</spanx> supporting trust level will provide
</t>

<figure align="left"><artwork align="left">
    INVOCATION.Details.trustlevel|integer
</artwork></figure>
<t>in an <spanx style="verb">INVOCATION</spanx> message sent to a <spanx style="emph">Callee</spanx>. The trustlevel <spanx style="verb">0</spanx> means lowest trust, and higher integers represent (application-defined) higher levels of trust.
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [68, 6131533, 9823526, {"trustlevel": 2}, ["Hello, world!"]]
</artwork></figure>
<t>In above event, the <spanx style="emph">Dealer</spanx> has (by configuration and/or other information) deemed the call (and hence the invocation) to be of trustlevel <spanx style="verb">2</spanx>.
</t>
</section>

<section anchor="feature-announcement-4" title="Feature Announcement">
<t>Support for this feature MUST be announced by <spanx style="emph">Callees</spanx> (<spanx style="verb">role := "callee"</spanx>) and <spanx style="emph">Dealers</spanx> (<spanx style="verb">role := "dealer"</spanx>) via
</t>

<figure align="left"><artwork align="left">
    HELLO.Details.roles.&lt;role&gt;.features.call_trustlevels|bool := true
</artwork></figure>
</section>
</section>

<section anchor="registration-meta-api" title="Registration Meta API">

<section anchor="feature-definition-5" title="Feature Definition">

<section anchor="introduction-1" title="Introduction">
<t><spanx style="strong">Registration Meta Events</spanx> are fired when registrations are first created, when <spanx style="emph">Callees</spanx> are attached (removed) to (from) a registration, and when registrations are finally destroyed.
</t>
<t>Furthermore, WAMP allows actively retrieving information about registrations via <spanx style="strong">Registration Meta Procedures</spanx>.
</t>
<t>Meta-events are created by the router itself. This means that the events as well as the data received when calling a meta-procedure can be accorded the same trust level as the router.
</t>
<t><list style="empty">
<t>Note that an implementation that only supports a <spanx style="emph">Broker</spanx> or <spanx style="emph">Dealer</spanx> role, not both at the same time, essentially cannot offer the <spanx style="strong">Registration Meta API</spanx>, as it requires both roles to support this feature.
</t>
</list></t>
</section>

<section anchor="registration-meta-events" title="Registration Meta Events">
<t>A client can subscribe to the following registration meta-events, which cover the lifecycle of a registration:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">wamp.registration.on_create</spanx>: Fired when a registration is created through a registration request for an URI which was previously without a registration.</t>
<t><spanx style="verb">wamp.registration.on_register</spanx>: Fired when a <spanx style="emph">Callee</spanx> session is added to a registration.</t>
<t><spanx style="verb">wamp.registration.on_unregister</spanx>: Fired when a <spanx style="emph">Callee</spanx> session is removed from a registration.</t>
<t><spanx style="verb">wamp.registration.on_delete</spanx>: Fired when a registration is deleted after the last <spanx style="emph">Callee</spanx> session attached to it has been removed.</t>
</list>
</t>
<t>A <spanx style="verb">wamp.registration.on_register</spanx> event MUST be fired subsequent to a <spanx style="verb">wamp.registration.on_create</spanx> event, since the first registration results in both the creation of the registration and the addition of a session.
</t>
<t>Similarly, the <spanx style="verb">wamp.registration.on_delete</spanx> event MUST be preceded by a <spanx style="verb">wamp.registration.on_unregister</spanx> event.
</t>
<t><spanx style="strong">Registration Meta Events</spanx> MUST be dispatched by the router to the same realm as the WAMP session which triggered the event.
</t>

<section anchor="wampregistrationoncreate" title="wamp.registration.on_create">
<t>Fired when a registration is created through a registration request for an URI which was previously without a registration. The event payload consists of positional arguments:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">session|id</spanx>: The session ID performing the registration request.</t>
<t><spanx style="verb">RegistrationDetails|dict</spanx>: Information on the created registration.</t>
</list>
</t>
<t><spanx style="strong">Object Schemas</spanx>
</t>

<figure align="left"><artwork align="left">
    RegistrationDetails :=
    {
        "id": registration|id,
        "created": time_created|iso_8601_string,
        "uri": procedure|uri,
        "match": match_policy|string,
        "invoke": invocation_policy|string
    }
</artwork></figure>
<t>See <eref target="pattern-based-registration.md">Pattern-based Registrations</eref> for a description of <spanx style="verb">match_policy</spanx>.
</t>
<t><list style="empty">
<t>NOTE: invocation_policy IS NOT YET DESCRIBED IN THE ADVANCED SPEC
</t>
</list></t>
</section>

<section anchor="wampregistrationonregister" title="wamp.registration.on_register">
<t>Fired when a session is added to a registration. The event payload consists of positional arguments:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">session|id</spanx>: The ID of the session being added to a registration.</t>
<t><spanx style="verb">registration|id</spanx>: The ID of the registration to which a session is being added.</t>
</list>
</t>
</section>

<section anchor="wampregistrationonunregister" title="wamp.registration.on_unregister">
<t>Fired when a session is removed from a subscription. The event payload consists of positional arguments:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">session|id</spanx>: The ID of the session being removed from a registration.</t>
<t><spanx style="verb">registration|id</spanx>: The ID of the registration from which a session is being removed.</t>
</list>
</t>
</section>

<section anchor="wampregistrationondelete" title="wamp.registration.on_delete">
<t>Fired when a registration is deleted after the last session attached to it has been removed. The event payload consists of positional arguments:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">session|id</spanx>: The ID of the last session being removed from a registration.</t>
<t><spanx style="verb">registration|id</spanx>: The ID of the registration being deleted.</t>
</list>
</t>
</section>
</section>

<section anchor="registration-metaprocedures" title="Registration Meta-Procedures">
<t>A client can actively retrieve information about registrations via the following meta-procedures:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">wamp.registration.list</spanx>: Retrieves registration IDs listed according to match policies.</t>
<t><spanx style="verb">wamp.registration.lookup</spanx>: Obtains the registration (if any) managing a procedure, according to some match policy.</t>
<t><spanx style="verb">wamp.registration.match</spanx>: Obtains the registration best matching a given procedure URI.</t>
<t><spanx style="verb">wamp.registration.get</spanx>: Retrieves information on a particular registration.</t>
<t><spanx style="verb">wamp.registration.list_callees</spanx>: Retrieves a list of session IDs for sessions currently attached to the registration.</t>
<t><spanx style="verb">wamp.registration.count_callees</spanx>: Obtains the number of sessions currently attached to the registration.</t>
</list>
</t>

<section anchor="wampregistrationlist" title="wamp.registration.list">
<t>Retrieves registration IDs listed according to match policies.
</t>
<t><spanx style="strong">Arguments</spanx>
</t>
<t>
<list style="symbols">
<t>None</t>
</list>
</t>
<t><spanx style="strong">Results</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">RegistrationLists|dict</spanx>: A dictionary with a list of registration IDs for each match policy.</t>
</list>
</t>
<t><spanx style="strong">Object Schemas</spanx>
</t>

<figure align="left"><artwork align="left">
    RegistrationLists :=
    {
        "exact": registration_ids|list,
        "prefix": registration_ids|list,
        "wildcard": registration_ids|list
    }
</artwork></figure>
<t>See <eref target="pattern-based-registration.md">Pattern-based Registrations</eref> for a description of match policies.
</t>
</section>

<section anchor="wampregistrationlookup" title="wamp.registration.lookup">
<t>Obtains the registration (if any) managing a procedure, according to some match policy.
</t>
<t><spanx style="strong">Arguments</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">procedure|uri</spanx>: The procedure to lookup the registration for.</t>
<t>(Optional) <spanx style="verb">options|dict</spanx>: Same options as when registering a procedure.</t>
</list>
</t>
<t><spanx style="strong">Results</spanx>
</t>
<t>
<list style="symbols">
<t>(Nullable) <spanx style="verb">registration|id</spanx>: The ID of the registration managing the procedure, if found, or null.</t>
</list>
</t>
</section>

<section anchor="wampregistrationmatch" title="wamp.registration.match">
<t>Obtains the registration best matching a given procedure URI.
</t>
<t><spanx style="strong">Arguments</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">procedure|uri</spanx>: The procedure URI to match</t>
</list>
</t>
<t><spanx style="strong">Results</spanx>
</t>
<t>
<list style="symbols">
<t>(Nullable) <spanx style="verb">registration|id</spanx>: The ID of best matching registration, or null.</t>
</list>
</t>
</section>

<section anchor="wampregistrationget" title="wamp.registration.get">
<t>Retrieves information on a particular registration.
</t>
<t><spanx style="strong">Arguments</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">registration|id</spanx>: The ID of the registration to retrieve.</t>
</list>
</t>
<t><spanx style="strong">Results</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">RegistrationDetails|dict</spanx>: Details on the registration.</t>
</list>
</t>
<t><spanx style="strong">Error URIs</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">wamp.error.no_such_registration</spanx>: No registration with the given ID exists on the router.</t>
</list>
</t>
<t><spanx style="strong">Object Schemas</spanx>
</t>

<figure align="left"><artwork align="left">
    RegistrationDetails :=
    {
        "id": registration|id,
        "created": time_created|iso_8601_string,
        "uri": procedure|uri,
        "match": match_policy|string,
        "invoke": invocation_policy|string
    }
</artwork></figure>
<t>See <eref target="pattern-based-registration.md">Pattern-based Registrations</eref> for a description of match policies.
</t>
<t><spanx style="emph">NOTE: invocation_policy IS NOT YET DESCRIBED IN THE ADVANCED SPEC</spanx>
</t>
</section>

<section anchor="wampregistrationlistcallees" title="wamp.registration.list_callees">
<t>Retrieves a list of session IDs for sessions currently attached to the registration.
</t>
<t><spanx style="strong">Arguments</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">registration|id</spanx>: The ID of the registration to get calles for.</t>
</list>
</t>
<t><spanx style="strong">Results</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">callee_ids|list</spanx>: A list of WAMP session IDs of callees currently attached to the registration.</t>
</list>
</t>
<t><spanx style="strong">Error URIs</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">wamp.error.no_such_registration</spanx>: No registration with the given ID exists on the router.</t>
</list>
</t>
</section>

<section anchor="wampregistrationcountcallees" title="wamp.registration.count_callees">
<t>Obtains the number of sessions currently attached to a registration.
</t>
<t><spanx style="strong">Arguments</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">registration|id</spanx>: The ID of the registration to get the number of callees for.</t>
</list>
</t>
<t><spanx style="strong">Results</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">count|int</spanx>: The number of callees currently attached to a registration.</t>
</list>
</t>
<t><spanx style="strong">Error URIs</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">wamp.error.no_such_registration</spanx>: No registration with the given ID exists on the router.</t>
</list>
</t>
</section>
</section>
</section>

<section anchor="feature-announcement-5" title="Feature Announcement">
<t>Support for this feature MUST be announced by a <spanx style="emph">Dealers</spanx> (<spanx style="verb">role := "dealer"</spanx>) via:
</t>

<figure align="left"><artwork align="left">
    HELLO.Details.roles.&lt;role&gt;.features.
        registration_meta_api|bool := true
</artwork></figure>
<t><spanx style="strong">Example</spanx>
</t>
<t>Here is a <spanx style="verb">WELCOME</spanx> message from a <spanx style="emph">Router</spanx> with support for both the <spanx style="emph">Broker</spanx> and <spanx style="emph">Dealer</spanx> role, and with support for <spanx style="strong">Registration Meta API</spanx>:
</t>

<figure align="left"><artwork align="left">
    [
        2,
        4580268554656113,
        {
            "authid":"OL3AeppwDLXiAAPbqm9IVhnw",
            "authrole": "anonymous",
            "authmethod": "anonymous",
            "roles": {
                "broker": {
                    "features": {
                    }
                },
                "dealer": {
                    "features": {
                        "registration_meta_api": true
                    }
                }
            }
        }
    ]
</artwork></figure>
</section>
</section>

<section anchor="patternbased-registrations" title="Pattern-based Registrations">

<section anchor="feature-definition-6" title="Feature Definition">

<section anchor="introduction-2" title="Introduction">
<t>By default, <spanx style="emph">Callees</spanx> register procedures with <spanx style="strong">exact matching policy</spanx>. That is a call will only be routed to a <spanx style="emph">Callee</spanx> by the <spanx style="emph">Dealer</spanx> if the procedure called (<spanx style="verb">CALL.Procedure</spanx>) <spanx style="emph">exactly</spanx> matches the endpoint registered (<spanx style="verb">REGISTER.Procedure</spanx>).
</t>
<t>A <spanx style="emph">Callee</spanx> might want to register procedures based on a <spanx style="emph">pattern</spanx>. This can be useful to reduce the number of individual registrations to be set up or to subscribe to a open set of topics, not known beforehand by the <spanx style="emph">Subscriber</spanx>.
</t>
<t>If the <spanx style="emph">Dealer</spanx> and the <spanx style="emph">Callee</spanx> support <spanx style="strong">pattern-based registrations</spanx>, this matching can happen by
</t>
<t>
<list style="symbols">
<t><spanx style="strong">prefix-matching policy</spanx></t>
<t><spanx style="strong">wildcard-matching policy</spanx></t>
</list>
</t>
</section>

<section anchor="prefix-matching" title="Prefix Matching">
<t>A <spanx style="emph">Callee</spanx> requests <spanx style="strong">prefix-matching policy</spanx> with a registration request by setting
</t>

<figure align="left"><artwork align="left">
    REGISTER.Options.match|string := "prefix"
</artwork></figure>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [
        64,
        612352435,
        {
            "match": "prefix"
        },
        "com.myapp.myobject1"
    ]
</artwork></figure>
<t>When a <spanx style="strong">prefix-matching policy</spanx> is in place, any call with a procedure that has <spanx style="verb">REGISTER.Procedure</spanx> as a <spanx style="emph">prefix</spanx> will match the registration, and potentially be routed to <spanx style="emph">Callees</spanx> on that registration.
</t>
<t>In above example, the following calls with <spanx style="verb">CALL.Procedure</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">com.myapp.myobject1.myprocedure1</spanx></t>
<t><spanx style="verb">com.myapp.myobject1-mysubobject1</spanx></t>
<t><spanx style="verb">com.myapp.myobject1.mysubobject1.myprocedure1</spanx></t>
<t><spanx style="verb">com.myapp.myobject1</spanx></t>
</list>
</t>
<t>will all apply for call routing. A call with one of the following <spanx style="verb">CALL.Procedure</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">com.myapp.myobject2</spanx></t>
<t><spanx style="verb">com.myapp.myobject</spanx></t>
</list>
</t>
<t>will not apply.
</t>
</section>

<section anchor="wildcard-matching" title="Wildcard Matching">
<t>A <spanx style="emph">Callee</spanx> requests <spanx style="strong">wildcard-matching policy</spanx> with a registration request by setting
</t>

<figure align="left"><artwork align="left">
    REGISTER.Options.match|string := "wildcard"
</artwork></figure>
<t>Wildcard-matching allows to provide wildcards for <spanx style="strong">whole</spanx> URI components.
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [
        64,
        612352435,
        {
            "match": "wildcard"
        },
        "com.myapp..myprocedure1"
    ]
</artwork></figure>
<t>In the above registration request, the 3rd URI component is empty, which signals a wildcard in that URI component position. In this example, calls with <spanx style="verb">CALL.Procedure</spanx> e.g.
</t>
<t>
<list style="symbols">
<t><spanx style="verb">com.myapp.myobject1.myprocedure1</spanx></t>
<t><spanx style="verb">com.myapp.myobject2.myprocedure1</spanx></t>
</list>
</t>
<t>will all apply for call routing. Calls with <spanx style="verb">CALL.Procedure</spanx> e.g.
</t>
<t>
<list style="symbols">
<t><spanx style="verb">com.myapp.myobject1.myprocedure1.mysubprocedure1</spanx></t>
<t><spanx style="verb">com.myapp.myobject1.myprocedure2</spanx></t>
<t><spanx style="verb">com.myapp2.myobject1.myprocedure1</spanx></t>
</list>
</t>
<t>will not apply for call routing.
</t>
<t>When a single call matches more than one of a <spanx style="emph">Callees</spanx> registrations, the call MAY be routed for invocation on multiple registrations, depending on call settings.
</t>
</section>

<section anchor="general" title="General">

<section anchor="no-set-semantics" title="No set semantics">
<t>Since each <spanx style="emph">Callee</spanx>'s' registrations &quot;stands on its own&quot;, there is no <spanx style="emph">set semantics</spanx> implied by pattern-based registrations.
</t>
<t>E.g. a <spanx style="emph">Callee</spanx> cannot register to a broad pattern, and then unregister from a subset of that broad pattern to form a more complex registration. Each registration is separate.
</t>
</section>

<section anchor="calls-matching-multiple-registrations" title="Calls matching multiple registrations">
<t>The behavior when a single call matches more than one of a <spanx style="emph">Callee's</spanx> registrations or more than one registration in general is still being discussed.
</t>
</section>

<section anchor="concrete-procedure-called" title="Concrete procedure called">
<t>If an endpoint was registered with a pattern-based matching policy, a <spanx style="emph">Dealer</spanx> MUST supply the original <spanx style="verb">CALL.Procedure</spanx> as provided by the <spanx style="emph">Caller</spanx> in
</t>

<figure align="left"><artwork align="left">
    INVOCATION.Details.procedure
</artwork></figure>
<t>to the <spanx style="emph">Callee</spanx>.
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [
        68,
        6131533,
        9823527,
        {
            "procedure": "com.myapp.procedure.proc1"
        },
        ["Hello, world!"]
    ]
</artwork></figure>
</section>
</section>
</section>

<section anchor="feature-announcement-6" title="Feature Announcement">
<t>Support for this feature MUST be announced by <spanx style="emph">Callees</spanx> (<spanx style="verb">role := "callee"</spanx>) and <spanx style="emph">Dealers</spanx> (<spanx style="verb">role := "dealer"</spanx>) via
</t>

<figure align="left"><artwork align="left">
    HELLO.Details.roles.&lt;role&gt;.features.
        pattern_based_registration|bool := true
</artwork></figure>
</section>
</section>

<section anchor="shared-registration" title="Shared Registration">
<t>Feature status: <spanx style="strong">alpha</spanx>
</t>

<section anchor="feature-definition-7" title="Feature Definition">
<t>As a default, only a single <spanx style="strong">Callee</spanx> may register a procedure for an URI.
</t>
<t>There are use cases where more flexibility is required. As an example, for an application component with a high computing load, several instances may run, and load balancing of calls across these may be desired. As another example, in an application a second or third component providing a procedure may run, which are only to be called in case the primary component is no longer reachable (hot standby).
</t>
<t>When shared registrations are supported, then the first <spanx style="strong">Callee</spanx> to register a procedure for a particular URI MAY determine that additional registrations for this URI are allowed, and what <spanx style="strong">Invocation Rules</spanx> to apply in case such additional registrations are made.
</t>
<t>This is done through setting
</t>

<figure align="left"><artwork align="left">
    REGISTER.Options.invoke|string := &lt;invocation_policy&gt;
</artwork></figure>
<t>where <spanx style="verb">&lt;invocation_policy&gt;</spanx> is one of
</t>
<t>
<list style="symbols">
<t>'single'</t>
<t>'roundrobin'</t>
<t>'random'</t>
<t>'first'</t>
<t>'last'</t>
</list>
</t>
<t>If the option is not set, 'single' is applied as a default.
</t>
<t>With 'single', the <spanx style="strong">Dealer</spanx> MUST fail all subsequent attempts to register a procedure for the URI while the registration remains in existence.
</t>
<t>With the other values, the <spanx style="strong">Dealer</spanx> MUST fail all subsequent attempst to register a procedure for the URI where the value for this option does not match that of the initial registration.
</t>

<section anchor="load-balancing" title="Load Balancing">
<t>For sets of registrations registered using either 'roundrobin' or 'random', load balancing is performed across calls to the URI.
</t>
<t>For 'roundrobin', callees are picked subsequently from the list of registrations (ordered by the order of registration), with the picking looping back to the beginning of the list once the end has been reached.
</t>
<t>For 'random' a callee is picked randomly from the list of registrations for each call.
</t>
</section>

<section anchor="hot-standby" title="Hot Stand-By">
<t>For sets of registrations registered using either 'first' or 'last', the first respectively last callee on the current list of registrations (ordered by the order of registration) is called.
</t>
</section>
</section>

<section anchor="feature-announcement-7" title="Feature Announcement">
<t>Support for this feature MUST be announced by <spanx style="emph">Callees</spanx> (<spanx style="verb">role := "callee"</spanx>) and <spanx style="emph">Dealers</spanx> (<spanx style="verb">role := "dealer"</spanx>) via
</t>

<figure align="left"><artwork align="left">
    HELLO.Details.roles.&lt;role&gt;.features.
        shared_registration|bool := true
</artwork></figure>
</section>
</section>

<section anchor="sharded-registration" title="Sharded Registration">
<t>Feature status: <spanx style="strong">sketch</spanx>
</t>

<section anchor="feature-definition-8" title="Feature Definition">
<t><spanx style="strong">Sharded Registrations</spanx> are intended to allow calling a procedure which is offered by a sharded database, by routing the call to a single shard.
</t>
</section>

<section anchor="partitioned-calls" title="&quot;Partitioned&quot; Calls">
<t>If <spanx style="verb">CALL.Options.runmode == "partition"</spanx>, then <spanx style="verb">CALL.Options.rkey</spanx> MUST be present.
</t>
<t>The call is then routed to all endpoints that were registered ..
</t>
<t>The call is then processed as for &quot;All&quot; Calls.
</t>
</section>

<section anchor="feature-announcement-8" title="Feature Announcement">
<t>Support for this feature MUST be announced by <spanx style="emph">Callers</spanx> (<spanx style="verb">role := "caller"</spanx>), <spanx style="emph">Callees</spanx> (<spanx style="verb">role := "callee"</spanx>) and <spanx style="emph">Dealers</spanx> (<spanx style="verb">role := "dealer"</spanx>) via
</t>

<figure align="center"><artwork align="center">
HELLO.Details.roles.&lt;role&gt;.features.sharded_registration|bool := true
</artwork></figure>
</section>
</section>

<section anchor="registration-revocation" title="Registration Revocation">

<section anchor="feature-definition-9" title="Feature Definition">
<t>Actively and forcefully revoke a previously granted registration from a session.
</t>
</section>

<section anchor="feature-announcement-9" title="Feature Announcement">
</section>
</section>

<section anchor="procedure-reflection" title="Procedure Reflection">
<t>Feature status: <spanx style="strong">sketch</spanx>
</t>
<t><spanx style="emph">Reflection</spanx> denotes the ability of WAMP peers to examine the procedures, topics and errors provided or used by other peers.
</t>
<t>I.e. a WAMP <spanx style="emph">Caller</spanx>, <spanx style="emph">Callee</spanx>, <spanx style="emph">Subscriber</spanx> or <spanx style="emph">Publisher</spanx> may be interested in retrieving a machine readable list and description of WAMP procedures and topics it is authorized to access or provide in the context of a WAMP session with a <spanx style="emph">Dealer</spanx> or <spanx style="emph">Broker</spanx>.
</t>
<t>Reflection may be useful in the following cases:
</t>
<t>
<list style="symbols">
<t>documentation</t>
<t>discoverability</t>
<t>generating stubs and proxies</t>
</list>
</t>
<t>WAMP predefines the following procedures for performing run-time reflection on WAMP peers which act as <spanx style="emph">Brokers</spanx> and/or <spanx style="emph">Dealers</spanx>.
</t>
<t>Predefined WAMP reflection procedures to <spanx style="emph">list</spanx> resources by type:
</t>

<figure align="left"><artwork align="left">
    wamp.reflection.topic.list
    wamp.reflection.procedure.list
    wamp.reflection.error.list
</artwork></figure>
<t>Predefined WAMP reflection procedures to <spanx style="emph">describe</spanx> resources by type:
</t>

<figure align="left"><artwork align="left">
    wamp.reflection.topic.describe
    wamp.reflection.procedure.describe
    wamp.reflection.error.describe
</artwork></figure>
<t>A peer that acts as a <spanx style="emph">Broker</spanx> SHOULD announce support for the reflection API by sending
</t>

<figure align="left"><artwork align="left">
    HELLO.Details.roles.broker.reflection|bool := true
</artwork></figure>
<t>A peer that acts as a <spanx style="emph">Dealer</spanx> SHOULD announce support for the reflection API by sending
</t>

<figure align="left"><artwork align="left">
    HELLO.Details.roles.dealer.reflection|bool := true
</artwork></figure>
<t><list style="empty">
<t>Since <spanx style="emph">Brokers</spanx> might provide (broker) procedures and <spanx style="emph">Dealers</spanx> might provide (dealer) topics, both SHOULD implement the complete API above (even if the peer only implements one of <spanx style="emph">Broker</spanx> or <spanx style="emph">Dealer</spanx> roles).
</t>
</list></t>
<t><spanx style="strong">Reflection</spanx>
</t>
<t>A topic or procedure is defined for reflection:
</t>

<figure align="left"><artwork align="left">
    wamp.reflect.define
</artwork></figure>
<t>A topic or procedure was asked to be described (reflected upon):
</t>

<figure align="left"><artwork align="left">
    wamp.reflect.describe
</artwork></figure>
<t><spanx style="strong">Reflection</spanx>
</t>
<t>A topic or procedure has been defined for reflection:
</t>

<figure align="left"><artwork align="left">
    wamp.reflect.on_define
</artwork></figure>
<t>A topic or procedure has been unfined from reflection:
</t>

<figure align="left"><artwork align="left">
    wamp.reflect.on_undefine
</artwork></figure>
</section>
</section>

<section anchor="advanced-pubsub-features" title="Advanced PubSub Features">

<section anchor="subscriber-black-and-whitelisting" title="Subscriber Black- and Whitelisting">

<section anchor="introduction-3" title="Introduction">
<t><spanx style="strong">Subscriber Black- and Whitelisting</spanx> is an advanced <spanx style="emph">Broker</spanx> feature where a <spanx style="emph">Publisher</spanx> is able to restrict the set of receivers of a published event.
</t>
<t>Under normal Publish &amp; Subscriber event dispatching, a <spanx style="emph">Broker</spanx> will dispatch a published event to all (authorized) <spanx style="emph">Subscribers</spanx> other than the <spanx style="emph">Publisher</spanx> itself. This set of receivers can be further reduced on a per-publication basis by the <spanx style="emph">Publisher</spanx> using <spanx style="strong">Subscriber Black- and Whitelisting</spanx>.
</t>
<t>The <spanx style="emph">Publisher</spanx> can explicitly <spanx style="strong">exclude</spanx> <spanx style="emph">Subscribers</spanx> based on WAMP <spanx style="verb">sessionid</spanx>, <spanx style="verb">authid</spanx> or <spanx style="verb">authrole</spanx>. This is referred to as <spanx style="strong">Blacklisting</spanx>.
</t>
<t>A <spanx style="emph">Publisher</spanx> may also explicitly define a <spanx style="strong">eligible</spanx> list of *Subscribers** based on WAMP <spanx style="verb">sessionid</spanx>, <spanx style="verb">authid</spanx> or <spanx style="verb">authrole</spanx>. This is referred to as <spanx style="strong">Whitelisting</spanx>.
</t>
</section>

<section anchor="use-cases" title="Use Cases">

<section anchor="avoiding-callers-from-being-selfnotified" title="Avoiding Callers from being self-notified">
<t>Consider an application that exposes a procedure to update a product price. The procedure might not only actually update the product price (e.g. in a backend database), but additionally publish an event with the updated product price, so that <spanx style="strong">all</spanx> application components get notified actively of the new price.
</t>
<t>However, the application might want to exclude the originator of the product price update (the <spanx style="strong">Caller</spanx> of the price update procedure) from receiving the update event - as the originator naturally already knows the new price, and might get confused when it receives an update the <spanx style="strong">Caller</spanx> has triggered himself.
</t>
<t>The product price update procedure can use <spanx style="verb">PUBLISH.Options.exclude|list[int]</spanx> to exclude the <spanx style="strong">Caller</spanx> of the procedure.
</t>
<t><list style="empty">
<t>Note that the product price update procedure needs to know the session ID of the <spanx style="strong">Caller</spanx> to be able to exclude him. For this, please see <spanx style="strong">Caller Identification</spanx>.
</t>
</list></t>
<t>A similar approach can be used for other CRUD-like procedures.
</t>
</section>

<section anchor="restricting-receivers-of-sensitive-information" title="Restricting receivers of sensitive information">
<t>Consider an application with users that have different <spanx style="verb">authroles</spanx>, such as &quot;manager&quot; and &quot;staff&quot; that publishes events with updates to &quot;customers&quot;. The topics being published to could be structured like
</t>

<figure align="left"><artwork align="left">
    com.example.myapp.customer.&lt;customer ID&gt;
</artwork></figure>
<t>The application might want to restrict the receivers of customer updates depending on the <spanx style="verb">authrole</spanx> of the user. E.g. a user authenticated under <spanx style="verb">authrole</spanx> &quot;manager&quot; might be allowed to receive any kind of customer update, including personal and business sensitive information. A user under <spanx style="verb">authrole</spanx> &quot;staff&quot; might only be allowed to receive a subset of events.
</t>
<t>The application can publish <spanx style="strong">all</spanx> customer updates to the <spanx style="strong">same</spanx> topic <spanx style="verb">com.example.myapp.customer.&lt;customer ID&gt;</spanx> and use <spanx style="verb">PUBLISH.Options.eligible_authrole|list[string]</spanx> to safely restrict the set of actual receivers as desired.
</t>
</section>
</section>

<section anchor="feature-definition-10" title="Feature Definition">
<t>A <spanx style="emph">Publisher</spanx> may restrict the actual receivers of an event from the set of <spanx style="emph">Subscribers</spanx> through the use of
</t>
<t>
<list style="symbols">
<t>Blacklisting Options
<list style="symbols">
<t><spanx style="verb">PUBLISH.Options.exclude|list[int]</spanx></t>
<t><spanx style="verb">PUBLISH.Options.exclude_authid|list[string]</spanx></t>
<t><spanx style="verb">PUBLISH.Options.exclude_authrole|list[string]</spanx></t>
</list></t>
<t>Whitelisting Options
<list style="symbols">
<t><spanx style="verb">PUBLISH.Options.eligible|list[int]</spanx></t>
<t><spanx style="verb">PUBLISH.Options.eligible_authid|list[string]</spanx></t>
<t><spanx style="verb">PUBLISH.Options.eligible_authrole|list[string]</spanx></t>
</list></t>
</list>
</t>
<t><spanx style="verb">PUBLISH.Options.exclude</spanx> is a list of integers with WAMP <spanx style="verb">sessionids</spanx> providing an explicit list of (potential) <spanx style="emph">Subscribers</spanx> that won't receive a published event, even though they may be subscribed. In other words, <spanx style="verb">PUBLISH.Options.exclude</spanx> is a <spanx style="strong">blacklist</spanx> of (potential) <spanx style="emph">Subscribers</spanx>.
</t>
<t><spanx style="verb">PUBLISH.Options.eligible</spanx> is a list of integeres with WAMP WAMP <spanx style="verb">sessionids</spanx> providing an explicit list of (potential) <spanx style="emph">Subscribers</spanx> that are allowed to receive a published event. In other words, <spanx style="verb">PUBLISH.Options.eligible</spanx> is a <spanx style="strong">whitelist</spanx> of (potential) <spanx style="emph">Subscribers</spanx>.
</t>
<t>The <spanx style="verb">exclude_authid</spanx>, <spanx style="verb">exclude_authrole</spanx>, <spanx style="verb">eligible_authid</spanx> and <spanx style="verb">eligible_authrole</spanx> options work similar, but not on the basis of WAMP <spanx style="verb">sessionid</spanx>, but <spanx style="verb">authid</spanx> and <spanx style="verb">authrole</spanx>.
</t>
<t>An (authorized) <spanx style="emph">Subscriber</spanx> to topic T will receive an event published to T if and only if all of the following statements hold true:
</t>
<t>
<list style="numbers">
<t>if there is an <spanx style="verb">eligible</spanx> attribute present, the <spanx style="emph">Subscriber</spanx>'s <spanx style="verb">sessionid</spanx> is in this list</t>
<t>if there is an <spanx style="verb">eligible_authid</spanx> attribute present, the <spanx style="emph">Subscriber</spanx>'s <spanx style="verb">authid</spanx> is in this list</t>
<t>if there is an <spanx style="verb">eligible_authrole</spanx> attribute present, the <spanx style="emph">Subscriber</spanx>'s <spanx style="verb">authrole</spanx> is in this list</t>
<t>if there is an <spanx style="verb">exclude attribute</spanx> present, the <spanx style="emph">Subscriber</spanx>'s <spanx style="verb">sessionid</spanx> is NOT in this list</t>
<t>if there is an <spanx style="verb">exclude_authid</spanx> attribute present, the <spanx style="emph">Subscriber</spanx>'s <spanx style="verb">authid</spanx> is NOT in this list</t>
<t>if there is an <spanx style="verb">exclude_authrole</spanx> attribute present, the <spanx style="emph">Subscriber</spanx>'s <spanx style="verb">authrole</spanx> is NOT in this list</t>
</list>
</t>
<t>For example, if both <spanx style="verb">PUBLISH.Options.exclude</spanx> and <spanx style="verb">PUBLISH.Options.eligible</spanx> are present, the <spanx style="emph">Broker</spanx> will dispatch events published only to <spanx style="emph">Subscribers</spanx> that are not explicitly excluded in <spanx style="verb">PUBLISH.Options.exclude</spanx> <spanx style="strong">and</spanx> which are explicitly eligible via <spanx style="verb">PUBLISH.Options.eligible</spanx>.
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [
       16,
       239714735,
       {
          "exclude": [
             7891255,
             1245751
          ]
       },
       "com.myapp.mytopic1",
       [
          "Hello, world!"
       ]
    ]
</artwork></figure>
<t>The above event will get dispatched to all <spanx style="emph">Subscribers</spanx> of <spanx style="verb">com.myapp.mytopic1</spanx>, but not WAMP sessions with IDs <spanx style="verb">7891255</spanx> or <spanx style="verb">1245751</spanx> (and also not the publishing session).
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [
       16,
       239714735,
       {
          "eligible": [
             7891255,
             1245751
          ]
       },
       "com.myapp.mytopic1",
       [
          "Hello, world!"
       ]
    ]
</artwork></figure>
<t>The above event will get dispatched to WAMP sessions with IDs <spanx style="verb">7891255</spanx> or <spanx style="verb">1245751</spanx> only - but only if those are actually subscribed to the topic <spanx style="verb">com.myapp.mytopic1</spanx>.
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [
       16,
       239714735,
       {
          "eligible": [
             7891255,
             1245751,
             9912315
          ],
          "exclude": [
             7891255
          ]
       },
       "com.myapp.mytopic1",
       [
          "Hello, world!"
       ]
    ]
</artwork></figure>
<t>The above event will get dispatched to WAMP sessions with IDs <spanx style="verb">1245751</spanx> or <spanx style="verb">9912315</spanx> only, since <spanx style="verb">7891255</spanx> is excluded - but only if those are actually subscribed to the topic <spanx style="verb">com.myapp.mytopic1</spanx>.
</t>
</section>

<section anchor="feature-announcement-10" title="Feature Announcement">
<t>Support for this feature MUST be announced by <spanx style="emph">Publishers</spanx> (<spanx style="verb">role := "publisher"</spanx>) and <spanx style="emph">Brokers</spanx> (<spanx style="verb">role := "broker"</spanx>) via
</t>

<figure align="left"><artwork align="left">
    HELLO.Details.roles.&lt;role&gt;.features.
        subscriber_blackwhite_listing|bool := true
</artwork></figure>
</section>
</section>

<section anchor="publisher-exclusion" title="Publisher Exclusion">

<section anchor="feature-definition-11" title="Feature Definition">
<t>By default, a <spanx style="emph">Publisher</spanx> of an event will <spanx style="strong">not</spanx> itself receive an event published, even when subscribed to the <spanx style="verb">Topic</spanx> the <spanx style="emph">Publisher</spanx> is publishing to. This behavior can be overridden using this feature.
</t>
<t>To override the exclusion of a publisher from its own publication, the <spanx style="verb">PUBLISH</spanx> message must include the following option:
</t>

<figure align="left"><artwork align="left">
    PUBLISH.Options.exclude_me|bool
</artwork></figure>
<t>When publishing with <spanx style="verb">PUBLISH.Options.exclude_me := false</spanx>, the <spanx style="emph">Publisher</spanx> of the event will receive that event, if it is subscribed to the <spanx style="verb">Topic</spanx> published to.
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [
        16,
        239714735,
        {
            "exclude_me": false
        },
        "com.myapp.mytopic1",
        ["Hello, world!"]
    ]
</artwork></figure>
<t>In this example, the <spanx style="emph">Publisher</spanx> will receive the published event, if it is subscribed to <spanx style="verb">com.myapp.mytopic1</spanx>.
</t>
</section>

<section anchor="feature-announcement-11" title="Feature Announcement">
<t>Support for this feature MUST be announced by <spanx style="emph">Publishers</spanx> (<spanx style="verb">role := "publisher"</spanx>) and <spanx style="emph">Brokers</spanx> (<spanx style="verb">role := "broker"</spanx>) via
</t>

<figure align="left"><artwork align="left">
    HELLO.Details.roles.&lt;role&gt;.features.
        publisher_exclusion|bool := true
</artwork></figure>
</section>
</section>

<section anchor="publisher-identification" title="Publisher Identification">

<section anchor="feature-definition-12" title="Feature Definition">
<t>A <spanx style="emph">Publisher</spanx> may request the disclosure of its identity (its WAMP session ID) to receivers of a published event by setting
</t>

<figure align="left"><artwork align="left">
    PUBLISH.Options.disclose_me|bool := true
</artwork></figure>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [16, 239714735, {"disclose_me": true}, "com.myapp.mytopic1",
        ["Hello, world!"]]
</artwork></figure>
<t>If above event is published by a <spanx style="emph">Publisher</spanx> with WAMP session ID <spanx style="verb">3335656</spanx>, the <spanx style="emph">Broker</spanx> would send an <spanx style="verb">EVENT</spanx> message to <spanx style="emph">Subscribers</spanx> with the <spanx style="emph">Publisher's</spanx> WAMP session ID in <spanx style="verb">EVENT.Details.publisher</spanx>:
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [36, 5512315355, 4429313566, {"publisher": 3335656},
        ["Hello, world!"]]
</artwork></figure>
<t>Note that a <spanx style="emph">Broker</spanx> may deny a <spanx style="emph">Publisher's</spanx> request to disclose its identity:
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [8, 239714735, {}, "wamp.error.option_disallowed.disclose_me"]
</artwork></figure>
<t>A <spanx style="emph">Broker</spanx> may also (automatically) disclose the identity of a <spanx style="emph">Publisher</spanx> even without the <spanx style="emph">Publisher</spanx> having explicitly requested to do so when the <spanx style="emph">Broker</spanx> configuration (for the publication topic) is set up to do so.
</t>
</section>

<section anchor="feature-announcement-12" title="Feature Announcement">
<t>Support for this feature MUST be announced by <spanx style="emph">Publishers</spanx> (<spanx style="verb">role := "publisher"</spanx>), <spanx style="emph">Brokers</spanx> (<spanx style="verb">role := "broker"</spanx>) and <spanx style="emph">Subscribers</spanx> (<spanx style="verb">role := "subscriber"</spanx>) via
</t>

<figure align="left"><artwork align="left">
    HELLO.Details.roles.&lt;role&gt;.features.
        publisher_identification|bool := true
</artwork></figure>
</section>
</section>

<section anchor="publication-trust-levels" title="Publication Trust Levels">

<section anchor="feature-definition-13" title="Feature Definition">
<t>A <spanx style="emph">Broker</spanx> may be configured to automatically assign <spanx style="emph">trust levels</spanx> to events published by <spanx style="emph">Publishers</spanx> according to the <spanx style="emph">Broker</spanx> configuration on a per-topic basis and/or depending on the application defined role of the (authenticated) <spanx style="emph">Publisher</spanx>.
</t>
<t>A <spanx style="emph">Broker</spanx> supporting trust level will provide
</t>

<figure align="left"><artwork align="left">
    EVENT.Details.trustlevel|integer
</artwork></figure>
<t>in an <spanx style="verb">EVENT</spanx> message sent to a <spanx style="emph">Subscriber</spanx>. The trustlevel <spanx style="verb">0</spanx> means lowest trust, and higher integers represent (application-defined) higher levels of trust.
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [36, 5512315355, 4429313566, {"trustlevel": 2}, 
        ["Hello, world!"]]
</artwork></figure>
<t>In above event, the <spanx style="emph">Broker</spanx> has (by configuration and/or other information) deemed the event publication to be of trustlevel <spanx style="verb">2</spanx>.
</t>
</section>

<section anchor="feature-announcement-13" title="Feature Announcement">
<t>Support for this feature MUST be announced by <spanx style="emph">Subscribers</spanx> (<spanx style="verb">role := "subscriber"</spanx>) and <spanx style="emph">Brokers</spanx> (<spanx style="verb">role := "broker"</spanx>) via
</t>

<figure align="left"><artwork align="left">
    HELLO.Details.roles.&lt;role&gt;.features.
        publication_trustlevels|bool := true
</artwork></figure>
</section>
</section>

<section anchor="subscription-meta-api" title="Subscription Meta API">
<t>Within an application, it may be desirable for a publisher to know whether a publication to a specific topic currently makes sense, i.e. whether there are any subscribers who would receive an event based on the publication. It may also be desirable to keep a current count of subscribers to a topic to then be able to filter out any subscribers who are not supposed to receive an event.
</t>
<t>Subscription <spanx style="emph">meta-events</spanx> are fired when topics are first created, when clients subscribe/unsubscribe to them, and when topics are deleted. WAMP allows retrieving information about subscriptions via subscription <spanx style="emph">meta-procedures</spanx>.
</t>
<t>Support for this feature MUST be announced by Brokers via
</t>

<figure align="left"><artwork align="left">
    HELLO.Details.roles.broker.features.subscription_meta_api|
        bool := true
</artwork></figure>
<t>Meta-events are created by the router itself. This means that the events as well as the data received when calling a meta-procedure can be accorded the same trust level as the router.
</t>

<section anchor="subscription-metaevents" title="Subscription Meta-Events">
<t>A client can subscribe to the following session meta-events, which cover the lifecycle of a subscription:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">wamp.subscription.on_create</spanx>: Fired when a subscription is created through a subscription request for a topic which was previously without subscribers.</t>
<t><spanx style="verb">wamp.subscription.on_subscribe</spanx>: Fired when a session is added to a subscription.</t>
<t><spanx style="verb">wamp.subscription.on_unsubscribe</spanx>: Fired when a session is removed from a subscription.</t>
<t><spanx style="verb">wamp.subscription.on_delete</spanx>: Fired when a subscription is deleted after the last session attached to it has been removed.</t>
</list>
</t>
<t>A <spanx style="verb">wamp.subscription.on_subscribe</spanx> event MUST always be fired subsequent to a <spanx style="verb">wamp.subscription.on_create</spanx> event, since the first subscribe results in both the creation of the subscription and the addition of a session. Similarly, the <spanx style="verb">wamp.subscription.on_delete</spanx> event MUST always be preceded by a <spanx style="verb">wamp.subscription.on_unsubscribe</spanx> event.
</t>
<t>The WAMP subscription meta events shall be dispatched by the router to the same realm as the WAMP session which triggered the event.
</t>

<section anchor="metaevent-specifications" title="Meta-Event Specifications">

<section anchor="wampsubscriptiononcreate" title="wamp.subscription.on_create">
<t>Fired when a subscription is created through a subscription request for a topic which was previously without subscribers. The event payload consists of positional arguments:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">session|id</spanx>: ID of the session performing the subscription request.</t>
<t><spanx style="verb">SubscriptionDetails|dict</spanx>: Information on the created subscription.</t>
</list>
</t>
<t><spanx style="strong">Object Schemas</spanx>
</t>

<figure align="left"><artwork align="left">
      SubscriptionDetails :=
      {
          "id": subscription|id,
          "created": time_created|iso_8601_string,
          "uri": topic|uri,
          "match": match_policy|string
      }
</artwork></figure>
<t>See <xref target="pattern-based-subscriptions"/> for a description of <spanx style="verb">match_policy</spanx>.
</t>
</section>

<section anchor="wampsubscriptiononsubscribe" title="wamp.subscription.on_subscribe">
<t>Fired when a session is added to a subscription.  The event payload consists of positional arguments:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">session|id</spanx>: ID of the session being added to a subscription.</t>
<t><spanx style="verb">subscription|id</spanx>: ID of the subscription to which the session is being added.</t>
</list>
</t>
</section>

<section anchor="wampsubscriptiononunsubscribe" title="wamp.subscription.on_unsubscribe">
<t>Fired when a session is removed from a subscription. The event payload consists of positional arguments:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">session|id</spanx>: ID of the session being removed from a subscription.</t>
<t><spanx style="verb">subscription|id</spanx>: ID of the subscription from which the session is being removed.</t>
</list>
</t>
</section>

<section anchor="wampsubscriptionondelete" title="wamp.subscription.on_delete">
<t>Fired when a subscription is deleted after the last session attached to it has been removed. The event payload consists of positional arguments:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">session|id</spanx>: ID of the last session being removed from a subscription.</t>
<t><spanx style="verb">subscription|id</spanx>: ID of the subscription being deleted.</t>
</list>
</t>
</section>
</section>
</section>

<section anchor="subscription-metaprocedures" title="Subscription Meta-Procedures">
<t>A client can actively retrieve information about subscriptions via the following meta-procedures:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">wamp.subscription.list</spanx>: Retrieves subscription IDs listed according to match policies.</t>
<t><spanx style="verb">wamp.subscription.lookup</spanx>: Obtains the subscription (if any) managing a topic, according to some match policy.</t>
<t><spanx style="verb">wamp.subscription.match</spanx>: Retrieves a list of IDs of subscriptions matching a topic URI, irrespective of match policy.</t>
<t><spanx style="verb">wamp.subscription.get</spanx>: Retrieves information on a particular subscription.</t>
<t><spanx style="verb">wamp.subscription.list_subscribers</spanx>: Retrieves a list of session IDs for sessions currently attached to the subscription.</t>
<t><spanx style="verb">wamp.subscription.count_subscribers</spanx>: Obtains the number of sessions currently attached to the subscription.</t>
</list>
</t>

<section anchor="metaprocedure-specifications" title="Meta-Procedure Specifications">

<section anchor="wampsubscriptionlist" title="wamp.subscription.list">
<t>Retrieves subscription IDs listed according to match policies.
</t>
<t><spanx style="strong">Arguments</spanx>
</t>
<t>
<list style="symbols">
<t>None</t>
</list>
</t>
<t><spanx style="strong">Results</spanx>
</t>
<t>The result consists of one positional argument:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">SubscriptionLists|dict</spanx>: A dictionary with a list of subscription IDs for each match policy.</t>
</list>
</t>
<t><spanx style="strong">Object Schemas</spanx>
</t>

<figure align="left"><artwork align="left">
      SubscriptionLists :=
      {
          "exact": subscription_ids|list,
          "prefix": subscription_ids|list,
          "wildcard": subscription_ids|list
      }
</artwork></figure>
<t>See <xref target="pattern-based-subscriptions"/> for information on match policies.
</t>
</section>

<section anchor="wampsubscriptionlookup" title="wamp.subscription.lookup">
<t>Obtains the subscription (if any) managing a topic, according to some match policy.
</t>
<t><spanx style="strong">Arguments</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">topic|uri</spanx>: The URI of the topic.</t>
<t>(Optional) <spanx style="verb">options|dict</spanx>: Same options as when subscribing to a topic.</t>
</list>
</t>
<t><spanx style="strong">Results</spanx>
</t>
<t>The result consists of one positional argument:
</t>
<t>
<list style="symbols">
<t>(Nullable) <spanx style="verb">subscription|id</spanx>: The ID of the subscription managing the topic, if found, or null.</t>
</list>
</t>
</section>

<section anchor="wampsubscriptionmatch" title="wamp.subscription.match">
<t>Retrieves a list of IDs of subscriptions matching a topic URI, irrespective of match policy.
</t>
<t><spanx style="strong">Arguments</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">topic|uri</spanx>: The topic to match.</t>
</list>
</t>
<t><spanx style="strong">Results</spanx>
</t>
<t>The result consists of positional arguments:
</t>
<t>
<list style="symbols">
<t>(Nullable) <spanx style="verb">subscription_ids|list</spanx>: A list of all matching subscription IDs, or null.</t>
</list>
</t>
</section>

<section anchor="wampsubscriptionget" title="wamp.subscription.get">
<t>Retrieves information on a particular subscription.
</t>
<t><spanx style="strong">Arguments</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">subscription|id</spanx>: The ID of the subscription to retrieve.</t>
</list>
</t>
<t><spanx style="strong">Results</spanx>
</t>
<t>The result consists of one positional argument:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">SubscriptionDetails|dict</spanx>: Details on the subscription.</t>
</list>
</t>
<t><spanx style="strong">Error URIs</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">wamp.error.no_such_subscription</spanx>: No subscription with the given ID exists on the router.</t>
</list>
</t>
<t><spanx style="strong">Object Schemas</spanx>
</t>

<figure align="left"><artwork align="left">
      SubscriptionDetails :=
      {
          "id": subscription|id,
          "created": time_created|iso_8601_string,
          "uri": topic|uri,
          "match": match_policy|string
      }
</artwork></figure>
<t>See <xref target="pattern-based-subscriptions"/> for information on match policies.
</t>
</section>

<section anchor="wampsubscriptionlistsubscribers" title="wamp.subscription.list_subscribers">
<t>Retrieves a list of session IDs for sessions currently attached to the subscription.
</t>
<t><spanx style="strong">Arguments</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">subscription|id</spanx>: The ID of the subscription to get subscribers for.</t>
</list>
</t>
<t><spanx style="strong">Results</spanx>
</t>
<t>The result consists of positional arguments:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">subscribers_ids|list</spanx>: A list of WAMP session IDs of subscribers currently attached to the subscription.</t>
</list>
</t>
<t><spanx style="strong">Error URIs</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">wamp.error.no_such_subscription</spanx>: No subscription with the given ID exists on the router.</t>
</list>
</t>
</section>

<section anchor="wampsubscriptioncountsubscribers" title="wamp.subscription.count_subscribers">
<t>Obtains the number of sessions currently attached to a subscription.
</t>
<t><spanx style="strong">Arguments</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">subscription|id</spanx>: The ID of the subscription to get the number of subscribers for.</t>
</list>
</t>
<t><spanx style="strong">Results</spanx>
</t>
<t>The result consists of one positional argument:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">count|int</spanx>: The number of sessions currently attached to a subscription.</t>
</list>
</t>
<t><spanx style="strong">Error URIs</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">wamp.error.no_such_subscription</spanx>: No subscription with the given ID exists on the router.</t>
</list>
</t>
</section>
</section>
</section>
</section>

<section anchor="pattern-based-subscriptions" title="Pattern-based Subscriptions">

<section anchor="introdution" title="Introdution">
<t>By default, <spanx style="emph">Subscribers</spanx> subscribe to topics with <spanx style="strong">exact matching policy</spanx>. That is an event will only be dispatched to a <spanx style="emph">Subscriber</spanx> by the <spanx style="emph">Broker</spanx> if the topic published to (<spanx style="verb">PUBLISH.Topic</spanx>) <spanx style="emph">exactly</spanx> matches the topic subscribed to (<spanx style="verb">SUBSCRIBE.Topic</spanx>).
</t>
<t>A <spanx style="emph">Subscriber</spanx> might want to subscribe to topics based on a <spanx style="emph">pattern</spanx>. This can be useful to reduce the number of individual subscriptions to be set up and to subscribe to topics the <spanx style="emph">Subscriber</spanx> is not aware of at the time of subscription, or which do not yet exist at this time.
</t>
<t>If the <spanx style="emph">Broker</spanx> and the <spanx style="emph">Subscriber</spanx> support <spanx style="strong">pattern-based subscriptions</spanx>, this matching can happen by
</t>
<t>
<list style="symbols">
<t>prefix-matching policy</t>
<t>wildcard-matching policy</t>
</list>
</t>
</section>

<section anchor="prefix-matching-1" title="Prefix Matching">
<t>A <spanx style="emph">Subscriber</spanx> requests <spanx style="strong">prefix-matching policy</spanx> with a subscription request by setting
</t>

<figure align="left"><artwork align="left">
    SUBSCRIBE.Options.match|string := "prefix"
</artwork></figure>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [
        32,
        912873614,
        {
            "match": "prefix"
        },
        "com.myapp.topic.emergency"
    ]
</artwork></figure>
<t>When a <spanx style="strong">prefix-matching policy</spanx> is in place, any event with a topic that has <spanx style="verb">SUBSCRIBE.Topic</spanx> as a <spanx style="emph">prefix</spanx> will match the subscription, and potentially be delivered to <spanx style="emph">Subscribers</spanx> on the subscription.
</t>
<t>In the above example, events with <spanx style="verb">PUBLISH.Topic</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">com.myapp.topic.emergency.11</spanx></t>
<t><spanx style="verb">com.myapp.topic.emergency-low</spanx></t>
<t><spanx style="verb">com.myapp.topic.emergency.category.severe</spanx></t>
<t><spanx style="verb">com.myapp.topic.emergency</spanx></t>
</list>
</t>
<t>will all apply for dispatching. An event with <spanx style="verb">PUBLISH.Topic</spanx> e.g. <spanx style="verb">com.myapp.topic.emerge</spanx> will not apply.
</t>
</section>

<section anchor="wildcard-matching-1" title="Wildcard Matching">
<t>A <spanx style="emph">Subscriber</spanx> requests <spanx style="strong">wildcard-matching policy</spanx> with a subscription request by setting
</t>

<figure align="left"><artwork align="left">
    SUBSCRIBE.Options.match|string := "wildcard"
</artwork></figure>
<t>Wildcard-matching allows to provide wildcards for <spanx style="strong">whole</spanx> URI components.
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [
        32,
        912873614,
        {
            "match": "wildcard"
        },
        "com.myapp..userevent"
    ]
</artwork></figure>
<t>In above subscription request, the 3rd URI component is empty, which signals a wildcard in that URI component position. In this example, events with <spanx style="verb">PUBLISH.Topic</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">com.myapp.foo.userevent</spanx></t>
<t><spanx style="verb">com.myapp.bar.userevent</spanx></t>
<t><spanx style="verb">com.myapp.a12.userevent</spanx></t>
</list>
</t>
<t>will all apply for dispatching. Events with <spanx style="verb">PUBLISH.Topic</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">com.myapp.foo.userevent.bar</spanx></t>
<t><spanx style="verb">com.myapp.foo.user</spanx></t>
<t><spanx style="verb">com.myapp2.foo.userevent</spanx></t>
</list>
</t>
<t>will not apply for dispatching.
</t>
</section>

<section anchor="general-1" title="General">

<section anchor="no-set-semantics-1" title="No set semantics">
<t>Since each <spanx style="emph">Subscriber's</spanx> subscription &quot;stands on its own&quot;, there is no <spanx style="emph">set semantics</spanx> implied by pattern-based subscriptions.
</t>
<t>E.g. a <spanx style="emph">Subscriber</spanx> cannot subscribe to a broad pattern, and then unsubscribe from a subset of that broad pattern to form a more complex subscription. Each subscription is separate.
</t>
</section>

<section anchor="events-matching-multiple-subscriptions" title="Events matching multiple subscriptions">
<t>When a single event matches more than one of a <spanx style="emph">Subscriber's</spanx> subscriptions, the event will be delivered for each subscription.
</t>
<t>The <spanx style="emph">Subscriber</spanx> can detect the delivery of that same event on multiple subscriptions via <spanx style="verb">EVENT.PUBLISHED.Publication</spanx>, which will be identical.
</t>
</section>

<section anchor="concrete-topic-published-to" title="Concrete topic published to">
<t>If a subscription was established with a pattern-based matching policy, a <spanx style="emph">Broker</spanx> MUST supply the original <spanx style="verb">PUBLISH.Topic</spanx> as provided by the <spanx style="emph">Publisher</spanx> in
</t>

<figure align="left"><artwork align="left">
    EVENT.Details.topic|uri
</artwork></figure>
<t>to the <spanx style="emph">Subscribers</spanx>.
</t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [
        36,
        5512315355,
        4429313566,
        {
            "topic": "com.myapp.topic.emergency.category.severe"
        },
        ["Hello, world!"]
    ]
</artwork></figure>
</section>
</section>

<section anchor="feature-announcement-14" title="Feature Announcement">
<t>Support for this feature MUST be announced by <spanx style="emph">Subscribers</spanx> (<spanx style="verb">role := "subscriber"</spanx>) and <spanx style="emph">Brokers</spanx> (<spanx style="verb">role := "broker"</spanx>) via
</t>

<figure align="left"><artwork align="left">
    HELLO.Details.roles.&lt;role&gt;.features.
        pattern_based_subscription|bool := true
</artwork></figure>
</section>
</section>

<section anchor="sharded-subscriptions" title="Sharded Subscriptions">
<t>Feature status: <spanx style="strong">alpha</spanx>
</t>
<t>Support for this feature MUST be announced by <spanx style="emph">Publishers</spanx> (<spanx style="verb">role := "publisher"</spanx>), <spanx style="emph">Subscribers</spanx> (<spanx style="verb">role := "subscriber"</spanx>) and <spanx style="emph">Brokers</spanx> (<spanx style="verb">role := "broker"</spanx>) via
</t>

<figure align="left"><artwork align="left">
    HELLO.Details.roles.&lt;role&gt;.features.shareded_subscriptions|
        bool := true
</artwork></figure>
<t>Resource keys: <spanx style="verb">PUBLISH.Options.rkey|string</spanx> is a stable, technical <spanx style="strong">resource key</spanx>.
</t>
<t><list style="empty">
<t>E.g. if your sensor has a unique serial identifier, you can use that.
</t>
</list></t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [16, 239714735, {"rkey": "sn239019"}, "com.myapp.sensor.sn239019. 
        temperature", [33.9]]
</artwork></figure>
<t>Node keys: <spanx style="verb">SUBSCRIBE.Options.nkey|string</spanx> is a stable, technical <spanx style="strong">node key</spanx>.
</t>
<t><list style="empty">
<t>E.g. if your backend process runs on a dedicated host, you can use its hostname.
</t>
</list></t>
<t><spanx style="emph">Example</spanx>
</t>

<figure align="left"><artwork align="left">
    [32, 912873614, {"match": "wildcard", "nkey": "node23"}, 
        "com.myapp.sensor..temperature"]
</artwork></figure>
</section>

<section anchor="event-history" title="Event History">

<section anchor="feature-definition-14" title="Feature Definition">
<t>Instead of complex QoS for message delivery, a <spanx style="emph">Broker</spanx> may provide <spanx style="emph">message history</spanx>. A <spanx style="emph">Subscriber</spanx> is responsible to handle overlaps (duplicates) when it wants &quot;exactly-once&quot; message processing across restarts.
</t>
<t>The <spanx style="emph">Broker</spanx> may allow for configuration on a per-topic basis.
</t>
<t>The event history may be transient or persistent message history (surviving <spanx style="emph">Broker</spanx> restarts).
</t>
<t>A <spanx style="emph">Broker</spanx> that implements <spanx style="emph">event history</spanx> must (also) announce role <spanx style="verb">HELLO.roles.callee</spanx>, indicate <spanx style="verb">HELLO.roles.broker.history == 1</spanx> and provide the following (builtin) procedures.
</t>
<t>A <spanx style="emph">Caller</spanx> can request message history by calling the <spanx style="emph">Broker</spanx> procedure
</t>

<figure align="left"><artwork align="left">
    wamp.topic.history.last
</artwork></figure>
<t>with <spanx style="verb">Arguments = [topic|uri, limit|integer]</spanx> where
</t>
<t>
<list style="symbols">
<t><spanx style="verb">topic</spanx> is the topic to retrieve event history for</t>
<t><spanx style="verb">limit</spanx> indicates the number of last N events to retrieve</t>
</list>
</t>
<t>or by calling
</t>

<figure align="left"><artwork align="left">
    wamp.topic.history.since
</artwork></figure>
<t>with <spanx style="verb">Arguments = [topic|uri, timestamp|string]</spanx> where
</t>
<t>
<list style="symbols">
<t><spanx style="verb">topic</spanx> is the topic to retrieve event history for</t>
<t><spanx style="verb">timestamp</spanx> indicates the UTC timestamp since when to retrieve the events in the ISO-8601 format <spanx style="verb">yyyy-MM-ddThh:mm:ss:SSSZ</spanx> (e.g. <spanx style="verb">"2013-12-21T13:43:11:000Z"</spanx>)</t>
</list>
</t>
<t>or by calling
</t>

<figure align="left"><artwork align="left">
    wamp.topic.history.after
</artwork></figure>
<t>with <spanx style="verb">Arguments = [topic|uri, publication|id]</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">topic</spanx> is the topic to retrieve event history for</t>
<t><spanx style="verb">publication</spanx> is the id of an event which marks the start of the events to retrieve from history</t>
</list>
</t>
<t><spanx style="emph">FIXME</spanx>
</t>
<t>
<list style="numbers">
<t>Should we use <spanx style="verb">topic|uri</spanx> or <spanx style="verb">subscription|id</spanx> in <spanx style="verb">Arguments</spanx>?
<list style="symbols">
<t>Since we need to be able to get history for pattern-based subscriptions as well, a subscription|id makes more sense: create pattern-based subscription, then get the event history for this.</t>
<t>The only restriction then is that we may not get event history without a current subscription covering the events. This is a minor inconvenience at worst.</t>
</list></t>
<t>Can <spanx style="verb">wamp.topic.history.after</spanx> be implemented (efficiently) at all?</t>
<t>How does that interact with pattern-based subscriptions?</t>
<t>The same question as with the subscriber lists applies where: to stay within our separation of roles, we need a broker + a separate peer which implements the callee role. Here we do not have a mechanism to get the history from the broker.</t>
<t>How are black/whitelisted sessionIDs treated? A client which requests event history will have a different sessionID than on previous connections, and may receive events for which it was excluded in the previous session, or not receive events for which it was whitelisted. - see <eref target="https://github.com/wamp-proto/wamp-proto/issues/206"/></t>
</list>
</t>
</section>

<section anchor="feature-announcement-15" title="Feature Announcement">
<t>Support for this feature MUST be announced by <spanx style="emph">Subscribers</spanx> (<spanx style="verb">role := "subscriber"</spanx>) and <spanx style="emph">Brokers</spanx> (<spanx style="verb">role := "broker"</spanx>) via
</t>

<figure align="left"><artwork align="left">
    HELLO.Details.roles.&lt;role&gt;.features.event_history|bool := true
</artwork></figure>
</section>
</section>

<section anchor="registration-revocation-1" title="Registration Revocation">

<section anchor="feature-definition-15" title="Feature Definition">
<t>Actively and forcefully revoke a previously granted subscription from a session.
</t>
</section>

<section anchor="feature-announcement-16" title="Feature Announcement">
</section>
</section>

<section anchor="topic-reflection" title="Topic Reflection">
<t>
<list style="symbols">
<t>see <spanx style="strong">Procedure Reflection</spanx> for now</t>
</list>
</t>
</section>

<section anchor="testament" title="Testament">

<section anchor="feature-definition-16" title="Feature Definition">
<t>When a WAMP client disconnects, or the WAMP session is destroyed, it may want to notify other subscribers or publish some fixed data.
Since a client may disconnect uncleanly, this can't be done reliably by them.
A <spanx style="emph">Testament</spanx>, however, set on the server, can be reliably sent by the <spanx style="emph">Broker</spanx> once either the WAMP session has detached or the client connection has been lost, and allows this functionality.
It can be triggered when a Session is either detached (the client has disconnected from it, or frozen it, in the case of Session Resumption) or destroyed (when the WAMP session no longer exists on the server).
</t>
<t>This allows clients that otherwise would not be able to know when other clients disconnect get a notification (for example, by using the WAMP Session Meta API) with a format the disconnected client chose.
</t>
</section>

<section anchor="testament-meta-procedures" title="Testament Meta Procedures">
<t>A <spanx style="emph">Client</spanx> can call the following procedures to set/flush Testaments:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">wamp.session.add_testament</spanx> to add a Testament which will be published on a particular topic when the Session is detatched or destroyed.</t>
<t><spanx style="verb">wamp.session.flush_testaments</spanx> to remove the Testaments for that Session, either for when it is detatched or destroyed.</t>
</list>
</t>

<section anchor="wampsessionaddtestament" title="wamp.session.add_testament">
<t>Adds a new testament:
</t>
<t><spanx style="strong">Positional arguments</spanx>
</t>
<t>
<list style="numbers">
<t><spanx style="verb">topic|uri</spanx> - the topic to publish the event on</t>
<t><spanx style="verb">args|list</spanx> - positional arguments for the event</t>
<t><spanx style="verb">kwargs|dict</spanx> - keyword arguments for the event</t>
</list>
</t>
<t><spanx style="strong">Keyword arguments</spanx>
</t>
<t>
<list style="numbers">
<t><spanx style="verb">publish_options|dict</spanx> - options for the event when it is published -- see <spanx style="verb">Publish.Options</spanx>. Not all options may be honoured (for example, <spanx style="verb">acknowledge</spanx>). By default, there are no options.</t>
<t><spanx style="verb">scope|string</spanx> - When the testament should be published. Valid values are <spanx style="verb">detatched</spanx> (when the WAMP session is detatched, for example, when using Event Retention) or <spanx style="verb">destroyed</spanx> (when the WAMP session is finalised and destroyed on the Broker). Default MUST be <spanx style="verb">destroyed</spanx>.</t>
</list>
</t>
<t><spanx style="verb">wamp.session.add_testament</spanx> does not return a value.
</t>
</section>

<section anchor="wampsessionflushtestaments" title="wamp.session.flush_testaments">
<t>Removes testaments for the given scope:
</t>
<t><spanx style="strong">Keyword arguments</spanx>
</t>
<t>
<list style="numbers">
<t><spanx style="verb">scope|string</spanx> - Which set of testaments to be removed. Valid values are the same as <spanx style="verb">wamp.session.add_testament</spanx>, and the default MUST be <spanx style="verb">destroyed</spanx>.</t>
</list>
</t>
<t><spanx style="verb">wamp.session.flush_testaments</spanx> does not return a value.
</t>
</section>
</section>

<section anchor="testaments-in-use" title="Testaments in Use">
<t>A <spanx style="emph">Client</spanx> that wishes to send some form of data when their <spanx style="emph">Session</spanx> ends unexpectedly or their <spanx style="emph">Transport</spanx> becomes lost can set a testament using the WAMP Testament Meta API, when a <spanx style="emph">Router</spanx> supports it.
For example, a client may call <spanx style="verb">add_testament</spanx> (this example uses the implicit <spanx style="verb">scope</spanx> option of <spanx style="verb">destroyed</spanx>):
</t>

<figure align="center"><artwork align="center">
yield self.call('wamp.session.add_testament',
                'com.myapp.mytopic', ['Seeya!'], {'my_name': 'app1'})
</artwork></figure>
<t>The <spanx style="emph">Router</spanx> will then store this information on the WAMP Session, either in a <spanx style="verb">detatched</spanx> or <spanx style="verb">destroyed</spanx> bucket, in the order they were added.
A client MUST be able to set multiple testaments per-scope.
If the <spanx style="emph">Router</spanx> does not support Session Resumption (therefore removing the distinction between a detached and destroyed session), it MUST still use these two separate buckets to allow <spanx style="verb">wamp.session.flush_testaments</spanx> to work.
</t>
<t>When a <spanx style="emph">Session</spanx> is <spanx style="emph">detatched</spanx>, the <spanx style="emph">Router</spanx> will inspect it for any Testaments in the <spanx style="verb">detached</spanx> scope, and publish them in the order that the Router recieved them, on the specified topic, with the specified arguments, keyword arguments, and publish options.
The <spanx style="emph">Router</spanx> MAY ignore publish options that do not make sense for a Testament (for example, acknowledged publishes).
</t>
<t>When a <spanx style="emph">Session</spanx> is going to be <spanx style="emph">destroyed</spanx>, the <spanx style="emph">Router</spanx> will inspect it for any Testaments in the <spanx style="verb">destroyed</spanx> scope, and publish them in the same way as it would for the <spanx style="verb">detached</spanx> scope, in the order that they were recieved.
</t>
<t>A <spanx style="emph">Router</spanx> that does not allow Session Resumption MUST send <spanx style="verb">detatched</spanx>-scope Testaments before <spanx style="verb">destroyed</spanx>-scope Testaments.
</t>
<t>A <spanx style="emph">Client</spanx> can also clear testaments if the information is no longer relevant (for example, it is shutting down completely cleanly).
For example, a client may call <spanx style="verb">wamp.session.flush_testaments</spanx>:
</t>

<figure align="center"><artwork align="center">
yield self.call('wamp.session.flush_testaments', scope='detatched')
yield self.call('wamp.session.flush_testaments', scope='destroyed')
</artwork></figure>
<t>The <spanx style="emph">Router</spanx> will then flush all Testaments stored for the given scope.
</t>
</section>

<section anchor="feature-announcement-17" title="Feature Announcement">
<t>Support for this feature MUST be announced by <spanx style="emph">Dealers</spanx> (<spanx style="verb">role := "dealer"</spanx>) via
</t>

<figure align="left"><artwork align="left">
    HELLO.Details.roles.dealer.features.
        testament_meta_api|bool := true
</artwork></figure>
</section>
</section>
</section>

<section anchor="other-advanced-features-1" title="Other Advanced Features">

<section anchor="session-meta-api" title="Session Meta API">

<section anchor="introduction-4" title="Introduction">
<t>WAMP enables the monitoring of when sessions join a realm on the router or when they leave it via <spanx style="strong">Session Meta Events</spanx>. It also allows retrieving information about currently connected sessions via <spanx style="strong">Session Meta Procedures</spanx>.
</t>
<t>Meta events are created by the router itself. This means that the events, as well as the data received when calling a meta procedure, can be accorded the same trust level as the router.
</t>
<t><list style="empty">
<t>Note that an implementation that only supports a <spanx style="emph">Broker</spanx> or <spanx style="emph">Dealer</spanx> role, not both at the same time, essentially cannot offer the <spanx style="strong">Session Meta API</spanx>, as it requires both roles to support this feature.
</t>
</list></t>
</section>

<section anchor="session-meta-events" title="Session Meta Events">
<t>A client can subscribe to the following session meta-events, which cover the lifecycle of a session:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">wamp.session.on_join</spanx>: Fired when a session joins a realm on the router.</t>
<t><spanx style="verb">wamp.session.on_leave</spanx>: Fired when a session leaves a realm on the router or is disconnected.</t>
</list>
</t>
<t><spanx style="strong">Session Meta Events</spanx> MUST be dispatched by the <spanx style="emph">Router</spanx> to the same realm as the WAMP session which triggered the event.
</t>

<section anchor="wampsessiononjoin" title="wamp.session.on_join">
<t>Fired when a session joins a realm on the router. The event payload consists of a single positional argument <spanx style="verb">details|dict</spanx>:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">session|id</spanx> - The session ID of the session that joined</t>
<t><spanx style="verb">authid|string</spanx> - The authentication ID of the session that joined</t>
<t><spanx style="verb">authrole|string</spanx> - The authentication role of the session that joined</t>
<t><spanx style="verb">authmethod|string</spanx> - The authentication method that was used for authentication the session that joined</t>
<t><spanx style="verb">authprovider|string</spanx>- The provider that performed the authentication of the session that joined</t>
<t><spanx style="verb">transport|dict</spanx> - Optional, implementation defined information about the WAMP transport the joined session is running over.</t>
</list>
</t>
<t><list style="empty">
<t>See <spanx style="strong">Authentication</spanx> for a description of the <spanx style="verb">authid</spanx>, <spanx style="verb">authrole</spanx>, <spanx style="verb">authmethod</spanx> and <spanx style="verb">authprovider</spanx> properties.
</t>
</list></t>
</section>

<section anchor="wampsessiononleave" title="wamp.session.on_leave">
<t>Fired when a session leaves a realm on the router or is disconnected. The event payload consists of a single positional argument <spanx style="verb">session|id</spanx> with the session ID of the session that left.
</t>
</section>
</section>

<section anchor="session-meta-procedures" title="Session Meta Procedures">
<t>A client can actively retrieve information about sessions via the following meta-procedures:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">wamp.session.count</spanx>: Obtains the number of sessions currently attached to the realm.</t>
<t><spanx style="verb">wamp.session.list</spanx>: Retrieves a list of the session IDs for all sessions currently attached to the realm.</t>
<t><spanx style="verb">wamp.session.get</spanx>: Retrieves information on a specific session.</t>
</list>
</t>
<t>Session meta procedures MUST be registered by the <spanx style="emph">Router</spanx> on the same realm as the WAMP session about which information is retrieved.
</t>

<section anchor="wampsessioncount" title="wamp.session.count">
<t>Obtains the number of sessions currently attached to the realm:
</t>
<t><spanx style="strong">Positional arguments</spanx>
</t>
<t>
<list style="numbers">
<t><spanx style="verb">filter_authroles|list[string]</spanx> - Optional filter: if provided, only count sessions with an <spanx style="verb">authrole</spanx> from this list.</t>
</list>
</t>
<t><spanx style="strong">Positional results</spanx>
</t>
<t>
<list style="numbers">
<t><spanx style="verb">count|int</spanx> - The number of sessions currently attached to the realm.</t>
</list>
</t>
</section>

<section anchor="wampsessionlist" title="wamp.session.list">
<t>Retrieves a list of the session IDs for all sessions currently attached to the realm.
</t>
<t><spanx style="strong">Positional arguments</spanx>
</t>
<t>
<list style="numbers">
<t><spanx style="verb">filter_authroles|list[string]</spanx> - Optional filter: if provided, only count sessions with an <spanx style="verb">authrole</spanx> from this list.</t>
</list>
</t>
<t><spanx style="strong">Positional results</spanx>
</t>
<t>
<list style="numbers">
<t><spanx style="verb">session_ids|list</spanx> - List of WAMP session IDs (order undefined).</t>
</list>
</t>
</section>

<section anchor="wampsessionget" title="wamp.session.get">
<t>Retrieves information on a specific session.
</t>
<t><spanx style="strong">Positional arguments</spanx>
</t>
<t>
<list style="numbers">
<t><spanx style="verb">session|id</spanx> - The session ID of the session to retrieve details for.</t>
</list>
</t>
<t><spanx style="strong">Positional results</spanx>
</t>
<t>
<list style="numbers">
<t><spanx style="verb">details|dict</spanx> - Information on a particular session:
<list style="symbols">
<t><spanx style="verb">session|id</spanx> - The session ID of the session that joined</t>
<t><spanx style="verb">authid|string</spanx> - The authentication ID of the session that joined</t>
<t><spanx style="verb">authrole|string</spanx> - The authentication role of the session that joined</t>
<t><spanx style="verb">authmethod|string</spanx> - The authentication method that was used for authentication the session that joined</t>
<t><spanx style="verb">authprovider|string</spanx>- The provider that performed the authentication of the session that joined</t>
<t><spanx style="verb">transport|dict</spanx> - Optional, implementation defined information about the WAMP transport the joined session is running over.</t>
</list></t>
</list>
</t>
<t><list style="empty">
<t>See <spanx style="strong">Authentication</spanx> for a description of the <spanx style="verb">authid</spanx>, <spanx style="verb">authrole</spanx>, <spanx style="verb">authmethod</spanx> and <spanx style="verb">authprovider</spanx> properties.
</t>
</list></t>
<t><spanx style="strong">Errors</spanx>
</t>
<t>
<list style="symbols">
<t><spanx style="verb">wamp.error.no_such_session</spanx> - No session with the given ID exists on the router.</t>
</list>
</t>
</section>
</section>

<section anchor="feature-announcement-18" title="Feature Announcement">
<t>Support for this feature MUST be announced by <spanx style="strong">both</spanx> <spanx style="emph">Dealers</spanx> and <spanx style="emph">Brokers</spanx> via:
</t>

<figure align="left"><artwork align="left">
    HELLO.Details.roles.&lt;role&gt;.features.
        session_meta_api|bool := true
</artwork></figure>
<t><spanx style="strong">Example</spanx>
</t>
<t>Here is a <spanx style="verb">WELCOME</spanx> message from a <spanx style="emph">Router</spanx> with support for both the <spanx style="emph">Broker</spanx> and <spanx style="emph">Dealer</spanx> role, and with support for <spanx style="strong">Session Meta API</spanx>:
</t>

<figure align="left"><artwork align="left">
    [
        2,
        4580268554656113,
        {
            "authid":"OL3AeppwDLXiAAPbqm9IVhnw",
            "authrole": "anonymous",
            "authmethod": "anonymous",
            "roles": {
                "broker": {
                    "features": {
                        "session_meta_api": true
                    }
                },
                "dealer": {
                    "features": {
                        "session_meta_api": true
                    }
                }
            }
        }
    ]
</artwork></figure>
<t><list style="empty">
<t>Note in particular that the feature is announced on both the <spanx style="emph">Broker</spanx> and the <spanx style="emph">Dealer</spanx> roles.
</t>
</list></t>
</section>
</section>

<section anchor="authentication" title="Authentication">
<t>Authentication is a complex area.
</t>
<t>Some applications might want to leverage authentication information coming from the transport underlying WAMP, e.g. HTTP cookies or TLS certificates.
</t>
<t>Some transports might imply trust or implicit authentication by their very nature, e.g. Unix domain sockets with appropriate file system permissions in place.
</t>
<t>Other application might want to perform their own authentication using external mechanisms (completely outside and independent of WAMP).
</t>
<t>Some applications might want to perform their own authentication schemes by using basic WAMP mechanisms, e.g. by using application-defined remote procedure calls.
</t>
<t>And some applications might want to use a transport independent scheme, nevertheless predefined by WAMP.
</t>

<section anchor="wamplevel-authentication" title="WAMP-level Authentication">
<t>The message flow between Clients and Routers for establishing and tearing down sessions MAY involve the following messages which authenticate a session:
</t>
<t>
<list style="numbers">
<t><spanx style="verb">CHALLENGE</spanx></t>
<t><spanx style="verb">AUTHENTICATE</spanx></t>
</list>
</t>

<figure align="left"><artwork align="left">
     ,------.          ,------.
     |Client|          |Router|
     `--+---'          `--+---'
        |      HELLO      |    
        | ----------------&gt;    
        |                 |    
        |    CHALLENGE    |    
        | &lt;----------------    
        |                 |    
        |   AUTHENTICATE  |    
        | ----------------&gt;    
        |                 |    
        | WELCOME or ABORT|    
        | &lt;----------------    
     ,--+---.          ,--+---.
     |Client|          |Router|
     `------'          `------'
</artwork></figure>
<t>Concrete use of <spanx style="verb">CHALLENGE</spanx> and <spanx style="verb">AUTHENTICATE</spanx> messages depends on the specific authentication method.
</t>
<t>See <xref target="wampcra"/> or <xref target="ticketauth"/> for the use in these authentication methods.
</t>
<t>If two-factor authentication is desired, then two subsequent rounds of <spanx style="verb">CHALLENGE</spanx> and <spanx style="verb">RESPONSE</spanx> may be employed.
</t>

<section anchor="challenge-1" title="CHALLENGE">
<t>An authentication MAY be required for the establishment of a session. Such requirement MAY be based on the <spanx style="verb">Realm</spanx> the connection is requested for.
</t>
<t>To request authentication, the Router MUST send a <spanx style="verb">CHALLENGE</spanx> message to the <spanx style="emph">Endpoint</spanx>.
</t>

<figure align="left"><artwork align="left">
    [CHALLENGE, AuthMethod|string, Extra|dict]
</artwork></figure>
</section>

<section anchor="authenticate-1" title="AUTHENTICATE">
<t>In response to a <spanx style="verb">CHALLENGE</spanx> message, the Client MUST send an <spanx style="verb">AUTHENTICATE</spanx> message.
</t>

<figure align="left"><artwork align="left">
    [AUTHENTICATE, Signature|string, Extra|dict]
</artwork></figure>
<t>If the authentication succeeds, the Router MUST send a <spanx style="verb">WELCOME</spanx> message, else it MUST send an <spanx style="verb">ABORT</spanx> message.
</t>
</section>
</section>

<section anchor="transportlevel-authentication" title="Transport-level Authentication">

<section anchor="cookiebased-authentication" title="Cookie-based Authentication">
<t>When running WAMP over WebSocket, the transport provides HTTP client cookies during the WebSocket opening handshake. The cookies can be used to authenticate one peer (the client) against the other (the server). The other authentication direction cannot be supported by cookies.
</t>
<t>This transport-level authentication information may be forward to the WAMP level within <spanx style="verb">HELLO.Details.transport.auth|any</spanx> in the client-to-server direction.
</t>
</section>

<section anchor="tls-certificate-authentication" title="TLS Certificate Authentication">
<t>When running WAMP over a TLS (either secure WebSocket or raw TCP) transport, a peer may authenticate to the other via the TLS certificate mechanism. A server might authenticate to the client, and a client may authenticate to the server (TLS client-certificate based authentication).
</t>
<t>This transport-level authentication information may be forward to the WAMP level within <spanx style="verb">HELLO.Details.transport.auth|any</spanx> in both directions (if available).
</t>
</section>
</section>

<section anchor="wampcra" title="Challenge Response Authentication">
<t>WAMP Challenge-Response (&quot;WAMP-CRA&quot;) authentication is a simple, secure authentication mechanism using a shared secret. The client and the server share a secret. The secret never travels the wire, hence WAMP-CRA can be used via non-TLS connections. The actual pre-sharing of the secret is outside the scope of the authentication mechanism.
</t>
<t>A typical authentication begins with the client sending a <spanx style="verb">HELLO</spanx> message specifying the <spanx style="verb">wampcra</spanx> method as (one of) the authentication methods:
</t>

<figure align="left"><artwork align="left">
    [1, "realm1",
        {
            "roles": ...,
            "authmethods": ["wampcra"],
            "authid": "peter"
        }
    ]
</artwork></figure>
<t>The <spanx style="verb">HELLO.Details.authmethods|list</spanx> is used by the client to announce the authentication methods it is prepared to perform. For WAMP-CRA, this MUST include <spanx style="verb">"wampcra"</spanx>.
</t>
<t>The <spanx style="verb">HELLO.Details.authid|string</spanx> is the authentication ID (e.g. username) the client wishes to authenticate as. For WAMP-CRA, this MUST be provided.
</t>
<t>If the server is unwilling or unable to perform WAMP-CRA authentication, it MAY either skip forward trying other authentication methods (if the client announced any) or send an <spanx style="verb">ABORT</spanx> message.
</t>
<t>If the server is willing to let the client authenticate using WAMP-CRA, and the server recognizes the provided <spanx style="verb">authid</spanx>, it MUST send a <spanx style="verb">CHALLENGE</spanx> message:
</t>

<figure align="left"><artwork align="left">
    [4, "wampcra",
        {
            "challenge": "{ \"nonce\": \"LHRTC9zeOIrt_9U3\", 
                \"authprovider\": \"userdb\", \"authid\": \"peter\",
                \"timestamp\": \"2014-06-22T16:36:25.448Z\", 
                \"authrole\": \"user\", \"authmethod\": \"wampcra\", 
                \"session\": 3251278072152162}"
        }
    ]
</artwork></figure>
<t>The <spanx style="verb">CHALLENGE.Details.challenge|string</spanx> is a string the client needs to create a signature for. The string MUST BE a JSON serialized object which MUST contain:
</t>
<t>
<list style="numbers">
<t><spanx style="verb">authid|string</spanx>: The authentication ID the client will be authenticated as when the authentication succeeds.</t>
<t><spanx style="verb">authrole|string</spanx>: The authentication role the client will be authenticated as when the authentication succeeds.</t>
<t><spanx style="verb">authmethod|string</spanx>: The authentication methods, here <spanx style="verb">"wampcra"</spanx></t>
<t><spanx style="verb">authprovider|string</spanx>: The actual provider of authentication. For WAMP-CRA, this can be freely chosen by the app, e.g. <spanx style="verb">userdb</spanx>.</t>
<t><spanx style="verb">nonce|string</spanx>: A random value.</t>
<t><spanx style="verb">timestamp|string</spanx>: The UTC timestamp (ISO8601 format) the authentication was started, e.g. <spanx style="verb">2014-06-22T16:51:41.643Z</spanx>.</t>
<t><spanx style="verb">session|int</spanx>: The WAMP session ID that will be assigned to the session once it is authenticated successfully.</t>
</list>
</t>
<t>The client needs to compute the signature as follows:
</t>

<figure align="left"><artwork align="left">
    signature := HMAC[SHA256]_{secret} (challenge)
</artwork></figure>
<t>That is, compute the HMAC-SHA256 using the shared <spanx style="verb">secret</spanx> over the <spanx style="verb">challenge</spanx>.
</t>
<t>After computing the signature, the client will send an <spanx style="verb">AUTHENTICATE</spanx> message containing the signature, as a base64-encoded string:
</t>

<figure align="left"><artwork align="left">
    [5, "gir1mSx+deCDUV7wRM5SGIn/+R/ClqLZuH4m7FJeBVI=", {}]
</artwork></figure>
<t>The server will then check if
</t>
<t>
<list style="symbols">
<t>the signature matches the one expected</t>
<t>the <spanx style="verb">AUTHENTICATE</spanx> message was sent in due time</t>
</list>
</t>
<t>If the authentication succeeds, the server will finally respond with a <spanx style="verb">WELCOME</spanx> message:
</t>

<figure align="left"><artwork align="left">
    [2, 3251278072152162,
        {
            "authid": "peter",
            "authrole": "user",
            "authmethod": "wampcra",
            "authprovider": "userdb",
            "roles": ...
        }
    ]
</artwork></figure>
<t>The <spanx style="verb">WELCOME.Details</spanx> again contain the actual authentication information active.
</t>
<t>If the authentication fails, the server will response with an <spanx style="verb">ABORT</spanx> message.
</t>

<section anchor="serverside-verification" title="Server-side Verification">
<t>The challenge sent during WAMP-CRA contains
</t>
<t>
<list style="numbers">
<t>random information (the <spanx style="verb">nonce</spanx>) to make WAMP-CRA robust against replay attacks</t>
<t>timestamp information (the <spanx style="verb">timestamp</spanx>) to allow WAMP-CRA timeout on authentication requests that took too long</t>
<t>session information (the <spanx style="verb">session</spanx>) to bind the authentication to a WAMP session ID</t>
<t>all the authentication information that relates to authorization like <spanx style="verb">authid</spanx> and <spanx style="verb">authrole</spanx></t>
</list>
</t>
</section>

<section anchor="threelegged-authentication" title="Three-legged Authentication">
<t>The signing of the challenge sent by the server usually is done directly on the client. However, this is no strict requirement.
</t>
<t>E.g. a client might forward the challenge to another party (hence the &quot;three-legged&quot;) for creating the signature. This can be used when the client was previously already authenticated to that third party, and WAMP-CRA should run piggy packed on that authentication.
</t>
<t>The third party would, upon receiving a signing request, simply check if the client is already authenticated, and if so, create a signature for WAMP-CRA.
</t>
<t>In this case, the secret is actually shared between the WAMP server who wants to authenticate clients using WAMP-CRA and the third party server, who shares a secret with the WAMP server.
</t>
<t>This scenario is also the reason the challenge sent with WAMP-CRA is not simply a random value, but a JSON serialized object containing sufficient authentication information for the thrid party to check.
</t>
</section>

<section anchor="password-salting" title="Password Salting">
<t>WAMP-CRA operates using a shared secret. While the secret is never sent over the wire, a shared secret often requires storage of that secret on the client and the server - and storing a password verbatim (unencrypted) is not recommended in general.
</t>
<t>WAMP-CRA allows the use of salted passwords following the <eref target="http://en.wikipedia.org/wiki/PBKDF2">PBKDF2</eref> key derivation scheme. With salted passwords, the password itself is never stored, but only a key derived from the password and a password salt. This derived key is then practically working as the new shared secret.
</t>
<t>When the password is salted, the server will during WAMP-CRA send a <spanx style="verb">CHALLENGE</spanx> message containing additional information:
</t>

<figure align="left"><artwork align="left">
    [4, "wampcra",
        {
            "challenge": "{ \"nonce\": \"LHRTC9zeOIrt_9U3\", 
                \"authprovider\": \"userdb\", \"authid\": \"peter\",
                \"timestamp\": \"2014-06-22T16:36:25.448Z\", 
                \"authrole\": \"user\", \"authmethod\": \"wampcra\", 
                \"session\": 3251278072152162}",
            "salt": "salt123",
            "keylen": 32,
            "iterations": 1000
        }
    ]
</artwork></figure>
<t>The <spanx style="verb">CHALLENGE.Details.salt|string</spanx> is the password salt in use. The <spanx style="verb">CHALLENGE.Details.keylen|int</spanx> and <spanx style="verb">CHALLENGE.Details.iterations|int</spanx> are parameters for the PBKDF2 algorithm.
</t>
</section>
</section>

<section anchor="ticketauth" title="Ticket-based Authentication">
<t>With <spanx style="emph">Ticket-based authentication</spanx>, the client needs to present the server an authentication &quot;ticket&quot; - some magic value to authenticate itself to the server.
</t>
<t>This &quot;ticket&quot; could be a long-lived, pre-agreed secret (e.g. a user password) or a short-lived authentication token (like a Kerberos token). WAMP does not care or interpret the ticket presented by the client.
</t>
<t><list style="empty">
<t>Caution: This scheme is extremely simple and flexible, but the resulting security may be limited. E.g., the ticket value will be sent over the wire. If the transport WAMP is running over is not encrypted, a man-in-the-middle can sniff and possibly hijack the ticket. If the ticket value is reused, that might enable replay attacks.
</t>
</list></t>
<t>A typical authentication begins with the client sending a <spanx style="verb">HELLO</spanx> message specifying the <spanx style="verb">ticket</spanx> method as (one of) the authentication methods:
</t>

<figure align="left"><artwork align="left">
    [1, "realm1",
      {
        "roles": ...,
        "authmethods": ["ticket"],
        "authid": "joe"
      }
    ]
</artwork></figure>
<t>The <spanx style="verb">HELLO.Details.authmethods|list</spanx> is used by the client to announce the authentication methods it is prepared to perform. For Ticket-based, this MUST include <spanx style="verb">"ticket"</spanx>.
</t>
<t>The <spanx style="verb">HELLO.Details.authid|string</spanx> is the authentication ID (e.g. username) the client wishes to authenticate as. For Ticket-based authentication, this MUST be provided.
</t>
<t>If the server is unwilling or unable to perform Ticket-based authentication, it'll either skip forward trying other authentication methods (if the client announced any) or send an <spanx style="verb">ABORT</spanx> message.
</t>
<t>If the server is willing to let the client authenticate using a ticket and the server recognizes the provided <spanx style="verb">authid</spanx>, it'll send a <spanx style="verb">CHALLENGE</spanx> message:
</t>

<figure align="left"><artwork align="left">
    [4, "ticket", {}]
</artwork></figure>
<t>The client will send an <spanx style="verb">AUTHENTICATE</spanx> message containing a ticket:
</t>

<figure align="left"><artwork align="left">
    [5, "secret!!!", {}]
</artwork></figure>
<t>The server will then check if the ticket provided is permissible (for the <spanx style="verb">authid</spanx> given).
</t>
<t>If the authentication succeeds, the server will finally respond with a <spanx style="verb">WELCOME</spanx> message:
</t>

<figure align="left"><artwork align="left">
    [2, 3251278072152162,
      {
        "authid": "joe",
        "authrole": "user",
        "authmethod": "ticket",
        "authprovider": "static",
        "roles": ...
      }
    ]
</artwork></figure>
<t>where
</t>
<t>
<list style="numbers">
<t><spanx style="verb">authid|string</spanx>: The authentication ID the client was (actually) authenticated as.</t>
<t><spanx style="verb">authrole|string</spanx>: The authentication role the client was authenticated for.</t>
<t><spanx style="verb">authmethod|string</spanx>: The authentication method, here <spanx style="verb">"ticket"</spanx></t>
<t><spanx style="verb">authprovider|string</spanx>: The actual provider of authentication. For Ticket-based authentication, this can be freely chosen by the app, e.g. <spanx style="verb">static</spanx> or <spanx style="verb">dynamic</spanx>.</t>
</list>
</t>
<t>The <spanx style="verb">WELCOME.Details</spanx> again contain the actual authentication information active. If the authentication fails, the server will response with an <spanx style="verb">ABORT</spanx> message.
</t>
</section>
</section>

<section anchor="alternative-transports" title="Alternative Transports">
<t>The only requirements that WAMP expects from a transport are: the transport must be message-based, bidirectional, reliable and ordered. This allows WAMP to run over different transports without any impact at the application layer.
</t>
<t>Besides the WebSocket transport, the following WAMP transports are currently specified:
</t>
<t>
<list style="symbols">
<t><xref target="rawsocket"/></t>
<t><xref target="batchedwebsocket"/></t>
<t><xref target="longpoll"/></t>
<t><xref target="multiplexed"/></t>
</list>
</t>
<t><list style="empty">
<t>Other transports such as HTTP 2.0 (&quot;SPDY&quot;) or UDP might be defined in the future.
</t>
</list></t>

<section anchor="rawsocket" title="RawSocket Transport">
<t><spanx style="strong">WAMP-over-RawSocket</spanx> is an (alternative) transport for WAMP that uses length-prefixed, binary messages - a message framing different from WebSocket.
</t>
<t>Compared to WAMP-over-WebSocket, WAMP-over-RawSocket is simple to implement, since there is no need to implement the WebSocket protocol which has some features that make it non-trivial (like a full HTTP-based opening handshake, message fragmentation, masking and variable length integers).
</t>
<t>WAMP-over-RawSocket has even lower overhead than WebSocket, which can be desirable in particular when running on local connections like loopback TCP or Unix domain sockets. It is also expected to allow implementations in microcontrollers in under 2KB RAM.
</t>
<t>WAMP-over-RawSocket can run over TCP, TLS, Unix domain sockets or any reliable streaming underlying transport. When run over TLS on the standard port for secure HTTPS (443), it is also able to traverse most locked down networking environments such as enterprise or mobile networks (unless man-in-the-middle TLS intercepting proxies are in use).
</t>
<t>However, WAMP-over-RawSocket cannot be used with Web browser clients, since browsers do not allow raw TCP connections. Browser extensions would do, but those need to be installed in a browser. WAMP-over-RawSocket also (currently) does not support transport-level compression as WebSocket does provide (<spanx style="verb">permessage-deflate</spanx> WebSocket extension).
</t>

<section anchor="endianess" title="Endianess">
<t>WAMP-over-RawSocket uses <spanx style="emph">network byte order</spanx> (&quot;big-endian&quot;). That means, given a unsigned 32 bit integer
</t>

<figure align="left"><artwork align="left">
    0x 11 22 33 44
</artwork></figure>
<t>the first octet sent out to (or received from) the wire is <spanx style="verb">0x11</spanx> and the last octet sent out (or received) is <spanx style="verb">0x44</spanx>.
</t>
<t>Here is how you would convert octets received from the wire into an integer in Python:
</t>

<figure align="left"><artwork align="left">
    &lt;CODE BEGINS&gt;
    import struct
    
    octets_received = b"\x11\x22\x33\x44"
    i = struct.unpack("&gt;L", octets_received)[0]
    &lt;CODE ENDS&gt;
</artwork></figure>
<t>The integer received has the value <spanx style="verb">287454020</spanx>.
</t>
<t>And here is how you would send out an integer to the wire in Python:
</t>

<figure align="left"><artwork align="left">
    &lt;CODE BEGINS&gt;
    octets_to_be_send = struct.pack("&gt;L", i)
    &lt;CODE ENDS&gt;
</artwork></figure>
<t>The octets to be sent are <spanx style="verb">b"\x11\x22\x33\x44"</spanx>.
</t>
</section>

<section anchor="handshake" title="Handshake">
<t><spanx style="strong">Client-to-Router Request</spanx>
</t>
<t>WAMP-over-RawSocket starts with a handshake where the client connecting to a router sends 4 octets:
</t>

<figure align="left"><artwork align="left">
    MSB                                 LSB
    31                                    0
    0111 1111 LLLL SSSS RRRR RRRR RRRR RRRR
</artwork></figure>
<t>The <spanx style="emph">first octet</spanx> is a magic octet with value <spanx style="verb">0x7F</spanx>. This value is chosen to avoid any possible collision with the first octet of a valid HTTP request (see <eref target="http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1">here</eref> and <eref target="http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2">here</eref>). No valid HTTP request can have <spanx style="verb">0x7F</spanx> as its first octet.
</t>
<t><list style="empty">
<t>By using a magic first octet that cannot appear in a regular HTTP request, WAMP-over-RawSocket can be run e.g. on the same TCP listening port as WAMP-over-WebSocket or WAMP-over-LongPoll.
</t>
</list></t>
<t>The <spanx style="emph">second octet</spanx> consists of a 4 bit <spanx style="verb">LENGTH</spanx> field and a 4 bit <spanx style="verb">SERIALIZER</spanx> field.
</t>
<t>The <spanx style="verb">LENGTH</spanx> value is used by the <spanx style="emph">Client</spanx> to signal the <spanx style="strong">maximum message length</spanx> of messages it is willing to <spanx style="strong">receive</spanx>. When the handshake completes successfully, a <spanx style="emph">Router</spanx> MUST NOT send messages larger than this size.
</t>
<t>The possible values for <spanx style="verb">LENGTH</spanx> are:
</t>

<figure align="left"><artwork align="left">
     0: 2**9 octets
     1: 2**10 octets
    ...
    15: 2**24 octets
</artwork></figure>
<t>This means a <spanx style="emph">Client</spanx> can choose the maximum message length between <spanx style="strong">512</spanx> and <spanx style="strong">16M</spanx> octets.
</t>
<t>The <spanx style="verb">SERIALIZER</spanx> value is used by the <spanx style="emph">Client</spanx> to request a specific serializer to be used. When the handshake completes successfully, the <spanx style="emph">Client</spanx> and <spanx style="emph">Router</spanx> will use the serializer requested by the <spanx style="emph">Client</spanx>.
</t>
<t>The possible values for <spanx style="verb">SERIALIZER</spanx> are:
</t>

<figure align="left"><artwork align="left">
    0: illegal
    1: JSON
    2: MessagePack
    3 - 15: reserved for future serializers
</artwork></figure>
<t>Here is a Python program that prints all (currently) permissible values for the <spanx style="emph">second octet</spanx>:
</t>

<figure align="center"><artwork align="center">
    &lt;CODE BEGINS&gt;
    SERMAP = {
       1: 'json',
       2: 'messagepack'
    }

    ## map serializer / max. msg length to RawSocket handshake  
    ## request or success reply (2nd octet)
    ##
    for ser in SERMAP:
       for l in range(16):
          octet_2 = (l &lt;&lt; 4) | ser
          print("serializer: {}, maxlen: {} =&gt; 
              0x{:02x}".format(SERMAP[ser], 2 ** (l + 9), octet_2))
    &lt;CODE ENDS&gt;
</artwork></figure>
<t>The <spanx style="emph">third and forth octet</spanx> are <spanx style="strong">reserved</spanx> and MUST be all zeros for now.
</t>
<t><spanx style="strong">Router-to-Client Reply</spanx>
</t>
<t>After a <spanx style="emph">Client</spanx> has connected to a <spanx style="emph">Router</spanx>, the <spanx style="emph">Router</spanx> will first receive the 4 octets handshake request from the <spanx style="emph">Client</spanx>.
</t>
<t>If the <spanx style="emph">first octet</spanx> differs from <spanx style="verb">0x7F</spanx>, it is not a WAMP-over-RawSocket request. Unless the <spanx style="emph">Router</spanx> also supports other transports on the connecting port (such as WebSocket or LongPoll), the <spanx style="emph">Router</spanx> MUST <spanx style="strong">fail the connection</spanx>.
</t>
<t>Here is an example of how a <spanx style="emph">Router</spanx> could parse the <spanx style="emph">second octet</spanx> in a <spanx style="emph">Clients</spanx> handshake request:
</t>

<figure align="left"><artwork align="left">
    &lt;CODE BEGINS&gt;
    ## map RawSocket handshake request (2nd octet) to 
    ## serializer / max. msg length
    ##
    for i in range(256):
       ser_id = i &amp; 0x0f
       if ser_id != 0:
          ser = SERMAP.get(ser_id, 'currently undefined')
          maxlen = 2 ** ((i &gt;&gt; 4) + 9)
          print("{:02x} =&gt; serializer: {}, maxlen: {}".
              format(i, ser, maxlen))
       else:
          print("fail the connection: illegal serializer value")
    &lt;CODE ENDS&gt;
</artwork></figure>
<t>When the <spanx style="emph">Router</spanx> is willing to speak the serializer requested by the <spanx style="emph">Client</spanx>, it will answer with a 4 octets response of identical structure as the <spanx style="emph">Client</spanx> request:
</t>

<figure align="left"><artwork align="left">
    MSB                                 LSB
    31                                    0
    0111 1111 LLLL SSSS RRRR RRRR RRRR RRRR
</artwork></figure>
<t>Again, the <spanx style="emph">first octet</spanx> MUST be the value <spanx style="verb">0x7F</spanx>. The <spanx style="emph">third and forth octets</spanx> are reserved and MUST be all zeros for now.
</t>
<t>In the <spanx style="emph">second octet</spanx>, the <spanx style="emph">Router</spanx> MUST echo the serializer value in <spanx style="verb">SERIALIZER</spanx> as requested by the <spanx style="emph">Client</spanx>.
</t>
<t>Similar to the <spanx style="emph">Client</spanx>, the <spanx style="emph">Router</spanx> sets the <spanx style="verb">LENGTH</spanx> field to request a limit on the length of messages sent by the <spanx style="emph">Client</spanx>.
</t>
<t>During the connection, <spanx style="emph">Router</spanx> MUST NOT send messages to the <spanx style="emph">Client</spanx> longer than the <spanx style="verb">LENGTH</spanx> requested by the <spanx style="emph">Client</spanx>, and the <spanx style="emph">Client</spanx> MUST NOT send messages larger than the maximum requested by the <spanx style="emph">Router</spanx> in its handshake reply.
</t>
<t>If a message received during a connection exceeds the limit requested, a <spanx style="emph">Peer</spanx> MUST <spanx style="strong">fail the connection</spanx>.
</t>
<t>When the <spanx style="emph">Router</spanx> is unable to speak the serializer requested by the <spanx style="emph">Client</spanx>, or it is denying the <spanx style="emph">Client</spanx> for other reasons, the <spanx style="emph">Router</spanx> replies with an error:
</t>

<figure align="left"><artwork align="left">
    MSB                                 LSB
    31                                    0
    0111 1111 EEEE 0000 RRRR RRRR RRRR RRRR
</artwork></figure>
<t>An error reply has 4 octets: the <spanx style="emph">first octet</spanx> is again the magic <spanx style="verb">0x7F</spanx>, and the <spanx style="emph">third and forth octet</spanx> are reserved and MUST all be zeros for now.
</t>
<t>The <spanx style="emph">second octet</spanx> has its lower 4 bits zero'ed (which distinguishes the reply from an success/accepting reply) and the upper 4 bits encode the error:
</t>

<figure align="left"><artwork align="left">
    0: illegal (must not be used)
    1: serializer unsupported
    2: maximum message length unacceptable
    3: use of reserved bits (unsupported feature)
    4: maximum connection count reached
    5 - 15: reserved for future errors
</artwork></figure>
<t><list style="empty">
<t>Note that the error code <spanx style="verb">0</spanx> MUST NOT be used. This is to allow storage of error state in a host language variable, while allowing <spanx style="verb">0</spanx> to signal the current state &quot;no error&quot;
</t>
</list></t>
<t>Here is an example of how a <spanx style="emph">Router</spanx> might create the <spanx style="emph">second octet</spanx> in an error response:
</t>

<figure align="left"><artwork align="left">
    &lt;CODE BEGINS&gt;
    ERRMAP = {
       0: "illegal (must not be used)",
       1: "serializer unsupported",
       2: "maximum message length unacceptable",
       3: "use of reserved bits (unsupported feature)",
       4: "maximum connection count reached"
    }

    ## map error to RawSocket handshake error reply (2nd octet)
    ##
    for err in ERRMAP:
       octet_2 = err &lt;&lt; 4
       print("error: {} =&gt; 0x{:02x}").format(ERRMAP[err], err)
    &lt;CODE ENDS&gt;
</artwork></figure>
<t>The <spanx style="emph">Client</spanx> - after having sent its handshake request - will wait for the 4 octets from <spanx style="emph">Router</spanx> handshake reply.
</t>
<t>Here is an example of how a <spanx style="emph">Client</spanx> might parse the <spanx style="emph">second octet</spanx> in a <spanx style="emph">Router</spanx> handshake reply:
</t>

<figure align="left"><artwork align="left">
    &lt;CODE BEGINS&gt;
    ## map RawSocket handshake reply (2nd octet)
    ##
    for i in range(256):
       ser_id = i &amp; 0x0f
       if ser_id:
          ## verify the serializer is the one we requested! 
          ## if not, fail the connection!
          ser = SERMAP.get(ser_id, 'currently undefined')
          maxlen = 2 ** ((i &gt;&gt; 4) + 9)
          print("{:02x} =&gt; serializer: {}, maxlen: {}".
              format(i, ser, maxlen))
       else:
          err = i &gt;&gt; 4
          print("error: {}".format(ERRMAP.get(err, 
              'currently undefined')))
    &lt;CODE ENDS&gt;
</artwork></figure>
</section>

<section anchor="serialization" title="Serialization">
<t>To send a WAMP message, the message is serialized according to the WAMP serializer agreed in the handshake (e.g. JSON or MessagePack).
</t>
<t>The length of the serialized messages in octets MUST NOT exceed the maximum requested by the <spanx style="emph">Peer</spanx>.
</t>
<t>If the serialized length exceed the maximum requested, the WAMP message can not be sent to the <spanx style="emph">Peer</spanx>. Handling situations like the latter is left to the implementation.
</t>
<t>E.g. a <spanx style="emph">Router</spanx> that is to forward a WAMP <spanx style="verb">EVENT</spanx> to a <spanx style="emph">Client</spanx> which exceeds the maximum length requested by the <spanx style="emph">Client</spanx> when serialized might:
</t>
<t>
<list style="symbols">
<t>drop the event (not forwarding to that specific client) and track dropped events</t>
<t>prohibit publishing to the topic already</t>
<t>remove the event payload, and send an event with extra information (<spanx style="verb">payload_limit_exceeded = true</spanx>)</t>
</list>
</t>
</section>

<section anchor="framing" title="Framing">
<t>The serialized octets for a message to be sent are prefixed with exactly 4 octets.
</t>

<figure align="left"><artwork align="left">
    MSB                                 LSB
    31                                    0
    RRRR RTTT LLLL LLLL LLLL LLLL LLLL LLLL
</artwork></figure>
<t>The <spanx style="emph">first octet</spanx> has the following structure
</t>

<figure align="left"><artwork align="left">
    MSB   LSB
    7       0
    RRRR RTTT
</artwork></figure>
<t>The five bits <spanx style="verb">RRRRR</spanx> are reserved for future use and MUST be all zeros for now.
</t>
<t>The three bits <spanx style="verb">TTT</spanx> encode the type of the transport message:
</t>

<figure align="left"><artwork align="left">
    0: regular WAMP message
    1: PING
    2: PONG
    3-7: reserved
</artwork></figure>
<t>The <spanx style="emph">three remaining octets</spanx> constitute an unsigned 24 bit integer that provides the length of transport message payload following, excluding the 4 octets that constitute the prefix.
</t>
<t>For a regular WAMP message (<spanx style="verb">TTT == 0</spanx>), the length is the length of the serialized WAMP message: the number of octets after serialization (excluding the 4 octets of the prefix).
</t>
<t>For a <spanx style="verb">PING</spanx> message (<spanx style="verb">TTT == 1</spanx>), the length is the length of the arbitrary payload that follows. A <spanx style="emph">Peer</spanx> MUST reply to each <spanx style="verb">PING</spanx> by sending exactly one <spanx style="verb">PONG</spanx> immediately, and the <spanx style="verb">PONG</spanx> MUST echo back the payload of the <spanx style="verb">PING</spanx> exactly.
</t>
<t>For receiving messages with WAMP-over-RawSocket, a <spanx style="emph">Peer</spanx> will usually read exactly 4 octets from the incoming stream, decode the transport level message type and payload length, and then receive as many octets as the length was giving.
</t>
<t>When the transport level message type indicates a regular WAMP message, the transport level message payload is unserialized according to the serializer agreed in the handshake and the processed at the WAMP level.
</t>
</section>
</section>

<section anchor="batchedwebsocket" title="Batched WebSocket Transport for WAMP">
<t><spanx style="emph">WAMP-over-Batched-WebSocket</spanx> is a variant of WAMP-over-WebSocket where multiple WAMP messages are sent in one WebSocket message.
</t>
<t>Using WAMP message batching can increase wire level efficiency further. In particular when using TLS and the WebSocket implementation is forcing every WebSocket message into a new TLS segment.
</t>
<t>WAMP-over-Batched-WebSocket is negotiated between Peers in the WebSocket opening handshake by agreeing on one of the following WebSocket subprotocols:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">wamp.2.json.batched</spanx></t>
<t><spanx style="verb">wamp.2.msgpack.batched</spanx></t>
</list>
</t>
<t>Batching with JSON works by serializing each WAMP message to JSON as normally, appending the single ASCII control character <spanx style="verb">\30</spanx> (<eref target="http://en.wikipedia.org/wiki/Record_separator#Field_separators">record separator</eref>) octet <spanx style="verb">0x1e</spanx> to <spanx style="emph">each</spanx> serialized messages, and packing a sequence of such serialized messages into a single WebSocket message:
</t>

<figure align="left"><artwork align="left">
    Serialized JSON WAMP Msg 1 | 0x1e | 
        Serialized JSON WAMP Msg 2 | 0x1e | ...
</artwork></figure>
<t>Batching with MessagePack works by serializing each WAMP message to MessagePack as normally, prepending a 32 bit unsigned integer (4 octets in big-endian byte order) with the length of the serialized MessagePack message (excluding the 4 octets for the length prefix), and packing a sequence of such serialized (length-prefixed) messages into a single WebSocket message:
</t>

<figure align="left"><artwork align="left">
    Length of Msg 1 serialization (uint32) | 
        serialized MessagePack WAMP Msg 1 | ...
</artwork></figure>
<t>With batched transport, even if only a single WAMP message is to be sent in a WebSocket message, the (single) WAMP message needs to be framed as described above. In other words, a single WAMP message is sent as a batch of length <spanx style="strong">1</spanx>. Sending a batch of length <spanx style="strong">0</spanx> (no WAMP message) is illegal and a <spanx style="emph">Peer</spanx> MUST fail the transport upon receiving such a transport message.
</t>
</section>

<section anchor="longpoll" title="A HTTP Longpoll Transport for WAMP">
<t>The <spanx style="emph">Long-Poll Transport</spanx> is able to transmit a WAMP session over plain old HTTP 1.0/1.1. This is realized by the Client issuing HTTP/POSTs requests, one for sending, and one for receiving. Those latter requests are kept open at the server when there are no messages currently pending to be received.
</t>
<t><spanx style="strong">Opening a Session</spanx>
</t>
<t>With the Long-Poll Transport, a Client opens a new WAMP session by sending a HTTP/POST request to a well-known URL, e.g.
</t>

<figure align="left"><artwork align="left">
    http://mypp.com/longpoll/open
</artwork></figure>
<t>Here, <spanx style="verb">http://mypp.com/longpoll</spanx> is the base URL for the Long-Poll Transport and <spanx style="verb">/open</spanx> is a path dedicated for opening new sessions.
</t>
<t>The HTTP/POST request SHOULD have a <spanx style="verb">Content-Type</spanx> header set to <spanx style="verb">application/json</spanx> and MUST have a request body with a JSON document that is a dictionary:
</t>

<figure align="left"><artwork align="left">
    {
       "protocols": ["wamp.2.json"]
    }
</artwork></figure>
<t>The (mandatory) <spanx style="verb">protocols</spanx> attribute specifies the protocols the client is willing to speak. The server will chose one from this list when establishing the session or fail the request when no protocol overlap was found.
</t>
<t>The valid protocols are:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">wamp.2.json.batched</spanx></t>
<t><spanx style="verb">wamp.2.json</spanx></t>
<t><spanx style="verb">wamp.2.msgpack.batched</spanx></t>
<t><spanx style="verb">wamp.2.msgpack</spanx></t>
</list>
</t>
<t><list style="empty">
<t>The request path with this and subsequently described HTTP/POST requests MAY contain a query parameter <spanx style="verb">x</spanx> with some random or sequentially incremented value:
</t>
<t><eref target="http://mypp.com/longpoll/open?x=382913"/>
</t>
<t>The value is ignored, but may help in certain situations to prevent intermediaries from caching the request.
</t>
</list></t>
<t>Returned is a JSON document containing a transport ID and the protocol to speak:
</t>

<figure align="left"><artwork align="left">
    {
       "protocol": "wamp.2.json",
       "transport": "kjmd3sBLOUnb3Fyr"
    }
</artwork></figure>
<t>As an implied side-effect, two HTTP endpoints are created
</t>

<figure align="left"><artwork align="left">
    http://mypp.com/longpoll/&lt;transport_id&gt;/receive
    http://mypp.com/longpoll/&lt;transport_id&gt;/send
</artwork></figure>
<t>where <spanx style="verb">transport_id</spanx> is the transport ID returned from <spanx style="verb">open</spanx>, e.g.
</t>

<figure align="left"><artwork align="left">
    http://mypp.com/longpoll/kjmd3sBLOUnb3Fyr/receive
    http://mypp.com/longpoll/kjmd3sBLOUnb3Fyr/send
</artwork></figure>
<t><spanx style="strong">Receiving WAMP Messages</spanx>
</t>
<t>The Client will then issue HTTP/POST requests (with empty request body) to
</t>

<figure align="left"><artwork align="left">
    http://mypp.com/longpoll/kjmd3sBLOUnb3Fyr/receive
</artwork></figure>
<t>When there are WAMP messages pending downstream, a request will return with a single WAMP message (unbatched modes) or a batch of serialized WAMP messages (batched mode).
</t>
<t>The serialization format used is the one agreed during opening the session.
</t>
<t>The batching uses the same scheme as with <spanx style="verb">wamp.2.json.batched</spanx> and <spanx style="verb">wamp.2.msgpack.batched</spanx> transport over WebSocket.
</t>
<t><list style="empty">
<t>Note: In unbatched mode, when there is more than one message pending, there will be at most one message returned for each request. The other pending messages must be retrieved by new requests. With batched mode, all messages pending at request time will be returned in one batch of messages.
</t>
</list></t>
<t><spanx style="strong">Sending WAMP Messages</spanx>
</t>
<t>For sending WAMP messages, the <spanx style="emph">Client</spanx> will issue HTTP/POST requests to
</t>

<figure align="left"><artwork align="left">
    http://mypp.com/longpoll/kjmd3sBLOUnb3Fyr/send
</artwork></figure>
<t>with request body being a single WAMP message (unbatched modes) or a batch of serialized WAMP messages (batched mode).
</t>
<t>The serialization format used is the one agreed during opening the session.
</t>
<t>The batching uses the same scheme as with <spanx style="verb">wamp.2.json.batched</spanx> and <spanx style="verb">wamp.2.msgpack.batched</spanx> transport over WebSocket.
</t>
<t>Upon success, the request will return with HTTP status code 202 (&quot;no content&quot;). Upon error, the request will return with HTTP status code 400 (&quot;bad request&quot;).
</t>
<t><spanx style="strong">Closing a Session</spanx>
</t>
<t>To orderly close a session, a Client will issue a HTTP/POST to
</t>

<figure align="left"><artwork align="left">
    http://mypp.com/longpoll/kjmd3sBLOUnb3Fyr/close
</artwork></figure>
<t>with an empty request body. Upon success, the request will return with HTTP status code 202 (&quot;no content&quot;).
</t>
</section>

<section anchor="multiplexed" title="Multiplexed Transport">
<t>A Transport may support the multiplexing of multiple logical transports over a single &quot;physical&quot; transport.
</t>
<t>By using such a Transport, multiple WAMP sessions can be transported over a single underlying transport at the same time.
</t>
<t>As an example, the proposed <eref target="https://github.com/oberstet/permessage-priority/blob/master/draft-oberstein-hybi-permessage-priority.txt">WebSocket extension &quot;permessage-priority&quot;</eref> would allow creating multiple logical Transports for WAMP over a single underlying WebSocket connection.
</t>
<t>Sessions running over a multiplexed Transport are completely independent: they get assigned different session IDs, may join different realms and each session needs to authenticate itself.
</t>
<t>Because of above, Multiplexed Transports for WAMP are actually not detailed in the WAMP spec, but a feature of the transport being used.
</t>
<t><list style="empty">
<t>Note: Currently no WAMP transport supports multiplexing. The work on the MUX extension with WebSocket has stalled, and the <spanx style="verb">permessage-priority</spanx> proposal above is still just a proposal. However, with RawSocket, we should be able to add multiplexing in the the future (with downward compatibility).
</t>
</list></t>
</section>
</section>
</section>
</section>

<section anchor="binary-conversion-of-json-strings" title="Binary conversion of JSON Strings">
<t>Binary data follows a convention for conversion to JSON strings.
</t>
<t>A byte array is converted to a JSON string as follows:
</t>
<t>
<list style="numbers">
<t>convert the byte array to a Base64 encoded (host language) string</t>
<t>prepend the string with a <spanx style="verb">\0</spanx> character</t>
<t>serialize the string to a JSON string</t>
</list>
</t>
<t>where Base64 encoding follows Section 4 of <xref target="RFC4648"/>.
</t>
<t><spanx style="emph">Example</spanx>
</t>
<t>Consider the byte array (hex representation):
</t>

<figure align="left"><artwork align="left">
    10e3ff9053075c526f5fc06d4fe37cdb
</artwork></figure>
<t>This will get converted to Base64
</t>

<figure align="left"><artwork align="left">
    EOP/kFMHXFJvX8BtT+N82w==
</artwork></figure>
<t>prepended with <spanx style="verb">\0</spanx>
</t>

<figure align="left"><artwork align="left">
    \x00EOP/kFMHXFJvX8BtT+N82w==
</artwork></figure>
<t>and serialized to a JSON string
</t>

<figure align="left"><artwork align="left">
    "\\u0000EOP/kFMHXFJvX8BtT+N82w=="
</artwork></figure>
<t>A JSON string is unserialized to either a string or a byte array using the following procedure:
</t>
<t>
<list style="numbers">
<t>Unserialize a JSON string to a host language (Unicode) string</t>
<t>If the string starts with a <spanx style="verb">\0</spanx> character, interpret the rest (after the first character) as Base64 and decode to a byte array</t>
<t>Otherwise, return the Unicode string</t>
</list>
</t>
<t>Below are complete Python and JavaScript code examples for conversion between byte arrays and JSON strings.
</t>

<section anchor="python" title="Python">
<t>Here is a complete example in Python showing how byte arrays are converted to and from JSON:
</t>

<figure align="left"><artwork align="left">
    &lt;CODE BEGINS&gt;

    import os, base64, json, sys, binascii
    PY3 = sys.version_info &gt;= (3,)
    if PY3:
       unicode = str

    data_in = os.urandom(16)
    print("In:   {}".format(binascii.hexlify(data_in)))

    ## encoding
    encoded = json.dumps('\0' + base64.b64encode(data_in).
                                          decode('ascii'))

    print("JSON: {}".format(encoded))

    ## decoding
    decoded = json.loads(encoded)
    if type(decoded) == unicode:
       if decoded[0] == '\0':
          data_out = base64.b64decode(decoded[1:])
       else:
          data_out = decoded

    print("Out:  {}".format(binascii.hexlify(data_out)))

    assert(data_out == data_in)

    &lt;CODE ENDS&gt;
</artwork></figure>
</section>

<section anchor="javascript" title="JavaScript">
<t>Here is a complete example in JavaScript showing how byte arrays are converted to and from JSON:
</t>

<figure align="left"><artwork align="left">
    &lt;CODE BEGINS&gt;

    var data_in = new Uint8Array(new ArrayBuffer(16));

    // initialize test data
    for (var i = 0; i &lt; data_in.length; ++i) {
       data_in[i] = i;
    }
    console.log(data_in);

    // convert byte array to raw string
    var raw_out = '';
    for (var i = 0; i &lt; data_in.length; ++i) {
       raw_out += String.fromCharCode(data_in[i]);
    }

    // base64 encode raw string, prepend with \0
    // and serialize to JSON
    var encoded = JSON.stringify("\0" + window.btoa(raw_out));
    console.log(encoded); // "\u0000AAECAwQFBgcICQoLDA0ODw=="

    // unserialize from JSON
    var decoded = JSON.parse(encoded);

    var data_out;
    if (decoded.charCodeAt(0) === 0) {
       // strip first character and decode base64 to raw string
       var raw = window.atob(decoded.substring(1));

       // convert raw string to byte array
       var data_out = new Uint8Array(new ArrayBuffer(raw.length));
       for (var i = 0; i &lt; raw.length; ++i) {
          data_out[i] = raw.charCodeAt(i);
       }
    } else {
       data_out = decoded;
    }

    console.log(data_out);

    &lt;CODE ENDS&gt;
</artwork></figure>
</section>
</section>

<section anchor="security-considerations" title="Security Considerations">
<t>-- write me --
</t>
</section>

<section anchor="iana-considerations" title="IANA Considerations">
<t>TBD
</t>
</section>

<section anchor="contributors" title="Contributors">
</section>

<section anchor="acknowledgements" title="Acknowledgements">
<t>WAMP was developed in an open process from the beginning, and a lot of people have contributed ideas and other feedback. Here we are listing people who have opted in to being mentioned:
</t>
<t>
<list style="symbols">
<t>Konstantin Burkalev</t>
<t>Emile Cormier</t>
</list>
</t>
</section>

</middle>
<back>
<references title="Normative References">
<?rfc include="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3629.xml"?>
<?rfc include="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3986.xml"?>
<?rfc include="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4648.xml"?>
<?rfc include="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6455.xml"?>
</references>
<references title="Informative References">
<?rfc include="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"?>
</references>

</back>
</rfc>
